[{"categories":null,"contents":"最近在 GCP 上，中南美洲的網路流量讓我每個月多花了好幾十塊\u0026hellip;台幣，對免費仔而言實在有點不能接受！其實，我們可以從 IP 層面直接把這些不必要的流量擋掉。\n為什麼要擋流量？ 如果你的網站或服務主要受眾不在中南美洲，那麼來自這些地區的流量很可能是惡意掃描、DDoS 攻擊的嘗試，或是其他你不需要的連線。擋掉這些流量，除了能省下荷包，也能降低主機的負擔，提升安全性。\n如何實現 IP 層級封鎖？ 對於 Linux 主機或虛擬機器 (VM)，最直接、開源且有效的方法就是使用 iptables 或 nftables。這兩者都是 Linux 內建的防火牆工具，可以在 IP 層級進行精準的流量控制。\n不過，光有 iptables/nftables 還不夠，我們需要一個方式來識別哪些 IP 屬於中南美洲。這時候就需要搭配：\nxtables-addons (或類似的腳本工具，例如 geoip-shell)：這些工具能讓你根據地理位置來設定防火牆規則。 MaxMind GeoLite2 資料庫：這是一個免費的地理位置 IP 資料庫，它會告訴你每個 IP 位址來自哪個國家或地區。 讓工具自動搞定！ 手動去找出中南美洲的所有 IP 範圍，然後一條一條地加到防火牆規則裡，那也太費時了！開源專案 friendly-bits/geoip-shell 已經為我們把這項工作簡化了許多。\n透過這個專案，可以：\n自動生成防火牆規則：它會根據 MaxMind GeoLite2 資料庫，自動產生針對特定國家或地區的 IP 封鎖規則。 排程自動更新 IP：IP 位址的歸屬可能會變動，geoip-shell 還能設定排程，自動更新 GeoLite2 資料庫和防火牆規則，確保你的封鎖列表始終保持最新。\n這樣一來，就能輕鬆地從 IP 層面阻擋來自中南美洲的流量，有效控制 GCP 的網路費用，同時提升主機的安全性！ # 安裝 geoip-shell\r# 根據其 GitHub 說明進行安裝\r# 生成封鎖南美洲的規則\rsudo geoip-shell block --countries AR,BO,BR,CL,CO,EC,GF,GY,PY,PE,SR,UY,VE\r","date":"June 3, 2025","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/firewall/geoip/","summary":"\u003cp\u003e最近在 GCP 上，中南美洲的網路流量讓我每個月多花了好幾十塊\u0026hellip;台幣，對免費仔而言實在有點不能接受！其實，我們可以從 IP 層面直接把這些不必要的流量擋掉。\u003c/p\u003e\n\u003ch2 id=\"為什麼要擋流量\"\u003e為什麼要擋流量？\u003c/h2\u003e\n\u003cp\u003e如果你的網站或服務主要受眾不在中南美洲，那麼來自這些地區的流量很可能是惡意掃描、DDoS 攻擊的嘗試，或是其他你不需要的連線。擋掉這些流量，除了能省下荷包，也能降低主機的負擔，提升安全性。\u003c/p\u003e\n\u003ch2 id=\"如何實現-ip-層級封鎖\"\u003e如何實現 IP 層級封鎖？\u003c/h2\u003e\n\u003cp\u003e對於 Linux 主機或虛擬機器 (VM)，最直接、開源且有效的方法就是使用 iptables 或 nftables。這兩者都是 Linux 內建的防火牆工具，可以在 IP 層級進行精準的流量控制。\u003c/p\u003e\n\u003cp\u003e不過，光有 iptables/nftables 還不夠，我們需要一個方式來識別哪些 IP 屬於中南美洲。這時候就需要搭配：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003extables-addons (或類似的腳本工具，例如 geoip-shell)：這些工具能讓你根據地理位置來設定防火牆規則。\u003c/li\u003e\n\u003cli\u003eMaxMind GeoLite2 資料庫：這是一個免費的地理位置 IP 資料庫，它會告訴你每個 IP 位址來自哪個國家或地區。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"讓工具自動搞定\"\u003e讓工具自動搞定！\u003c/h2\u003e\n\u003cp\u003e手動去找出中南美洲的所有 IP 範圍，然後一條一條地加到防火牆規則裡，那也太費時了！開源專案 \u003ccode\u003efriendly-bits/geoip-shell\u003c/code\u003e 已經為我們把這項工作簡化了許多。\u003c/p\u003e\n\u003cp\u003e透過這個專案，可以：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e自動生成防火牆規則：它會根據 MaxMind GeoLite2 資料庫，自動產生針對特定國家或地區的 IP 封鎖規則。\u003c/li\u003e\n\u003cli\u003e排程自動更新 IP：IP 位址的歸屬可能會變動，geoip-shell 還能設定排程，自動更新 GeoLite2 資料庫和防火牆規則，確保你的封鎖列表始終保持最新。\u003cbr\u003e\n這樣一來，就能輕鬆地從 IP 層面阻擋來自中南美洲的流量，有效控制 GCP 的網路費用，同時提升主機的安全性！\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 安裝 geoip-shell\r\n# 根據其 GitHub 說明進行安裝\r\n\r\n# 生成封鎖南美洲的規則\r\nsudo geoip-shell block --countries AR,BO,BR,CL,CO,EC,GF,GY,PY,PE,SR,UY,VE\r\n\u003c/code\u003e\u003c/pre\u003e","tags":null,"title":"[防火牆] 地理位置規則(GeoIP)"},{"categories":null,"contents":"定義一個 Network，叫做 MYNAT，關閉 DHCP。\n新增一部虛擬機，定義兩張網卡：\n預設 NAT：用來模擬 ISP 裝置。(enp0s3) MYNAT：用來建構內網。(enp0s8) 開啟網卡 promisc ip link set enp0s3 promisc on ip link set enp0s8 promisc on ###. 建立 docker 網路 查詢路由所在網段、遮罩、閘道器。\nip route show dev enp0s3\r結果：軟路由所在網段、遮罩為 10.0.2.0/24、閘道器 10.0.2.2。\ndefault via 10.0.2.2 proto dhcp src 10.0.2.15 metric 1024\r10.0.2.0/24 proto kernel scope link src 10.0.2.15 metric 1024\r10.0.2.2 proto dhcp scope link src 10.0.2.15 metric 1024\r192.73.141.230 via 10.0.2.2 proto dhcp src 10.0.2.15 metric 1024\r192.73.144.230 via 10.0.2.2 proto dhcp src 10.0.2.15 metric 1024\r創建 docker 網路\n#!/bin/bash\rdocker network rm openwrt-wan\rdocker network create -d macvlan \\\r--subnet=10.0.2.0/24 \\\r--gateway=10.0.2.2 \\\r-o parent=enp0s3 openwrt-wan\rdocker network rm openwrt-lan\rdocker network create -d macvlan \\\r--subnet=10.0.3.0/24 \\\r--gateway=10.0.3.254 \\\r-o parent=enp0s8 openwrt-lan\r製作 OpenWrt 容器 docker-compose.yml\nversion: '3'\rservices:\ropenwrt:\rimage: zzsrv/openwrt:latest\rcontainer_name: openwrt\rrestart: always\rprivileged: true\rvolumes:\r- ./network:/etc/config/network\rnetworks:\r- openwrt-wan\r- openwrt-lan\rcommand: /sbin/init\rnetworks:\ropenwrt-wan:\rexternal: true\ropenwrt-lan:\rexternal: true\r啟動\ndocker-compose up -d \u0026amp;\u0026amp; docker-compose logs -f\r設定容器的網路\ndocker exec -it openwrt bash\r/etc/config/network 改成這樣：\nconfig interface 'loopback'\roption proto 'static'\roption ipaddr '127.0.0.1'\roption netmask '255.0.0.0'\roption device 'lo'\rconfig globals 'globals'\roption packet_steering '1'\rconfig interface 'lan'\roption proto 'static'\roption ipaddr '10.0.3.254'\roption netmask '255.255.255.0'\roption device 'br-lan'\rconfig interface 'wan'\roption proto 'dhcp'\roption netmask '255.255.255.0'\roption device 'br-wan'\rconfig interface 'utun'\roption proto 'none'\roption ifname 'utun'\roption device 'utun'\rconfig device\roption name 'br-lan'\roption type 'bridge'\rlist ports 'eth1'\rconfig device\roption name 'br-wan'\roption type 'bridge'\rlist ports 'eth0'\r重啟網路\n/etc/init.d/network restart\ropenwrt 設定 目前 openwrt 和路由主機處於同一個 NAT 下了，可以使用剛剛設定給 openwrt 的 IP http://10.0.2.3 進入控制面板，如果是用 virtualbox 就自行使用連接埠轉送。\n使用者：root 密碼：password 取消 lan 的 DHCP：\nNetwork -\u0026gt; Interfaces 點選 lan 項目的 Edit DHCP Server -\u0026gt; General Setup -\u0026gt; 確認勾選 Ignore interface host 設定 主機無法直接透過 ip 訪問 macvlan 底下的 openwrt，需要額外設置一個 route： 這裡使用腳本比較清楚，方便修改：route.sh\n#!/bin/bash\rdevice=\u0026quot;enp0s8\u0026quot;\rmacvlan=\u0026quot;mac30\u0026quot;\rtarget=\u0026quot;10.0.3.254\u0026quot;\rmacvlan_ip=\u0026quot;10.0.3.253\u0026quot;\rip link add link ${device} ${macvlan} type macvlan mode bridge\rip addr add ${macvlan_ip}/24 brd + dev ${macvlan}\rip link set ${macvlan} up\r# let host automatically use macvlan when communicating with target\rip route add ${target} dev ${macvlan}\r執行\nchmod a+x ./route.sh\r./route.sh\r接下來主機就能使用內網 ip ping 到 openwrt\nReference 在Docker 中运行 OpenWrt 旁路网关 DockerHub-zzsrv/openwrt Using Docker macvlan networks ","date":"January 19, 2024","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/other/openwrt-docker/","summary":"\u003cp\u003e定義一個 Network，叫做 MYNAT，關閉 DHCP。\u003c/p\u003e\n\u003cp\u003e新增一部虛擬機，定義兩張網卡：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e預設 NAT：用來模擬 ISP 裝置。(enp0s3)\u003c/li\u003e\n\u003cli\u003eMYNAT：用來建構內網。(enp0s8)\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"開啟網卡-promisc\"\u003e開啟網卡 promisc\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eip link set enp0s3 promisc on \r\nip link set enp0s8 promisc on \r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e###. 建立 docker 網路\n查詢路由所在網段、遮罩、閘道器。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eip route show dev enp0s3\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e結果：軟路由所在網段、遮罩為 \u003ccode\u003e10.0.2.0/24\u003c/code\u003e、閘道器 \u003ccode\u003e10.0.2.2\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edefault via 10.0.2.2 proto dhcp src 10.0.2.15 metric 1024\r\n10.0.2.0/24 proto kernel scope link src 10.0.2.15 metric 1024\r\n10.0.2.2 proto dhcp scope link src 10.0.2.15 metric 1024\r\n192.73.141.230 via 10.0.2.2 proto dhcp src 10.0.2.15 metric 1024\r\n192.73.144.230 via 10.0.2.2 proto dhcp src 10.0.2.15 metric 1024\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e創建 docker 網路\u003c/p\u003e","tags":null,"title":"[OpenWrt] 在 linux 中使用 Docker 跑 OpenWrt"},{"categories":null,"contents":"PdfiumViewer 是開源的 C# 控件，用於顯示和列印 PDF 文件。它基於 Chromium 瀏覽器使用的 PDF 渲染引擎 Pdfium 所開發。 而Pdfium 是 Chromium 瀏覽器使用的 PDF 渲染引擎，由 Google 和 Mozilla 共同開發。它是一個開放原始碼的函式庫，用於 PDF 文件的解碼、渲染和編輯。 PdfiumViewer 提供以下功能：\n顯示 PDF 文件的所有頁面。 支持縮放、旋轉、翻頁等操作。 支持列印 PDF 文件。 在 c# 中使用 PdfiumViewer 可以將 PDF 轉換為列印文件，送至印表機進行列印。\n安裝 Nuget 套件： PdfiumViewer PdfiumViewer.Native.x86.v8-xfa 引用\nusing PdfiumViewer;\rusing System.Drawing.Printing;\rusing System.IO;\r程式範例\n從記憶體列印： var pdfBytes = new byte[] { }; // todo: 取得 PDF by docid\rvar printerName = \u0026quot;\u0026quot;; // todo 取得印表機名稱\r// 列印\rusing (MemoryStream memoryStream = new MemoryStream(pdfBytes))\r{\rvar pageSettings = new PageSettings() { Margins = new Margins(0, 0, 0, 0) };\rvar printerSettings = new PrinterSettings();\rif (!string.IsNullOrEmpty(printerName)) printerSettings.PrinterName = printerName;\rusing (var document = PdfDocument.Load(memoryStream))\r{\rusing (PrintDocument printDocument = document.CreatePrintDocument())\r{\rprintDocument.PrinterSettings = printerSettings;\rprintDocument.DefaultPageSettings = pageSettings;\rprintDocument.PrintController = new StandardPrintController();\rprintDocument.Print();\r}\r}\r}\r從檔案列印： var file = \u0026quot;\u0026quot;; // todo 取得檔案路徑\rvar printerName = \u0026quot;\u0026quot;; // todo 取得印表機名稱\r// 列印\rvar pageSettings = new PageSettings() { Margins = new Margins(0, 0, 0, 0) };\rvar printerSettings = new PrinterSettings();\rif (!string.IsNullOrEmpty(printerName)) printerSettings.PrinterName = printerName;\rusing (var document = PdfDocument.Load(file))\r{\rusing (PrintDocument printDocument = document.CreatePrintDocument())\r{\rprintDocument.PrinterSettings = printerSettings;\rprintDocument.DefaultPageSettings = pageSettings;\rprintDocument.PrintController = new StandardPrintController();\rprintDocument.Print();\r}\r}\rReference Github-PdfiumViewer Nuget-PdfiumViewer Nuget-PdfiumViewer.Native.x86.v8-xfa ","date":"January 5, 2024","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/pdf-print/","summary":"\u003cp\u003ePdfiumViewer 是開源的 C# 控件，用於顯示和列印 PDF 文件。它基於 Chromium 瀏覽器使用的 PDF 渲染引擎 Pdfium 所開發。\n而Pdfium 是 Chromium 瀏覽器使用的 PDF 渲染引擎，由 Google 和 Mozilla 共同開發。它是一個開放原始碼的函式庫，用於 PDF 文件的解碼、渲染和編輯。\nPdfiumViewer 提供以下功能：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e顯示 PDF 文件的所有頁面。\u003c/li\u003e\n\u003cli\u003e支持縮放、旋轉、翻頁等操作。\u003c/li\u003e\n\u003cli\u003e支持列印 PDF 文件。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在 c# 中使用 PdfiumViewer 可以將 PDF 轉換為列印文件，送至印表機進行列印。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e安裝 Nuget 套件：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.nuget.org/packages/PdfiumViewer/2.13.0\" target=\"_blank\" rel=\"noopener\"\u003ePdfiumViewer\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.nuget.org/packages/PdfiumViewer.Native.x86.v8-xfa/\" target=\"_blank\" rel=\"noopener\"\u003ePdfiumViewer.Native.x86.v8-xfa\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003cp\u003e引用\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c#\"\u003eusing PdfiumViewer;\r\nusing System.Drawing.Printing;\r\nusing System.IO;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e程式範例\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e從記憶體列印：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-c#\"\u003evar pdfBytes = new byte[] { }; // todo: 取得 PDF by docid\r\nvar printerName = \u0026quot;\u0026quot;; // todo 取得印表機名稱\r\n\n// 列印\r\nusing (MemoryStream memoryStream = new MemoryStream(pdfBytes))\r\n{\r\n    var pageSettings = new PageSettings() { Margins = new Margins(0, 0, 0, 0) };\r\n    var printerSettings = new PrinterSettings();\r\n    if (!string.IsNullOrEmpty(printerName)) printerSettings.PrinterName = printerName;\r\n\n    using (var document = PdfDocument.Load(memoryStream))\r\n    {\r\n        using (PrintDocument printDocument = document.CreatePrintDocument())\r\n        {\r\n            printDocument.PrinterSettings = printerSettings;\r\n            printDocument.DefaultPageSettings = pageSettings;\r\n            printDocument.PrintController = new StandardPrintController();\r\n            printDocument.Print();\r\n        }\r\n    }\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e從檔案列印：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-c#\"\u003evar file = \u0026quot;\u0026quot;; // todo 取得檔案路徑\r\nvar printerName = \u0026quot;\u0026quot;; // todo 取得印表機名稱\r\n\n// 列印\r\nvar pageSettings = new PageSettings() { Margins = new Margins(0, 0, 0, 0) };\r\nvar printerSettings = new PrinterSettings();\r\nif (!string.IsNullOrEmpty(printerName)) printerSettings.PrinterName = printerName;\r\n\nusing (var document = PdfDocument.Load(file))\r\n{\r\n    using (PrintDocument printDocument = document.CreatePrintDocument())\r\n    {\r\n        printDocument.PrinterSettings = printerSettings;\r\n        printDocument.DefaultPageSettings = pageSettings;\r\n        printDocument.PrintController = new StandardPrintController();\r\n        printDocument.Print();\r\n    }\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"reference\"\u003eReference\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://github.com/pvginkel/PdfiumViewer\" target=\"_blank\" rel=\"noopener\"\u003eGithub-PdfiumViewer\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.nuget.org/packages/PdfiumViewer/2.13.0\" target=\"_blank\" rel=\"noopener\"\u003eNuget-PdfiumViewer\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.nuget.org/packages/PdfiumViewer.Native.x86.v8-xfa/\" target=\"_blank\" rel=\"noopener\"\u003eNuget-PdfiumViewer.Native.x86.v8-xfa\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[.NET] C# 將 PDF 轉為列印文件送出至印表機"},{"categories":null,"contents":"DeadLock Reference []https://blog.darkthread.net/blog/await-task-block-deadlock/) []https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html) []https://learn.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming) ","date":"July 28, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/csharp/async/","summary":"\u003ch1 id=\"deadlock\"\u003eDeadLock\u003c/h1\u003e\n\u003ch2 id=\"reference\"\u003eReference\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://stackoverflow.com/questions/13140523/await-vs-task-wait-deadlock\" target=\"_blank\" rel=\"noopener\"\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[]https://blog.darkthread.net/blog/await-task-block-deadlock/)\u003c/li\u003e\n\u003cli\u003e[]https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html)\u003c/li\u003e\n\u003cli\u003e[]https://learn.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming)\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[C#] 非同步"},{"categories":null,"contents":"介紹 Introduction OAuth 是一套授權框架，讓第三方應用程式(被授權方)不需取得原始帳號、密碼等敏感資訊，獲得有限的權限以存取資源，目前版本為 2.0。 運作方式為授權伺服器發放 token給第三方應用，token 上記載相關權限範圍(scope)，資源伺服器需要權限存取時第三方應用再把 token 出示給系統驗證。\n腳色(Roles) 授權伺服器 (Authorization Server)：負責管理使用者授權的伺服器。 資源伺服器 (Resource Server)：儲存資源的伺服器。 第三方應用程式 (Third-Party Application)：需要存取資源的應用程式。 使用者 (User)：授權第三方應用程式存取其資源的使用者。 RFC 規範 RFC 6749\n是 OAuth 2.0 的核心規範，描述了 OAuth 2.0 的授權框架和授權流程。 RFC 6750\nOAuth 2.0 的另一個相關規範，定義了用於訪問受保護資源的身份驗證方法，規範包括 Bearer Token 的身份驗證。 Reference RFC 6749 ","date":"July 16, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/secure/oauth2-01protocol/","summary":"\u003ch2 id=\"介紹-introduction\"\u003e介紹 Introduction\u003c/h2\u003e\n\u003cp\u003eOAuth 是一套授權框架，讓第三方應用程式(被授權方)不需取得原始帳號、密碼等敏感資訊，獲得有限的權限以存取資源，目前版本為 2.0。\n運作方式為\u003ccode\u003e授權伺服器\u003c/code\u003e發放 \u003ccode\u003etoken\u003c/code\u003e給\u003ccode\u003e第三方應用\u003c/code\u003e，token 上記載相關權限範圍(scope)，\u003ccode\u003e資源伺服器\u003c/code\u003e需要權限存取時\u003ccode\u003e第三方應用\u003c/code\u003e再把 token 出示給系統驗證。\u003c/p\u003e\n\u003ch3 id=\"腳色roles\"\u003e腳色(Roles)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e授權伺服器 (Authorization Server)\u003c/code\u003e：負責管理使用者授權的伺服器。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e資源伺服器 (Resource Server)\u003c/code\u003e：儲存資源的伺服器。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e第三方應用程式 (Third-Party Application)\u003c/code\u003e：需要存取資源的應用程式。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e使用者 (User)\u003c/code\u003e：授權第三方應用程式存取其資源的使用者。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"rfc-規範\"\u003eRFC 規範\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eRFC 6749\u003cbr\u003e\n是 OAuth 2.0 的核心規範，描述了 OAuth 2.0 的\u003ccode\u003e授權框架\u003c/code\u003e和\u003ccode\u003e授權流程\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003eRFC 6750\u003cbr\u003e\nOAuth 2.0 的另一個相關規範，定義了用於訪問受保護資源的\u003ccode\u003e身份驗證方法\u003c/code\u003e，規範包括 Bearer Token 的身份驗證。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ### 協定流程 --\u003e\r\n\u003c!-- todo: flow --\u003e\r\n\u003ch2 id=\"reference\"\u003eReference\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://www.rfcreader.com/#rfc6749\" target=\"_blank\" rel=\"noopener\"\u003eRFC 6749\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[授權] OAuth 2.0 Authorization Framework"},{"categories":null,"contents":"授權許可 (Authorization Grant) 理解授權許可前需要先瞭解解幾個名詞：\n授權碼 (Authorization Code)：由授權伺服器產生，用於授權第三方應用程式存取資源的授權憑證。 存取權杖 (Access Token)：由授權伺服器產生，用於允許第三方應用程式存取資源的授權憑證，時效通常較短。 刷新令牌 (Refresh Token)：由授權伺服器產生，用於重新產生存取權杖的授權憑證，時效通常較長。 客戶端憑證：第三方應用程式本身用於 Basic Access Authentication 的驗證資訊，具體來說是 client_id、client_secret。 OAth 2.0 根據授權許可的方式分為四種：\n授權碼許可(Authorization Code Grant) 隱含許可(Implicit Grant) 資源擁有者密碼憑證許可(Resource Owner Password Credentials Grant) 客戶端憑證許可(Client Credentials Grant) 授權碼許可(Authorization Code Grant) 第三方應用程式向授權伺服器請求授權碼，並將授權碼傳遞給資源伺服器以存取資源的授權流程，這是最常用的模式。\n網站使用者在授權伺服器的登入站點申請授權碼。 授權伺服器將授權碼告知第三方應用程式 第三方應用程式使用客戶端憑證和收到的授權碼 向 授權伺服器 發起請求獲得 token。 隱含許可(Implicit Grant) 因省略對第三方應用的授權碼直接以前端網址列取得 token ，故稱隱含式許可，但直接以前端網址參數的方式傳送 token 給網站使用者，是非常不安全的作法，一般 token 的有效期間設定為 session 期間有效 (關閉網頁即失效)。\n網站使用者從授權伺服器登入。 授權伺服器直接在網址列帶入 access_token 轉跳第三方應用程式。 資源擁有者密碼憑證許可(Resource Owner Password Credentials Grant) 讓第三方應用直接以網站使用者密碼取得 token，必須要是高度信任的第三方應用才能用此方法。\n第三方應用程式向使用者請求其帳戶密碼(使用者憑證)。 第三方應用程式以使用者帳戶密碼向授權伺服器請求 token。 客戶端憑證許可(Client Credentials Grant) 此種 token 針發放對象為第三方應用而非用戶，與用戶認証無關，由第三方應用傳送其自己的 user credentials 獲得 token。\n第三方應用程式傳送其自己的客戶端憑證獲得 token。 Reference RFC 6749 ","date":"July 16, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/secure/oauth2-02grants/","summary":"\u003ch2 id=\"授權許可-authorization-grant\"\u003e授權許可 (Authorization Grant)\u003c/h2\u003e\n\u003cp\u003e理解授權許可前需要先瞭解解幾個名詞：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e授權碼 (Authorization Code)\u003c/code\u003e：由授權伺服器產生，用於授權第三方應用程式存取資源的授權憑證。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e存取權杖 (Access Token)\u003c/code\u003e：由授權伺服器產生，用於允許第三方應用程式存取資源的授權憑證，時效通常較短。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e刷新令牌 (Refresh Token)\u003c/code\u003e：由授權伺服器產生，用於重新產生存取權杖的授權憑證，時效通常較長。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e客戶端憑證\u003c/code\u003e：第三方應用程式本身用於 Basic Access Authentication 的驗證資訊，具體來說是 client_id、client_secret。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOAth 2.0 根據授權許可的方式分為四種：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e授權碼許可(Authorization Code Grant)\u003c/li\u003e\n\u003cli\u003e隱含許可(Implicit Grant)\u003c/li\u003e\n\u003cli\u003e資源擁有者密碼憑證許可(Resource Owner Password Credentials Grant)\u003c/li\u003e\n\u003cli\u003e客戶端憑證許可(Client Credentials Grant)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"授權碼許可authorization-code-grant\"\u003e授權碼許可(Authorization Code Grant)\u003c/h3\u003e\n\u003cp\u003e第三方應用程式向授權伺服器請求授權碼，並將授權碼傳遞給資源伺服器以存取資源的授權流程，這是最常用的模式。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e網站使用者\u003c/code\u003e在\u003ccode\u003e授權伺服器\u003c/code\u003e的登入站點申請\u003ccode\u003e授權碼\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e授權伺服器\u003c/code\u003e將授權碼告知\u003ccode\u003e第三方應用程式\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e第三方應用程式\u003c/code\u003e使用\u003ccode\u003e客戶端憑證\u003c/code\u003e和收到的\u003ccode\u003e授權碼\u003c/code\u003e 向 \u003ccode\u003e授權伺服器\u003c/code\u003e 發起請求獲得 token。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"隱含許可implicit-grant\"\u003e隱含許可(Implicit Grant)\u003c/h3\u003e\n\u003cp\u003e因省略對第三方應用的授權碼直接以前端網址列取得 token ，故稱隱含式許可，但直接以前端網址參數的方式傳送 token 給網站使用者，是\u003cstrong\u003e非常不安全的作法\u003c/strong\u003e，一般 token 的有效期間設定為 session 期間有效 (關閉網頁即失效)。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e網站使用者\u003c/code\u003e從\u003ccode\u003e授權伺服器\u003c/code\u003e登入。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e授權伺服器\u003c/code\u003e直接在網址列帶入 access_token 轉跳第三方應用程式。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"資源擁有者密碼憑證許可resource-owner-password-credentials-grant\"\u003e資源擁有者密碼憑證許可(Resource Owner Password Credentials Grant)\u003c/h3\u003e\n\u003cp\u003e讓第三方應用直接以網站使用者密碼取得 token，必須要是高度信任的第三方應用才能用此方法。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e第三方應用程式\u003c/code\u003e向\u003ccode\u003e使用者\u003c/code\u003e請求其\u003ccode\u003e帳戶密碼\u003c/code\u003e(使用者憑證)。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e第三方應用程式\u003c/code\u003e以\u003ccode\u003e使用者帳戶密碼\u003c/code\u003e向\u003ccode\u003e授權伺服器\u003c/code\u003e請求 token。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"客戶端憑證許可client-credentials-grant\"\u003e客戶端憑證許可(Client Credentials Grant)\u003c/h3\u003e\n\u003cp\u003e此種 token 針發放對象為第三方應用而非用戶，與用戶認証無關，由第三方應用傳送其自己的 user credentials 獲得 token。\u003c/p\u003e","tags":null,"title":"[授權] OAuth 2.0 Authorization Framework 授權許可"},{"categories":null,"contents":"Overview SMART Health IT 最早在《新英格蘭醫學雜誌》的一篇文章中推出，提出編寫一次應用程序，然後讓它在醫療保健系統的任何地方運行，制定通用 API。 SMART 已成為 21st Century Cures Act和2020 Final Rule from the ONC認證要求項目。\nPre-erequirement 需要先熟悉 OAuth 2.0 的流程。\nDiscovery document SMART 定義了一個標準的 metadata 端點 /.well-known/smart-configuration 稱為 discovery document 用來告訴使用者仲介訊息：\nServer Capabilities (server 可以做什麼) Configuration (配置?) 認證與授權 授權(Authorization) SMART 定義兩種 Client 端 App 授權模式，差別主要在於被授權是否有使用者參與：\nAuthorization via SMART App Launch\n透過 1.EHR 或其他健康軟體的登入 session 或2.使用者手動授權，將用戶權限委託給面向使用者的 App本身連接到 FHIR Server 存取資源，被授權方獲得授權方分向的資訊稱為 lanuch context (例如用戶資訊)。 Authorization via SMART Backend Services\n授權在與用戶無關的情況下完成。 認證(Authentication) SMART 定義兩種 Client 端 App 認證模式，也就是對稱/不對稱加密，官方建議是使用不對稱加密：\nAsymmetric (“private key JWT”) authentication Symmetric (“client secret”) authentication 範圍(scopes) SMART 的scopes允許 client 程式請求委派(delegate)一組特定的訪問權限，而委派的權限所受到的限制來自兩種機制：\n底層系統政策(policy)\n假如 client 使用 SMART App Launch 向使用者請求 user/*.cruds scope，使用者授予後 client 底層系統本身權限(permission)的限制。 使用 scopes 限制被授權的 client 可存取範圍 例如：\nSMART App Launch 的程式被授權 user/Encounter.rs 可讀取、搜尋授權使用者(launch context)可存取的 Encounter 資源。 SMART Backend Services 的程式被授權 system/Encounter.rs 可讀取、搜尋該 App 全部或被設定可存取的 Encounter 資源。 例如最常見的 Scope:\nScope 權限 patient/*.rs 可以對屬於當下病患(patient)的任何資源(*)進行搜尋/讀取(rs) user/*.cruds 可以對屬於當下使用者(user)的任何資源(*)進行搜尋和CRUD(cruds) openid fhirUser 可以存取當前登入的使用者(user)資訊 launch 當 app 從 EHR 啟動，app 獲得 launch context launch/patient 當 app 不是從 EHR 啟動，app 在啟動時請求選擇患者(?) offline_access 可申請一組即使 access token 失效、使用者離線仍有效的refresh_token online_access 可申請一組需使用者在線才有效的refresh_token Token Introspection SMART 流程中，Authorization Server 需要定義一個 Token Introspection API，用來檢查 token 的 scopes、用戶、病患、等等 token 詳細訊息，透過這個模式讓 Resource Server 和 Authorization Server 解耦。\n實作可以參考 RFC7662 - OAuth 2.0 Token Introspection。\nRequest 請求範例：使用POST、需要使用者驗證。\nPOST /introspect HTTP/1.1\rHost: server.example.com\rAccept: application/json\rContent-Type: application/x-www-form-urlencoded\rAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\rtoken=mF_9.B5f-4.1JqM\u0026amp;token_type_hint=access_token\r參數說明:\n欄位 必要 說明 token 必要 token 本人 token_type_hint 選用 token 類型提示 Response 回應範例：JSON\n欄位 必要 說明 active REQUIRED token 是否可用 scope OPTIONAL 授權範圍 client_id OPTIONAL 要求授權的 client (SMART App) username OPTIONAL user ID token_type OPTIONAL token 類型(access/refresh..) exp OPTIONAL expiration time (JWT Registered Claims) iat OPTIONAL issued at (JWT Registered Claims) nbf OPTIONAL not before (JWT Registered Claims) sub OPTIONAL subject (JWT Registered Claims) aud OPTIONAL audience (JWT Registered Claims) iss OPTIONAL issuer (JWT Registered Claims) jti OPTIONAL JWT ID (JWT Registered Claims) Reference SMART SMART App Launch iThome - 簡介其他 OpenID Connect 協定的內容 RFC7662 - OAuth 2.0 Token Introspection iThome - Revocation 與 Introspection ","date":"July 10, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/fhir/fhir-smart-overview/","summary":"\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://smarthealthit.org/\" target=\"_blank\" rel=\"noopener\"\u003eSMART Health IT\u003c/a\u003e 最早在《新英格蘭醫學雜誌》的一篇文章中推出，提出\u003ccode\u003e編寫一次應用程序，然後讓它在醫療保健系統的任何地方運行\u003c/code\u003e，制定通用 API。\nSMART 已成為 \u003ccode\u003e21st Century Cures Act\u003c/code\u003e和\u003ccode\u003e2020 Final Rule from the ONC\u003c/code\u003e認證要求項目。\u003c/p\u003e\n\u003ch2 id=\"pre-erequirement\"\u003ePre-erequirement\u003c/h2\u003e\n\u003cp\u003e需要先熟悉 OAuth 2.0 的流程。\u003c/p\u003e\n\u003ch2 id=\"discovery-document\"\u003eDiscovery document\u003c/h2\u003e\n\u003cp\u003eSMART 定義了一個標準的 metadata 端點 \u003ccode\u003e/.well-known/smart-configuration\u003c/code\u003e 稱為 discovery document\n用來告訴使用者仲介訊息：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eServer Capabilities (server 可以做什麼)\u003c/li\u003e\n\u003cli\u003eConfiguration (配置?)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"認證與授權\"\u003e認證與授權\u003c/h2\u003e\n\u003ch3 id=\"授權authorization\"\u003e授權(Authorization)\u003c/h3\u003e\n\u003cp\u003eSMART 定義兩種 Client 端 App \u003ccode\u003e授權\u003c/code\u003e模式，差別主要在於被授權是否有使用者參與：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAuthorization via SMART App Launch\u003cbr\u003e\n透過 1.EHR 或其他健康軟體的登入 session 或2.使用者手動授權，將用戶權限委託給\u003ccode\u003e面向使用者的 App\u003c/code\u003e本身連接到 FHIR Server 存取資源，被授權方獲得授權方分向的資訊稱為 \u003ccode\u003elanuch context\u003c/code\u003e (例如用戶資訊)。\u003c/li\u003e\n\u003cli\u003eAuthorization via SMART Backend Services\u003cbr\u003e\n授權在與用戶無關的情況下完成。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"認證authentication\"\u003e認證(Authentication)\u003c/h3\u003e\n\u003cp\u003eSMART 定義兩種 Client 端 App \u003ccode\u003e認證\u003c/code\u003e模式，也就是對稱/不對稱加密，官方建議是使用不對稱加密：\u003c/p\u003e","tags":null,"title":"[FHIR] SMART Health IT"},{"categories":null,"contents":"Prerequest 已安裝 Debian 11，並且 ssh 可連線\ndisable swap sed -i '/\\/swap/s/^/#/' /etc/fstab\rswapoff -a\rContainer Runtime (CRI-O) Forwarding IPv4 and letting iptables\ncat \u0026lt;\u0026lt;EOF | sudo tee /etc/modules-load.d/k8s.conf\roverlay\rbr_netfilter\rEOF\rmodprobe overlay\rmodprobe br_netfilter\r# sysctl params required by setup, params persist across reboots\rcat \u0026lt;\u0026lt;EOF | sudo tee /etc/sysctl.d/k8s.conf\rnet.bridge.bridge-nf-call-iptables = 1\rnet.bridge.bridge-nf-call-ip6tables = 1\rnet.ipv4.ip_forward = 1\rEOF\r# Apply sysctl params without reboot\rsysctl --system\r#!/bin/bash\rOS=Debian_11\rVERSION=1.27\recho 'deb http://deb.debian.org/debian buster-backports main' \u0026gt; /etc/apt/sources.list.d/backports.list\rapt update\rapt install -y -t buster-backports libseccomp2 || apt update -y -t buster-backports libseccomp2\rapt install -y gnupg gnupg2 curl\recho \u0026quot;deb [signed-by=/usr/share/keyrings/libcontainers-archive-keyring.gpg] https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\u0026quot; \u0026gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list\recho \u0026quot;deb [signed-by=/usr/share/keyrings/libcontainers-crio-archive-keyring.gpg] https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /\u0026quot; \u0026gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list\rmkdir -p /usr/share/keyrings\rcurl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | gpg --dearmor -o /usr/share/keyrings/libcontainers-archive-keyring.gpg\rcurl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/Release.key | gpg --dearmor -o /usr/share/keyrings/libcontainers-crio-archive-keyring.gpg\rapt-get update\rapt-get install -y cri-o cri-o-runc\rsystemctl daemon-reload\rsystemctl enable crio\rsystemctl start crio\rInstall kubeadm apt-get update\rapt-get install -y apt-transport-https ca-certificates curl\rmkdir -p /etc/apt/keyrings\rcurl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg\recho \u0026quot;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\u0026quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list\rapt-get update\rapt-get install -y kubelet kubeadm kubectl\rapt-mark hold kubelet kubeadm kubectl\rCreating a cluster with kubeadm # 設定 k8s server上網路\rcat \u0026lt;\u0026lt;EOF | sudo tee /etc/sysctl.d/k8s.conf\rnet.bridge.bridge-nf-call-ip6tables = 1\rnet.bridge.bridge-nf-call-iptables = 1\rEOF\rsudo sysctl --system\rkubeadm init --pod-network-cidr=10.85.0.0/16 --cri-socket=unix:///var/run/crio/crio.sock\r## kubectl 設定\r### root\r```bash\rexport KUBECONFIG=/etc/kubernetes/admin.conf\rnon-root user make user sudor\napt install sudo\rusermod -aG sudo $username\rgive user kubectl config\nmkdir -p $HOME/.kube\rsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\rsudo chown $(id -u):$(id -g) $HOME/.kube/config\rInstalling a Pod network add-on curl -sL https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml | sed 's/10\\.244\\.0\\.0/10\\.85\\.0\\.0/g' \u0026gt; /tmp/flannel.yml\rkubectl apply -f /tmp/flannel.yml\r其他 讓 control plane 所在 node 可以部屬\nkubectl taint nodes --all node-role.kubernetes.io/control-plane-\rReference Installing kubeadm Container Runtimes CRI-O Installation Instructions Running CRI-O with kubeadm Network Plugins Creating a cluster with kubeadm ","date":"June 17, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/devops/k8s-debian-kubeadm/","summary":"\u003ch2 id=\"prerequest\"\u003ePrerequest\u003c/h2\u003e\n\u003cp\u003e已安裝 Debian 11，並且 ssh 可連線\u003c/p\u003e\n\u003ch3 id=\"disable-swap\"\u003edisable swap\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003esed -i '/\\/swap/s/^/#/' /etc/fstab\r\nswapoff -a\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"container-runtime-cri-o\"\u003eContainer Runtime (CRI-O)\u003c/h2\u003e\n\u003cp\u003eForwarding IPv4 and letting iptables\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ecat \u0026lt;\u0026lt;EOF | sudo tee /etc/modules-load.d/k8s.conf\r\noverlay\r\nbr_netfilter\r\nEOF\r\n\r\nmodprobe overlay\r\nmodprobe br_netfilter\r\n\r\n# sysctl params required by setup, params persist across reboots\r\ncat \u0026lt;\u0026lt;EOF | sudo tee /etc/sysctl.d/k8s.conf\r\nnet.bridge.bridge-nf-call-iptables  = 1\r\nnet.bridge.bridge-nf-call-ip6tables = 1\r\nnet.ipv4.ip_forward                 = 1\r\nEOF\r\n\r\n# Apply sysctl params without reboot\r\nsysctl --system\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\r\nOS=Debian_11\r\nVERSION=1.27\r\n\r\necho 'deb http://deb.debian.org/debian buster-backports main' \u0026gt; /etc/apt/sources.list.d/backports.list\r\napt update\r\napt install -y -t buster-backports libseccomp2 || apt update -y -t buster-backports libseccomp2\r\napt install -y gnupg gnupg2 curl\r\n\r\necho \u0026quot;deb [signed-by=/usr/share/keyrings/libcontainers-archive-keyring.gpg] https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\u0026quot; \u0026gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list\r\necho \u0026quot;deb [signed-by=/usr/share/keyrings/libcontainers-crio-archive-keyring.gpg] https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /\u0026quot; \u0026gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list\r\n\r\nmkdir -p /usr/share/keyrings\r\ncurl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | gpg --dearmor -o /usr/share/keyrings/libcontainers-archive-keyring.gpg\r\ncurl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/Release.key | gpg --dearmor -o /usr/share/keyrings/libcontainers-crio-archive-keyring.gpg\r\n\r\napt-get update\r\napt-get install -y cri-o cri-o-runc\r\n\r\nsystemctl daemon-reload\r\nsystemctl enable crio\r\nsystemctl start crio\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"install-kubeadm\"\u003eInstall kubeadm\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eapt-get update\r\napt-get install -y apt-transport-https ca-certificates curl\r\n\r\nmkdir -p /etc/apt/keyrings\r\ncurl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg\r\n\r\necho \u0026quot;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\u0026quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list\r\n\r\napt-get update\r\napt-get install -y kubelet kubeadm kubectl\r\napt-mark hold kubelet kubeadm kubectl\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"creating-a-cluster-with-kubeadm\"\u003eCreating a cluster with kubeadm\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 設定 k8s server上網路\r\ncat \u0026lt;\u0026lt;EOF | sudo tee /etc/sysctl.d/k8s.conf\r\nnet.bridge.bridge-nf-call-ip6tables = 1\r\nnet.bridge.bridge-nf-call-iptables = 1\r\nEOF\r\nsudo sysctl --system\r\n\r\nkubeadm init --pod-network-cidr=10.85.0.0/16 --cri-socket=unix:///var/run/crio/crio.sock\r\n\r\n## kubectl 設定\r\n\r\n### root\r\n\r\n```bash\r\nexport KUBECONFIG=/etc/kubernetes/admin.conf\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"non-root-user\"\u003enon-root user\u003c/h3\u003e\n\u003cp\u003emake user sudor\u003c/p\u003e","tags":null,"title":"[K8s] 安裝"},{"categories":null,"contents":"有些部屬環境要求能單一執行檔，如果要使用自己的 DLL 就會有問題，研究了內嵌 DLL 的作法應用於 WebView2 專案上。\n以 .NET Framework 4.7.2 的 WinForm 專案為例，目標環境為 windows x64。\nDependency 安裝 Nuget 上的 Microsoft.Web.WebView2。\n把這些資料夾底下的 Dll 複製到專案資料夾下，並加入版控\npackages\\Microsoft.Web.WebView2.1.0.1823.32\\runtimes packages\\Microsoft.Web.WebView2.1.0.1823.32\\lib\\net45 參考移除上述 Dll 參考(移除 Nuget 參考)，改直接參考專案資料夾下的 Dll。\n把參考的 Dll 調整為內嵌資源\nAssemblyHelper.cs public class AssemblyHelper\r{\rpublic string Name\r{\rget\r{\rreturn this.assembly.GetName().Name;\r}\r}\rpublic string AppDataPath { get; set; }\rprivate Assembly assembly;\rpublic AssemblyHelper()\r{\rassembly = Assembly.GetCallingAssembly();\rAppDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);\rAppDataPath = Path.Combine(AppDataPath, Name);\r}\r/// \u0026lt;summary\u0026gt;\r/// Extract embeded dll to target path\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;param name=\u0026quot;resourceName\u0026quot;\u0026gt;Dll embed path\u0026lt;/param\u0026gt;\r/// \u0026lt;param name=\u0026quot;targetPath\u0026quot;\u0026gt;Dll extract distination\u0026lt;/param\u0026gt;\rpublic void ExtractEmbeddedDLL(string resourceName, string targetPath)\r{\rvar targetDir = Path.GetDirectoryName(targetPath);\rif (!string.IsNullOrEmpty(targetDir) \u0026amp;\u0026amp; !Directory.Exists(targetDir)) Directory.CreateDirectory(targetDir);\rusing (Stream resourceStream = assembly.GetManifestResourceStream(resourceName))\r{\rusing (FileStream fileStream = new FileStream(targetPath, FileMode.Create))\r{\rresourceStream.CopyTo(fileStream);\r}\r}\r}\r/// \u0026lt;summary\u0026gt;\r/// 設置解析組件路徑的事件處理常式\r/// \u0026lt;/summary\u0026gt;\rpublic void EnableEmbededManifestDll() =\u0026gt; AppDomain.CurrentDomain.AssemblyResolve += OnResolveAssembly;\r/// \u0026lt;summary\u0026gt;\r/// Assembly 解析行為\r/// \u0026lt;/summary\u0026gt;\r/// \u0026lt;param name=\u0026quot;sender\u0026quot;\u0026gt;\u0026lt;/param\u0026gt;\r/// \u0026lt;param name=\u0026quot;args\u0026quot;\u0026gt;\u0026lt;/param\u0026gt;\r/// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\rpublic static Assembly OnResolveAssembly(object sender, ResolveEventArgs args)\r{\rAssembly assembly = Assembly.GetCallingAssembly();\rstring project = Assembly.GetEntryAssembly().GetName().Name;\rstring manifestItem = $\u0026quot;{project}.{new AssemblyName(args.Name).Name}.dll\u0026quot;;\rusing (Stream stream = assembly.GetManifestResourceStream(manifestItem))\r{\rif (stream == null) return null;\rbyte[] assemblyRawBytes = new byte[stream.Length];\rstream.Read(assemblyRawBytes, 0, assemblyRawBytes.Length);\rreturn Assembly.Load(assemblyRawBytes);\r}\r}\r}\rProgram.cs internal static class Program\r{\r[STAThread]\rstatic void Main()\r{\rtry\r{\rvar asm = new AssemblyHelper();\r// Load an extracted DLL dynamically\rasm.EnableEmbededManifestDll();\rvar loaderDllFolderPath = Path.Combine(asm.AppDataPath, \u0026quot;runtimes\\\\win-x64\\\\native\u0026quot;);\rvar dll = Path.Combine(loaderDllFolderPath, \u0026quot;WebView2Loader.dll\u0026quot;);\rvar loaderDllEmbedPath = $\u0026quot;{asm.Name}.runtimes.win_x64.native.WebView2Loader.dll\u0026quot;;\rasm.ExtractEmbeddedDLL(loaderDllEmbedPath, dll);\r// 將需注入 DLL 的邏輯抽離 Main 才能跑\rrun(loaderDllFolderPath);\r}\rcatch (Exception ex)\r{\rMessageBox.Show(ex.Message);\r}\r}\rprivate static void run(string loaderDllFolderPath)\r{\rCoreWebView2Environment.SetLoaderDllFolderPath(loaderDllFolderPath);\rApplication.EnableVisualStyles();\rApplication.SetCompatibleTextRenderingDefault(false);\rApplication.Run(new Form1());\r}\r}\r隱藏暫存檔 假設 webview2 元件變數是wv：\nprivate async Task showWeb(string url) {\r// 重設網頁暫存檔案位置\rvar asm = new AssemblyHelper();\rvar webView2DataPath = Path.Combine(asm.AppDataPath, $\u0026quot;webview2\u0026quot;);\rDirectory.CreateDirectory(webView2DataPath);\rvar webView2Environment = await CoreWebView2Environment.CreateAsync(null, webView2DataPath);\rawait wv.EnsureCoreWebView2Async(webView2Environment);\rwv.CoreWebView2.SetVirtualHostNameToFolderMapping(\u0026quot;appdata\u0026quot;, webView2DataPath, CoreWebView2HostResourceAccessKind.Allow);\rwv.Source = new Uri(url);\r}\r部屬 編譯之後可以直接部屬單一 exe 檔案(其他產生的 dll 檔案不用理會)，這個做法也不會在執行黨所在資料夾留下瀏覽器暫存檔。\n","date":"June 15, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/webview2-single-file/","summary":"\u003cp\u003e有些部屬環境要求能單一執行檔，如果要使用自己的 DLL 就會有問題，研究了內嵌 DLL 的作法應用於 WebView2 專案上。\u003cbr\u003e\n以 .NET Framework 4.7.2 的 WinForm 專案為例，目標環境為 windows x64。\u003c/p\u003e\n\u003ch2 id=\"dependency\"\u003eDependency\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e安裝 Nuget 上的 Microsoft.Web.WebView2。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e把這些資料夾底下的 Dll 複製到專案資料夾下，並加入版控\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epackages\\Microsoft.Web.WebView2.1.0.1823.32\\runtimes\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epackages\\Microsoft.Web.WebView2.1.0.1823.32\\lib\\net45\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e參考移除上述 Dll 參考(移除 Nuget 參考)，改直接參考專案資料夾下的 Dll。\u003cbr\u003e\n\u003cimg src=\"/posts/dotnet/webview2-single-file/reference.png\" alt=\"參考\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e把參考的 Dll 調整為內嵌資源\u003cbr\u003e\n\u003cimg src=\"/posts/dotnet/webview2-single-file/embed.png\" alt=\"參考\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"assemblyhelpercs\"\u003eAssemblyHelper.cs\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-c#\"\u003epublic class AssemblyHelper\r\n{\r\n  public string Name\r\n  {\r\n    get\r\n    {\r\n      return this.assembly.GetName().Name;\r\n    }\r\n  }\r\n  public string AppDataPath { get; set; }\r\n  private Assembly assembly;\r\n\r\n  public AssemblyHelper()\r\n  {\r\n    assembly = Assembly.GetCallingAssembly();\r\n    AppDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);\r\n    AppDataPath = Path.Combine(AppDataPath, Name);\r\n  }\r\n\r\n  /// \u0026lt;summary\u0026gt;\r\n  /// Extract embeded dll to target path\r\n  /// \u0026lt;/summary\u0026gt;\r\n  /// \u0026lt;param name=\u0026quot;resourceName\u0026quot;\u0026gt;Dll embed path\u0026lt;/param\u0026gt;\r\n  /// \u0026lt;param name=\u0026quot;targetPath\u0026quot;\u0026gt;Dll extract distination\u0026lt;/param\u0026gt;\r\n  public void ExtractEmbeddedDLL(string resourceName, string targetPath)\r\n  {\r\n    var targetDir = Path.GetDirectoryName(targetPath);\r\n    if (!string.IsNullOrEmpty(targetDir) \u0026amp;\u0026amp; !Directory.Exists(targetDir)) Directory.CreateDirectory(targetDir);\r\n\r\n    using (Stream resourceStream = assembly.GetManifestResourceStream(resourceName))\r\n    {\r\n      using (FileStream fileStream = new FileStream(targetPath, FileMode.Create))\r\n      {\r\n        resourceStream.CopyTo(fileStream);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// \u0026lt;summary\u0026gt;\r\n  /// 設置解析組件路徑的事件處理常式\r\n  /// \u0026lt;/summary\u0026gt;\r\n  public void EnableEmbededManifestDll() =\u0026gt; AppDomain.CurrentDomain.AssemblyResolve += OnResolveAssembly;\r\n  \r\n  /// \u0026lt;summary\u0026gt;\r\n  /// Assembly 解析行為\r\n  /// \u0026lt;/summary\u0026gt;\r\n  /// \u0026lt;param name=\u0026quot;sender\u0026quot;\u0026gt;\u0026lt;/param\u0026gt;\r\n  /// \u0026lt;param name=\u0026quot;args\u0026quot;\u0026gt;\u0026lt;/param\u0026gt;\r\n  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;\r\n  public static Assembly OnResolveAssembly(object sender, ResolveEventArgs args)\r\n  {\r\n    Assembly assembly = Assembly.GetCallingAssembly();\r\n\r\n    string project = Assembly.GetEntryAssembly().GetName().Name;\r\n    string manifestItem = $\u0026quot;{project}.{new AssemblyName(args.Name).Name}.dll\u0026quot;;\r\n    using (Stream stream = assembly.GetManifestResourceStream(manifestItem))\r\n    {\r\n      if (stream == null) return null;\r\n\r\n      byte[] assemblyRawBytes = new byte[stream.Length];\r\n      stream.Read(assemblyRawBytes, 0, assemblyRawBytes.Length);\r\n      return Assembly.Load(assemblyRawBytes);\r\n    }\r\n  }\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"programcs\"\u003eProgram.cs\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-C#\"\u003einternal static class Program\r\n{\r\n  [STAThread]\r\n  static void Main()\r\n  {\r\n    try\r\n    {\r\n      var asm = new AssemblyHelper();\r\n      // Load an extracted DLL dynamically\r\n      asm.EnableEmbededManifestDll();\r\n\r\n      var loaderDllFolderPath = Path.Combine(asm.AppDataPath, \u0026quot;runtimes\\\\win-x64\\\\native\u0026quot;);\r\n      var dll = Path.Combine(loaderDllFolderPath, \u0026quot;WebView2Loader.dll\u0026quot;);\r\n      var loaderDllEmbedPath = $\u0026quot;{asm.Name}.runtimes.win_x64.native.WebView2Loader.dll\u0026quot;;\r\n      asm.ExtractEmbeddedDLL(loaderDllEmbedPath, dll);\r\n\r\n      // 將需注入 DLL 的邏輯抽離 Main 才能跑\r\n      run(loaderDllFolderPath);\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n      MessageBox.Show(ex.Message);\r\n    }\r\n  }\r\n  private static void run(string loaderDllFolderPath)\r\n  {\r\n    CoreWebView2Environment.SetLoaderDllFolderPath(loaderDllFolderPath);\r\n\r\n    Application.EnableVisualStyles();\r\n    Application.SetCompatibleTextRenderingDefault(false);\r\n    Application.Run(new Form1());\r\n  }\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"隱藏暫存檔\"\u003e隱藏暫存檔\u003c/h2\u003e\n\u003cp\u003e假設 webview2 元件變數是\u003ccode\u003ewv\u003c/code\u003e：\u003c/p\u003e","tags":null,"title":"[.NET] WebView2 單一檔案部屬"},{"categories":null,"contents":"這個方法用 proxy 擴充 dayjs，讓 dayjs 支援格式化民國年。\nJS 程式碼 // dayx.js\rimport day from \u0026quot;dayjs\u0026quot;;\rconst prototype = Object.getPrototypeOf(day());\rconst yyy = (dt) =\u0026gt; (dt.getFullYear() - 1911).toString().padStart(3, \u0026quot;0\u0026quot;);\rconst handler = {\rget: function (target, prop, receiver) {\r// age, dte, tme\rif (prop === \u0026quot;age\u0026quot;) return day().diff(receiver, \u0026quot;years\u0026quot;, false);\rif (prop === \u0026quot;dte\u0026quot;) return receiver.format(\u0026quot;YYYMMDD\u0026quot;);\rif (prop === \u0026quot;tme\u0026quot;) return receiver.format(\u0026quot;HHmmss\u0026quot;);\r// format\rif (prop === \u0026quot;format\u0026quot;)\rreturn (format) =\u0026gt; {\rconst formattingTokens = /Y{4,}|Y{3}|[^Y{3}]+/g;\rconst arr = format.match(formattingTokens);\rconst format2 = arr\r.map((x) =\u0026gt; (x === \u0026quot;YYY\u0026quot; ? yyy(target.$d) : x))\r.join(\u0026quot;\u0026quot;);\rconsole.log(\u0026quot;ktformat\u0026quot;, format2);\rreturn new day(target.$d).format(format2);\r};\r// Return the original property value\rif (typeof target[prop] !== \u0026quot;function\u0026quot;) return target[prop];\r// Wrap the original function with custom behavior\rreturn function (...args) {\rconst result = target[prop].apply(target, args);\rconst isReturnDayjs = Object.getPrototypeOf(result) === prototype;\rreturn isReturnDayjs ? p(result, handler) : result;\r};\r},\rset(obj, prop, v, receiver) {\rif (prop === \u0026quot;dte\u0026quot;) {\rv = v.padStart(7, \u0026quot;0\u0026quot;);\rconst yyy = parseInt(v.substring(0, 3)) + 1911;\robj.$d.setFullYear(yyy);\robj.$d.setMonth(parseInt(v.substring(3, 5)) - 1);\robj.$d.setDate(parseInt(v.substring(5, 7)));\rreturn receiver;\r}\rif (prop === \u0026quot;tme\u0026quot;) {\rv = v.padEnd(6, \u0026quot;0\u0026quot;);\robj.$d.setHours(parseInt(v.substring(0, 2)));\robj.$d.setMinutes(parseInt(v.substring(2, 4)));\robj.$d.setSeconds(parseInt(v.substring(4, 6)));\rreturn receiver;\r}\rreturn Reflect.set(...arguments);\r},\r};\rconst p = (...args) =\u0026gt; new Proxy(day(...args), handler);\rexport default p;\r型別定義 // dayx.d.ts\rimport dayjs from \u0026quot;dayjs\u0026quot;;\rdeclare module \u0026quot;dayjs\u0026quot; {\rinterface Dayjs {\rage: number;\rdte: string;\rtme: string;\r}\r}\rexport = dayjs;\rexport as namespace dayjs;\r使用方式 可直接設定民國年，此外時間的加減乘除都可以參照 dayjs 文件\nimport dayx from \u0026quot;./dayx\u0026quot;;\r//#region 從資料庫的 dte, tme 欄位\rlet d = dayx();\rd.dte = \u0026quot;1110315\u0026quot;;\rd.tme = \u0026quot;123338\u0026quot;;\rconsole.log(d.format(\u0026quot;民國YYY年MM月DD日 HH:mm:ss\u0026quot;));\r// 民國110年03月15日 12:33:38\r//#endregion\r//#region 從原生 Date\rd = dayx(\u0026quot;2022-03-15T12:33:38\u0026quot;);\rconsole.log(d.format(\u0026quot;民國YYY年MM月DD日 HH:mm:ss\u0026quot;));\r// 民國110年03月15日 12:33:38\r//#endregion\r//#region 使用當下時間不需要任何參數\rd = dayx();\rconsole.log(d.format(\u0026quot;民國YYY年MM月DD日 HH:mm:ss\u0026quot;));\r//#endregion\rReference Dayjs ","date":"June 6, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/javascript/code-roc-format/","summary":"\u003cp\u003e這個方法用 proxy 擴充 dayjs，讓 dayjs 支援格式化民國年。\u003c/p\u003e\n\u003ch2 id=\"js-程式碼\"\u003eJS 程式碼\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// dayx.js\r\nimport day from \u0026quot;dayjs\u0026quot;;\r\nconst prototype = Object.getPrototypeOf(day());\r\nconst yyy = (dt) =\u0026gt; (dt.getFullYear() - 1911).toString().padStart(3, \u0026quot;0\u0026quot;);\r\nconst handler = {\r\n  get: function (target, prop, receiver) {\r\n    // age, dte, tme\r\n    if (prop === \u0026quot;age\u0026quot;) return day().diff(receiver, \u0026quot;years\u0026quot;, false);\r\n    if (prop === \u0026quot;dte\u0026quot;) return receiver.format(\u0026quot;YYYMMDD\u0026quot;);\r\n    if (prop === \u0026quot;tme\u0026quot;) return receiver.format(\u0026quot;HHmmss\u0026quot;);\r\n    // format\r\n    if (prop === \u0026quot;format\u0026quot;)\r\n      return (format) =\u0026gt; {\r\n        const formattingTokens = /Y{4,}|Y{3}|[^Y{3}]+/g;\r\n        const arr = format.match(formattingTokens);\r\n        const format2 = arr\r\n          .map((x) =\u0026gt; (x === \u0026quot;YYY\u0026quot; ? yyy(target.$d) : x))\r\n          .join(\u0026quot;\u0026quot;);\r\n        console.log(\u0026quot;ktformat\u0026quot;, format2);\r\n        return new day(target.$d).format(format2);\r\n      };\r\n\r\n    // Return the original property value\r\n    if (typeof target[prop] !== \u0026quot;function\u0026quot;) return target[prop];\r\n    // Wrap the original function with custom behavior\r\n    return function (...args) {\r\n      const result = target[prop].apply(target, args);\r\n      const isReturnDayjs = Object.getPrototypeOf(result) === prototype;\r\n      return isReturnDayjs ? p(result, handler) : result;\r\n    };\r\n  },\r\n  set(obj, prop, v, receiver) {\r\n    if (prop === \u0026quot;dte\u0026quot;) {\r\n      v = v.padStart(7, \u0026quot;0\u0026quot;);\r\n      const yyy = parseInt(v.substring(0, 3)) + 1911;\r\n      obj.$d.setFullYear(yyy);\r\n      obj.$d.setMonth(parseInt(v.substring(3, 5)) - 1);\r\n      obj.$d.setDate(parseInt(v.substring(5, 7)));\r\n      return receiver;\r\n    }\r\n    if (prop === \u0026quot;tme\u0026quot;) {\r\n      v = v.padEnd(6, \u0026quot;0\u0026quot;);\r\n      obj.$d.setHours(parseInt(v.substring(0, 2)));\r\n      obj.$d.setMinutes(parseInt(v.substring(2, 4)));\r\n      obj.$d.setSeconds(parseInt(v.substring(4, 6)));\r\n      return receiver;\r\n    }\r\n    return Reflect.set(...arguments);\r\n  },\r\n};\r\n\r\nconst p = (...args) =\u0026gt; new Proxy(day(...args), handler);\r\n\r\nexport default p;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"型別定義\"\u003e型別定義\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-ts\"\u003e// dayx.d.ts\r\nimport dayjs from \u0026quot;dayjs\u0026quot;;\r\n\r\ndeclare module \u0026quot;dayjs\u0026quot; {\r\n  interface Dayjs {\r\n    age: number;\r\n    dte: string;\r\n    tme: string;\r\n  }\r\n}\r\n\r\nexport = dayjs;\r\nexport as namespace dayjs;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"使用方式\"\u003e使用方式\u003c/h2\u003e\n\u003cp\u003e可直接設定民國年，此外時間的加減乘除都可以參照 \u003ca href=\"https://day.js.org/docs/en/manipulate/manipulate\" target=\"_blank\" rel=\"noopener\"\u003edayjs 文件\u003c/a\u003e\u003c/p\u003e","tags":null,"title":"[Code] 格式化民國年"},{"categories":null,"contents":"預設 CultureInfo // Program.cs\rCultureInfo.DefaultThreadCurrentCulture = new CultureInfo(\u0026quot;zh-TW\u0026quot;)\r{\rDateTimeFormat = { Calendar = new TaiwanCalendar() }\r};\r民國年轉換西元年 string dtestr1 = \u0026quot;1010229\u0026quot;;\r// ParseExact 的時候，民國年的年分要補成4碼，3碼不合法\rvar dte1 = DateTime.ParseExact(dtestr1.PadLeft(8, '0'), \u0026quot;yyMMdd\u0026quot;, CultureInfo.CurrentCulture);\rvar cedte = dte1.ToString(\u0026quot;yyyy/MM/dd\u0026quot;);\r西元年轉民國年 var dtestr2 = \u0026quot;20230508\u0026quot;;\rvar dte2 = DateTime.ParseExact(dtestr2, \u0026quot;yyyyMMdd\u0026quot;, CultureInfo.InvariantCulture);\rvar rocdte = dte2.ToString(\u0026quot;yyMMdd\u0026quot;);\r","date":"May 10, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/csharp/cultureinfo/","summary":"\u003ch2 id=\"預設-cultureinfo\"\u003e預設 CultureInfo\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-cs\"\u003e// Program.cs\r\nCultureInfo.DefaultThreadCurrentCulture = new CultureInfo(\u0026quot;zh-TW\u0026quot;)\r\n{\r\n    DateTimeFormat = { Calendar = new TaiwanCalendar() }\r\n};\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"民國年轉換西元年\"\u003e民國年轉換西元年\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-cs\"\u003estring dtestr1 = \u0026quot;1010229\u0026quot;;\r\n// ParseExact 的時候，民國年的年分要補成4碼，3碼不合法\r\nvar dte1 = DateTime.ParseExact(dtestr1.PadLeft(8, '0'), \u0026quot;yyMMdd\u0026quot;, CultureInfo.CurrentCulture);\r\nvar cedte = dte1.ToString(\u0026quot;yyyy/MM/dd\u0026quot;);\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"西元年轉民國年\"\u003e西元年轉民國年\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-cs\"\u003evar dtestr2 = \u0026quot;20230508\u0026quot;;\r\nvar dte2 = DateTime.ParseExact(dtestr2, \u0026quot;yyyyMMdd\u0026quot;, CultureInfo.InvariantCulture);\r\nvar rocdte = dte2.ToString(\u0026quot;yyMMdd\u0026quot;);\r\n\u003c/code\u003e\u003c/pre\u003e","tags":null,"title":"[Code] 處理民國年"},{"categories":null,"contents":"Method chaining、Fluent interface 和 擴充方法(Extension method) 三種雖然相似，但實則為不同的程式設計概念。\nMethod chaining Method chaining 是一種技術，允許在一行程式碼中調用對象的一系列方法。鏈中的每個方法都返回被調用的對象，從而允許在同一個對象上調用下一個方法。這種技術用於創建更可讀和簡潔的代碼。\nFluent interface Fluent interface 是一種設計模式，使用方法串鏈創建更具表現力和可讀性的API。 Fluent interface 的目標是使代碼看起來更像自然語言，使其更容易理解和使用。 在 Fluent interface 中，每個方法調用返回一個對象，允許在同一個對象上調用下一個方法。這種技術通常用於庫和框架中，以為開發人員提供更直觀和自然的API。\n擴充方法 擴充方法是一種在不修改類本身的情況下為現有類添加功能的方法。擴充方法在單獨的靜態類中定義，並像擴展類的方法一樣調用。這允許開發人員在不修改源代碼的情況下為現有類添加功能。擴充方法通常用於為現有類添加實用函數或為無法修改的類（例如第三方庫）添加功能。\nReference Fluent Interface｜一種程式碼”寫作”風格 擴充方法 (C# 程式設計手冊) wiki-Method chaining ","date":"April 22, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/software/pg-method-chaining/","summary":"\u003cp\u003eMethod chaining、Fluent interface 和 擴充方法(Extension method) 三種雖然相似，但實則為不同的程式設計概念。\u003c/p\u003e\n\u003ch2 id=\"method-chaining\"\u003eMethod chaining\u003c/h2\u003e\n\u003cp\u003eMethod chaining 是一種技術，允許在一行程式碼中調用對象的一系列方法。鏈中的每個方法都返回被調用的對象，從而允許在同一個對象上調用下一個方法。這種技術用於創建更可讀和簡潔的代碼。\u003c/p\u003e\n\u003ch2 id=\"fluent-interface\"\u003eFluent interface\u003c/h2\u003e\n\u003cp\u003eFluent interface 是一種設計模式，使用方法串鏈創建更具表現力和可讀性的API。\nFluent interface 的目標是使代碼看起來更像自然語言，使其更容易理解和使用。\n在 Fluent interface 中，每個方法調用返回一個對象，允許在同一個對象上調用下一個方法。這種技術通常用於庫和框架中，以為開發人員提供更直觀和自然的API。\u003c/p\u003e\n\u003ch2 id=\"擴充方法\"\u003e擴充方法\u003c/h2\u003e\n\u003cp\u003e擴充方法是一種在不修改類本身的情況下為現有類添加功能的方法。擴充方法在單獨的靜態類中定義，並像擴展類的方法一樣調用。這允許開發人員在不修改源代碼的情況下為現有類添加功能。擴充方法通常用於為現有類添加實用函數或為無法修改的類（例如第三方庫）添加功能。\u003c/p\u003e\n\u003ch1 id=\"reference\"\u003eReference\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.thinkinmd.com/post/2020/03/02/coding-style-of-fluent-interface/\" target=\"_blank\" rel=\"noopener\"\u003eFluent Interface｜一種程式碼”寫作”風格\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://learn.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/extension-methods\" target=\"_blank\" rel=\"noopener\"\u003e擴充方法 (C# 程式設計手冊)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Method_chaining\" target=\"_blank\" rel=\"noopener\"\u003ewiki-Method chaining\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[Program] 比較 Method chaining、fluent interface、c# 擴充方法"},{"categories":null,"contents":"手動設置 需要 java 環境、npm 安裝執行檔，可參照CLI Installation\nopenapi-generator-cli generate \\\r-i \u0026lt;spec file|url\u0026gt; -o \u0026lt;outdir\u0026gt; \\ # 設定輸入 json/xml (檔案或網址)、輸出資料夾\r-g csharp-netcore \\ # 輸出 csharp .net core 專案\r--skip-validate-spec # 不檢查規格\rDocker 更簡單，一行搞定：\ndocker run --rm \\\r-v ${PWD}:/local openapitools/openapi-generator-cli generate \\\r-i \u0026lt;spec file|url\u0026gt; -o \u0026lt;outdir\u0026gt; \\ # 設定輸入 json/xml (檔案或網址)、輸出資料夾\r-g csharp-netcore \\ # 輸出 csharp .net core 專案\r--skip-validate-spec # 不檢查規格\rReference CLI Installation Documentation for the csharp-netcore Generator ","date":"April 7, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/other/tools-openapi-generator/","summary":"\u003ch2 id=\"手動設置\"\u003e手動設置\u003c/h2\u003e\n\u003cp\u003e需要 java 環境、npm 安裝執行檔，可參照\u003ca href=\"https://openapi-generator.tech/docs/installation\" target=\"_blank\" rel=\"noopener\"\u003eCLI Installation\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eopenapi-generator-cli generate \\\r\n  -i \u0026lt;spec file|url\u0026gt; -o \u0026lt;outdir\u0026gt; \\  \t# 設定輸入 json/xml (檔案或網址)、輸出資料夾\r\n  -g csharp-netcore \\   \t\t\t\t# 輸出 csharp .net core 專案\r\n  --skip-validate-spec  \t\t\t\t# 不檢查規格\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"docker\"\u003eDocker\u003c/h2\u003e\n\u003cp\u003e更簡單，一行搞定：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003edocker run --rm \\\r\n  -v ${PWD}:/local openapitools/openapi-generator-cli generate \\\r\n  -i \u0026lt;spec file|url\u0026gt; -o \u0026lt;outdir\u0026gt; \\  \t# 設定輸入 json/xml (檔案或網址)、輸出資料夾\r\n  -g csharp-netcore \\   \t\t\t\t# 輸出 csharp .net core 專案\r\n  --skip-validate-spec  \t\t\t\t# 不檢查規格\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"reference\"\u003eReference\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://openapi-generator.tech/docs/installation\" target=\"_blank\" rel=\"noopener\"\u003eCLI Installation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://openapi-generator.tech/docs/generators/csharp-netcore/\" target=\"_blank\" rel=\"noopener\"\u003eDocumentation for the csharp-netcore Generator\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[Tools] 使用 OpenApi Generator 產生 .Net Core Client"},{"categories":null,"contents":"用來複寫給專案用的元件，用於在既有 UI framework 上打造專案元件\nVue3 Vue2.6 \u0026lt;template\u0026gt;\r\u0026lt;q-btn v-bind=\u0026quot;{ ...$attrs, ...$props }\u0026quot; v-on=\u0026quot;$listeners\u0026quot;\u0026gt;\r\u0026lt;template v-for=\u0026quot;(_, slot) of $scopedSlots\u0026quot; v-slot:[slot]=\u0026quot;scope\u0026quot;\u0026gt;\r\u0026lt;slot :name=\u0026quot;slot\u0026quot; v-bind=\u0026quot;scope\u0026quot;/\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\r\u0026lt;/q-btn\u0026gt;\r\u0026lt;/template\u0026gt;\rVue3 Vue3 裡面只要綁定 $attrs 即可，attrs, props, event 全部自動綁定進去。\n\u0026lt;template\u0026gt;\r\u0026lt;q-btn v-bind=\u0026quot;$attrs\u0026quot;\u0026gt;\r\u0026lt;template v-for=\u0026quot;(slot, index) of Object.keys($slots)\u0026quot; :key=\u0026quot;index\u0026quot; v-slot:[slot]\u0026gt;\r\u0026lt;slot :name=\u0026quot;slot\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\r\u0026lt;/q-btn\u0026gt;\r\u0026lt;/template\u0026gt;\rQuasar2-TS Quasar 裡面 Props, Slot 有獨立的 interface 定義，因此可直接拿到。\n\u0026lt;template\u0026gt;\r\u0026lt;q-btn v-bind=\u0026quot;$attrs\u0026quot;\u0026gt;\r\u0026lt;template v-for=\u0026quot;(slot, index) of Object.keys($slots)\u0026quot; :key=\u0026quot;index\u0026quot; v-slot:[slot]\u0026gt;\r\u0026lt;slot :name=\u0026quot;slot\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;/q-btn\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script setup lang=\u0026quot;ts\u0026quot;\u0026gt;\rimport type { QBtnSlots, QBtnProps } from 'quasar';\rimport { QBtn } from 'quasar';\rconst props = withDefaults(defineProps\u0026lt;QBtnProps\u0026gt;(),{\r// here comes default settings\r});\r\u0026lt;/script\u0026gt;\r\u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt;\rVuetify3 Vuetify3 裡面 Props, Slot 沒有獨立的 interface 定義，因此需額外定義。 MyBtn.vue\n\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;v-btn v-bind=\u0026quot;$attrs\u0026quot;\u0026gt;\r\u0026lt;template v-for=\u0026quot;(slot, index) of Object.keys($slots)\u0026quot; :key=\u0026quot;index\u0026quot; v-slot:[slot]\u0026gt;\r\u0026lt;slot :name=\u0026quot;slot\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;/v-btn\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script setup\u0026gt;\u0026lt;/script\u0026gt;\rMyBtn.vue.d.ts，這裡要注意\u0026quot;vuetify/components\u0026quot;而不是\u0026quot;vuetify/lib/components\u0026quot;，\nimport { VBtn } from \u0026quot;vuetify/components\u0026quot;;\rexport default VBtn\rReference Vue.js - TypeScript with Composition API ","date":"April 6, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/frontend-vue/vue-comp-wrapper/","summary":"\u003cp\u003e用來複寫給專案用的元件，用於在既有 UI framework 上打造專案元件\u003c/p\u003e\n\u003ch2 id=\"vue3\"\u003eVue3\u003c/h2\u003e\n\u003ch3 id=\"vue26\"\u003eVue2.6\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;template\u0026gt;\r\n  \u0026lt;q-btn v-bind=\u0026quot;{ ...$attrs, ...$props }\u0026quot; v-on=\u0026quot;$listeners\u0026quot;\u0026gt;\r\n    \u0026lt;template v-for=\u0026quot;(_, slot) of $scopedSlots\u0026quot; v-slot:[slot]=\u0026quot;scope\u0026quot;\u0026gt;\r\n      \u0026lt;slot :name=\u0026quot;slot\u0026quot; v-bind=\u0026quot;scope\u0026quot;/\u0026gt;\r\n    \u0026lt;/template\u0026gt;\r\n    \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\r\n  \u0026lt;/q-btn\u0026gt;\r\n\u0026lt;/template\u0026gt;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"vue3-1\"\u003eVue3\u003c/h3\u003e\n\u003cp\u003eVue3 裡面只要綁定 $attrs 即可，attrs, props, event 全部自動綁定進去。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;template\u0026gt;\r\n  \u0026lt;q-btn v-bind=\u0026quot;$attrs\u0026quot;\u0026gt;\r\n    \u0026lt;template v-for=\u0026quot;(slot, index) of Object.keys($slots)\u0026quot; :key=\u0026quot;index\u0026quot; v-slot:[slot]\u0026gt;\r\n      \u0026lt;slot :name=\u0026quot;slot\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\r\n    \u0026lt;/template\u0026gt;\r\n    \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\r\n  \u0026lt;/q-btn\u0026gt;\r\n\u0026lt;/template\u0026gt;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"quasar2-ts\"\u003eQuasar2-TS\u003c/h3\u003e\n\u003cp\u003eQuasar 裡面 Props, Slot 有獨立的 interface 定義，因此可直接拿到。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;template\u0026gt;\r\n  \u0026lt;q-btn v-bind=\u0026quot;$attrs\u0026quot;\u0026gt;\r\n    \u0026lt;template v-for=\u0026quot;(slot, index) of Object.keys($slots)\u0026quot; :key=\u0026quot;index\u0026quot; v-slot:[slot]\u0026gt;\r\n      \u0026lt;slot :name=\u0026quot;slot\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\r\n    \u0026lt;/template\u0026gt;\r\n  \u0026lt;/q-btn\u0026gt;\r\n\u0026lt;/template\u0026gt;\r\n\r\n\u0026lt;script setup lang=\u0026quot;ts\u0026quot;\u0026gt;\r\nimport type { QBtnSlots, QBtnProps } from 'quasar';\r\nimport { QBtn } from 'quasar';\r\nconst props = withDefaults(defineProps\u0026lt;QBtnProps\u0026gt;(),{\r\n  // here comes default settings\r\n});\r\n\u0026lt;/script\u0026gt;\r\n\r\n\u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"vuetify3\"\u003eVuetify3\u003c/h3\u003e\n\u003cp\u003eVuetify3 裡面 Props, Slot 沒有獨立的 interface 定義，因此需額外定義。\n\u003ccode\u003eMyBtn.vue\u003c/code\u003e\u003c/p\u003e","tags":null,"title":"[元件] 把 attr、event、slot，直接 Passthrough 給子元件，製作包裝元件"},{"categories":null,"contents":"中文多層架構的層可翻作 layer 或 tier，兩者主要的差別在於 layer 指程式邏輯在應用程式的位置；而 tier 指 layer 在系統上實際部屬執行的位址，屬於物理層級的指涉。這一篇的層說的是 layer，談如何在軟體層面利用分層 (layer) 妥善安排程式碼，以 multi-layer 撰寫程式碼能將複雜的邏輯隔離開達成關注點分離(SoC, Separation of concerns)，好處有：\n降低耦合：程式拆成各司其職的單元，降低彼此耦合，增加程式單元彈性(擴展性)、複用性。 易於維護：多層式架構中程式碼各司其職，容易定位問題發生點、而非從整個應用程式邏輯找。 敏捷開發：程式可快速回應需求修改(理由與易於維護類似，但是在開發時獲得的好處)。 平行開發：解耦的程式有助於降低協作併版衝突。 分層 三層式架構 一般來說最常用的三層式架構組成為：\n表現層 (PL; Presentation Layer)：ASP 內就是 Controller 結尾。 商業邏輯繩 (BLL; Business Logic Layer)：又稱為 Service Layer，命名習慣是 Service、Helper 結尾。 資料存取層(DAL; Data Access Layer)：命名習慣是 Repo 結尾。 另外有人將 Domain、Common 稱為一層，但這個部分其實不太像層，因為會被每一層引用，在架構上呈現比較不像層那樣扁平，裡面包含： Model、Entity、DTO(Data transfer object) 或 Value Object，這裡只有屬性沒有方法。\n四層式架構 為了降低 PL 與 BL 之間的耦合，有時會在 Business Logic Layer(BLL) 上再疊一層 Service Layer(SL)，作為 Presentation Layer 與 Business Layer 的中介層，這時 Business Logic Layer 的命名就不以 Serviece 結尾，通常較大型專案才需要如此分法。\n而 SL 和 BLL 的差別在於商業邏輯精細度，一個SL操作 (coarse-grained operation) 通常包含複數BL操作 (fine-grained operation)。\nPresentation Layer(PL) Service Layer(SL) Business Logic Layer(BLL) Data Access Layer(DAL) 整理 中文 英文 Naming Convention 3 layer 4 layer 表現層 PL, Presentation Layer Controller 1 1 服務層 BLL, Business Logic Layer Service - 2 業務層 BLL, Business Logic Layer Helper, Service 2 3 資料層 DAL, Data Access Layer Repoitory 3 4 共用(層?) Common Layer Domain, Common o o 避免過度設計 並非所有的程式都必須要分為三層，較小型、單純的專案分層會增加複雜度，可視專案複雜度分 1~3 層，分層邏輯如下：\none-layer：也就是不分層，所有邏輯全寫在一起。 two-layer：抽離 BLL，BLL負責商業邏輯與資料存取。 three-layer：從 BLL 抽離 DAL，BLL負責商業邏輯、DAL負責資料存取。 Business Logic Layer business object (BO)\nData Access Layer Repository pattern todo: define aggregate root todo: define model (或稱 entity) todo: specify IEnumerable、IQueryable 實作 Repository pattern 的原則如下：\nRepository 方法應該是回傳 IEnumerable 而非 IQueryable Repository 應該只負責基本的 CRUD 操作 Repository 的方法回傳的型別應該是 model 只為 aggregate root 實作 Repository UoF; unit of work separate/generic generic repository\nDAL 與 ORM ** 由於為每個 table 建立包含相同 CRUD 功能的 DAL 類別是重複性高的工作， 如果使用 ORM 的話可以考慮不為特定的 table 建立 DAL 類別，一律改為使用 generic DAL， 如果有需要其他衍伸的功能則實作在 Service 類別當中， 且可以相關的 Table 整併為單一個 Service\n複雜sql語法 一般來說 Repository pattern 定義 DAL 應該只能存取最基本的 CRUD， 然後佐以 unit of work pattern 進行跨資料庫操作， 但是當應用程式需要存取資料較複雜的資料庫時， 往往需要組裝較複雜的 sql ，並且在同一個交易(transation)當中實現跨資料庫查詢、計算、資料回存以確保資料一致性， 如果這時候應用程式仍死守 Repository pattern 的設計原則很容易發生過度設計(Overengineering/over-engineered)， 大幅拖慢整體效能， \u0026hellip; 這裡舉例\n交易(transaction) make the service(s) transaction aware (https://stackoverflow.com/questions/41301400/nhibernate-at-what-scope-i-should-use-transaction) 開啟交易的地方應該在 BLL\n類別歸屬 而該查詢語法的DAL歸屬類別(要寫在哪一個 Repository 的方法下)， 應該視組裝出來的 sql 最外層第一個被查詢的 table 而定。 \u0026hellip; 這裡舉例\n參數 應該提供該方法適當的參數，而難處在於決定該方法的參數要接收數個參數或是額外定義一個類別作為參數用\n群組化 可以將相關的 Table Group 起來，否則會變得很複雜而難以維護\nmemo Interface 應該定義在上層組件中，interface、entity 的依賴關係必須是終點以避免閉鎖環出現，如此一來在追蹤閉鎖環的時候可以排除只依賴於 interface, enetity 的依賴關係? DI Container 的地位是\u0026quot;組合根\u0026quot;應該是唯一和所有所有模組都有依賴關係的組件。 Dto 各層都存在，是為了隔離沒有直接依賴的層，只依賴於 interface 但卻無法迴避直接依賴 Dto? 因為方 interface 是為了抽換不同方法，而 dto 沒有方法嗎？\nReference Understanding Multilayered Architecture in .NET stackoverflow - Designing DAL and BLL - Single/Multiple Data Repository for the Related Tables stackoverflow - Should write complex query in Repository or Service layer? stackoverflow - Repository and query objects pattern. How to implement complex queries stackoverflow - NHibernate: At what scope I should use transaction? Pete\u0026rsquo;s Dev Life - Data Transfer Object使用心得及時機 SOFTWARE ENGINEERING - Business logic vs Service layer wikipedia - Multitier architecture Rockford Lhotka - Should all apps be n-tier? How to build and deploy a three-layer architecture application with C# 菜雞新訓記 (5): 使用 三層式架構 來切分服務的關注點和職責吧 ","date":"March 28, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/software/arch-multi-layer/","summary":"\u003cp\u003e中文多層架構的層可翻作 layer 或 tier，兩者主要的差別在於 layer 指程式邏輯在應用程式的位置；而 tier 指 layer 在系統上實際部屬執行的位址，屬於物理層級的指涉。這一篇的層說的是 layer，談如何在軟體層面利用分層 (layer) 妥善安排程式碼，以 multi-layer 撰寫程式碼能將複雜的邏輯隔離開達成關注點分離(SoC, Separation of concerns)，好處有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e降低耦合：程式拆成各司其職的單元，降低彼此耦合，增加程式單元彈性(擴展性)、複用性。\u003c/li\u003e\n\u003cli\u003e易於維護：多層式架構中程式碼各司其職，容易定位問題發生點、而非從整個應用程式邏輯找。\u003c/li\u003e\n\u003cli\u003e敏捷開發：程式可快速回應需求修改(理由與易於維護類似，但是在開發時獲得的好處)。\u003c/li\u003e\n\u003cli\u003e平行開發：解耦的程式有助於降低協作併版衝突。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"分層\"\u003e分層\u003c/h1\u003e\n\u003ch2 id=\"三層式架構\"\u003e三層式架構\u003c/h2\u003e\n\u003cp\u003e一般來說最常用的三層式架構組成為：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e表現層 (PL; Presentation Layer)：ASP 內就是 Controller 結尾。\u003c/li\u003e\n\u003cli\u003e商業邏輯繩 (BLL; Business Logic Layer)：又稱為 Service Layer，命名習慣是 Service、Helper 結尾。\u003c/li\u003e\n\u003cli\u003e資料存取層(DAL; Data Access Layer)：命名習慣是 Repo 結尾。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e另外有人將 Domain、Common 稱為一層，但這個部分其實不太像層，因為會被每一層引用，在架構上呈現比較不像層那樣扁平，裡面包含：\nModel、Entity、DTO(Data transfer object) 或 Value Object，這裡只有屬性沒有方法。\u003c/p\u003e\n\u003ch2 id=\"四層式架構\"\u003e四層式架構\u003c/h2\u003e\n\u003cp\u003e為了降低 PL 與 BL 之間的耦合，有時會在 Business Logic Layer(BLL) 上再疊一層 Service Layer(SL)，作為 Presentation Layer 與 Business Layer 的中介層，這時 Business Logic Layer 的命名就不以 Serviece 結尾，通常較大型專案才需要如此分法。\u003cbr\u003e\n而 SL 和 BLL 的差別在於商業邏輯精細度，一個SL操作 (coarse-grained operation) 通常包含複數BL操作 (fine-grained operation)。\u003c/p\u003e","tags":null,"title":"[架構] 多層式架構(Multi-layer Architecture)"},{"categories":null,"contents":"用這樣的寫法，會造成 IDE 異常\n:columns=\u0026quot;columns as QTableProps['columns']\u0026quot;\r","date":"March 10, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/frontend-vue/vue-ts-bug/","summary":"\u003cp\u003e用這樣的寫法，會造成 IDE 異常\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e:columns=\u0026quot;columns as QTableProps['columns']\u0026quot;\r\n\u003c/code\u003e\u003c/pre\u003e","tags":null,"title":"[But] TypeScript 注意事項"},{"categories":null,"contents":"環境需求： Hugo Version 0.109.0 (extended) or higher Go language 1.18 or higher (require for hugo modules) Node version v18.x or later and npm 8.x or later. git GitHub 設定 建立一個 repo 叫做 \u0026lt;GitAccount\u0026gt;.github.io，進入 repo 頁面 進入Repo -\u0026gt; Setting -\u0026gt; Code and automation -\u0026gt; Actions -\u0026gt; General -\u0026gt; Workflow permissions -\u0026gt; 勾選 Read and write permissions Repo 設定 抓 template\ngit clone https://github.com/hugo-toha/hugo-toha.github.io.git\rmv hugo-toha.github.io \u0026lt;GitAccount\u0026gt;.github.io\rcd \u0026lt;GitAccount\u0026gt;.github.io\rhugo mod tidy\r設置 config.yaml\nrm config.toml\rwget https://github.com/hugo-toha/hugo-toha.github.io/blob/main/config.yaml\r# 然後修改 config.yaml 裡面的 title、baseURL、gitRepo\r安裝套件\nhugo mod npm pack\rnpm install\r加入 git\ngit remote rm origin\rgit remote add origin https://github.com/\u0026lt;GitAccount\u0026gt;/\u0026lt;GitAccount\u0026gt;.github.io\r推送\ngit add .\rgit commit -m 'first commit'\rgit push -u origin main\rGitHub 設定 左側 Settings -\u0026gt; Pages -\u0026gt; 右側 Build and deployment -\u0026gt; Branch -\u0026gt; 選擇 gh-pages -\u0026gt; Save\n完成！ 之後推送到 main 的時候就會更新內容到 https://\u0026lt;GitAccount\u0026gt;.github.io\n","date":"February 15, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/other/hugo-toha-2023/","summary":"\u003ch2 id=\"環境需求\"\u003e環境需求：\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/gohugoio/hugo/releases\" target=\"_blank\" rel=\"noopener\"\u003eHugo Version 0.109.0 (extended) or higher\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/golang/go/tags\" target=\"_blank\" rel=\"noopener\"\u003eGo language 1.18 or higher (require for hugo modules)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\"\u003eNode version v18.x or later and npm 8.x or later.\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003egit\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"github-設定\"\u003eGitHub 設定\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e建立一個 repo 叫做 \u003ccode\u003e\u0026lt;GitAccount\u0026gt;.github.io\u003c/code\u003e，進入 repo 頁面\u003c/li\u003e\n\u003c/ul\u003e\n \u003c!-- - 建立一個 Branch 叫做 `gh-pages` (??) --\u003e\r\n\u003cul\u003e\n\u003cli\u003e進入Repo -\u0026gt; \u003ccode\u003eSetting\u003c/code\u003e -\u0026gt; \u003ccode\u003eCode and automation\u003c/code\u003e -\u0026gt; \u003ccode\u003eActions\u003c/code\u003e -\u0026gt; \u003ccode\u003eGeneral\u003c/code\u003e -\u0026gt; \u003ccode\u003eWorkflow permissions\u003c/code\u003e -\u0026gt; 勾選 \u003ccode\u003eRead and write permissions\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"repo-設定\"\u003eRepo 設定\u003c/h2\u003e\n\u003cp\u003e抓 template\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit clone https://github.com/hugo-toha/hugo-toha.github.io.git\r\nmv hugo-toha.github.io \u0026lt;GitAccount\u0026gt;.github.io\r\ncd \u0026lt;GitAccount\u0026gt;.github.io\r\nhugo mod tidy\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e設置 config.yaml\u003c/p\u003e","tags":null,"title":"[Hugo] Toha Theme 10分鐘快速建構"},{"categories":null,"contents":"BIOS system 分割磁碟， /dev/sda1 給 1G，其餘給 /dev/sda2 fdisk /dev/sda\rmkswap /dev/sda1\rmkfs.ext4 /dev/sda2\rmount /dev/sda2 /mnt\rswapon /dev/sda1\r安裝(arch 核心、linux 核心、韌體) pacstrap -K /mnt base linux linux-firmware 其他套件(非必要) pacstrap -K /mnt vim sudo openssh docker docker-compose bash-completion\r產生 fstab # -U Use UUIDs for source identifiers genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab\rChroot arch-chroot /mnt\rTime zone ln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime\r# generate /etc/adjtime\rhwclock --systohc\rLocalization 在/etc/locale.gen裡面把en_US.UTF-8 UTF-8、zh_TW.UTF-8 UTF-8解除註解。 locale-gen\recho \u0026quot;LANG=en_US.UTF-8\u0026quot; \u0026gt;\u0026gt; /etc/locale.conf\rBoot loader pacman -S grub\r# don’t put the disk number sda1, just the disk name sda\rgrub-install /dev/sda\rgrub-mkconfig -o /boot/grub/grub.cfg\rRoot password passwd\r重開機 exit\runmount -R /mnt\rreboot\rEFI system 首先在 virtualbox 硬體的部分將 EFI 打勾\n分割磁碟，使用 GPT table，/dev/sda1, /dev/sda2 給 1G，其餘給 /dev/sda3 fdisk /dev/sda\rmkswap /dev/sda1\rmkfs.fat -F32 /dev/sda2\rmkfs.ext4 /dev/sda3\r# 注意順序，一定要先掛載根目錄再掛載 /mnt/boot/efi\rmount /dev/sda3 /mnt\rmount /dev/sda2 /mnt/boot/efi --mkdir\rswapon /dev/sda1\r安裝(arch 核心、linux 核心、韌體) pacstrap -K /mnt base linux linux-firmware 其他套件(非必要) pacstrap -K /mnt vim sudo openssh docker docker-compose bash-completion\r產生 fstab # -U Use UUIDs for source identifiers genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab\rChroot arch-chroot /mnt\rTime zone ln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime\r# generate /etc/adjtime\rhwclock --systohc\rLocalization locale-gen\recho \u0026quot;LANG=en_US.UTF-8\u0026quot; \u0026gt;\u0026gt; /etc/locale.conf\rBoot loader pacman -S grub efibootmgr os-prober\rgrub-install --target=x86_64-efi --bootloader-id=grub --efi-directory=/boot/efi\rgrub-mkconfig -o /boot/grub/grub.cfg\rRoot password passwd\r重開機 exit\runmount -R /mnt\rreboot\rNetwork configuration touch /etc/hostname\r使用內建的 systemd-networkd，新增檔案 /etc/systemd/network/default.network\n[Match]\rName=*\r[Network]\rDHCP=yes\r# enable\rsystemctl enable systemd-networkd\rsystemctl enable systemd-resolved\r# start\rsystemctl start systemd-networkd\rsystemctl start systemd-resolved\ropenssh systemctl enable sshd\rsystemctl start sshd\rsudo user\u0026hellip; visudo，讓 %wheel 成為 sudor useradd -m naxo usermod -aG wheel naxo https://ostechnix.com/add-delete-and-grant-sudo-privileges-to-users-in-arch-linux/\n新增國網中心 mirrot /etc/pacman.d/mirrorlist\nServer = https://mirror.archlinux.tw/ArchLinux/$repo/os/$arch\rReference Arch-Installation_guide https://itsfoss.com/install-arch-linux/ ","date":"January 20, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/linux/arch-install/","summary":"\u003ch2 id=\"bios-system\"\u003eBIOS system\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e分割磁碟， /dev/sda1 給 1G，其餘給 /dev/sda2\n\u003cpre\u003e\u003ccode\u003efdisk /dev/sda\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003emkswap /dev/sda1\r\nmkfs.ext4 /dev/sda2\r\nmount /dev/sda2 /mnt\r\nswapon /dev/sda1\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e安裝(arch 核心、linux 核心、韌體)\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epacstrap -K /mnt base linux linux-firmware \r\n\u003c/code\u003e\u003c/pre\u003e\n其他套件(非必要)\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epacstrap -K /mnt vim sudo openssh docker docker-compose bash-completion\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e產生 fstab\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# -U Use UUIDs for source identifiers \r\ngenfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003eChroot\n\u003cpre\u003e\u003ccode\u003earch-chroot /mnt\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003eTime zone\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime\r\n# generate /etc/adjtime\r\nhwclock --systohc\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003eLocalization\n在\u003ccode\u003e/etc/locale.gen\u003c/code\u003e裡面把\u003ccode\u003een_US.UTF-8 UTF-8\u003c/code\u003e、\u003ccode\u003ezh_TW.UTF-8 UTF-8\u003c/code\u003e解除註解。\n\u003cpre\u003e\u003ccode\u003elocale-gen\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eecho \u0026quot;LANG=en_US.UTF-8\u0026quot; \u0026gt;\u0026gt; /etc/locale.conf\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003eBoot loader\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epacman -S grub\r\n# don’t put the disk number sda1, just the disk name sda\r\ngrub-install /dev/sda\r\ngrub-mkconfig -o /boot/grub/grub.cfg\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003eRoot password\n\u003cpre\u003e\u003ccode\u003epasswd\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e重開機\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eexit\r\nunmount -R /mnt\r\nreboot\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"efi-system\"\u003eEFI system\u003c/h2\u003e\n\u003cp\u003e首先在 virtualbox 硬體的部分將 EFI 打勾\u003c/p\u003e","tags":null,"title":"[Arch] 安裝(Virtualbox)"},{"categories":null,"contents":"效果：新增一個 v 開頭的 Tag，等 Action 結束之後該 Release 會獲得相對應的 Release 壓縮檔案。\n步驟 新增檔案.github/workflow/Release.yml\nname: Release\r# 新增 tag 的時候觸發\ron:\rpush:\rtags:\r- \u0026quot;*\u0026quot;\r# 讓 workflow 獲得上傳檔案的權限\rpermissions:\rcontents: write\rjobs:\rbuild:\rruns-on: ubuntu-latest\rstrategy:\rmatrix:\rdotnet-version: [\u0026quot;5.0.x\u0026quot;]\r# 判斷 tag 如果是 v 開頭才繼續\rif: startsWith(github.ref, 'refs/tags/v')\rsteps:\r# 取得 Git 中的原始碼\r- uses: actions/checkout@v3\r- name: Setup .NET Core SDK ${{ matrix.dotnet-version }}\ruses: actions/setup-dotnet@v3\rwith:\rdotnet-version: ${{ matrix.dotnet-version }}\r# 還原套件\r- name: Restore\rrun: dotnet restore\r# 編譯\r- name: Build\rrun: dotnet build --configuration Release --no-restore --no-restore -o api\r# 壓縮編譯檔\r- name: Compress\rrun: zip -r api.${{ github.ref_name }}.zip ./api\r# 建立 Release 、上傳檔案\r- name: Create Release and Upload Release Asset\ruses: softprops/action-gh-release@v1\rwith:\rtag_name: ${{ github.ref_name }}\rname: ${{ github.ref_name }}\rbody: ${{ github.ref_name }}\rdraft: false\rprerelease: false\rfiles: api.${{ github.ref_name }}.zip\r","date":"January 18, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/devops/git-action-release-dotnet/","summary":"\u003cp\u003e效果：新增一個 v 開頭的 Tag，等 Action 結束之後該 Release 會獲得相對應的 Release 壓縮檔案。\u003c/p\u003e\n\u003ch2 id=\"步驟\"\u003e步驟\u003c/h2\u003e\n\u003cp\u003e新增檔案\u003ccode\u003e.github/workflow/Release.yml\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003ename: Release\r\n\r\n# 新增 tag 的時候觸發\r\non:\r\n  push:\r\n    tags:\r\n      - \u0026quot;*\u0026quot;\r\n\r\n# 讓 workflow 獲得上傳檔案的權限\r\npermissions:\r\n  contents: write\r\n\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-latest\r\n    strategy:\r\n      matrix:\r\n        dotnet-version: [\u0026quot;5.0.x\u0026quot;]\r\n    # 判斷 tag 如果是 v 開頭才繼續\r\n    if: startsWith(github.ref, 'refs/tags/v')\r\n    steps:\r\n      # 取得 Git 中的原始碼\r\n      - uses: actions/checkout@v3\r\n      - name: Setup .NET Core SDK ${{ matrix.dotnet-version }}\r\n        uses: actions/setup-dotnet@v3\r\n        with:\r\n          dotnet-version: ${{ matrix.dotnet-version }}\r\n      # 還原套件\r\n      - name: Restore\r\n        run: dotnet restore\r\n      # 編譯\r\n      - name: Build\r\n        run: dotnet build --configuration Release --no-restore --no-restore -o api\r\n      # 壓縮編譯檔\r\n      - name: Compress\r\n        run: zip -r api.${{ github.ref_name }}.zip ./api\r\n      # 建立 Release 、上傳檔案\r\n      - name: Create Release and Upload Release Asset\r\n        uses: softprops/action-gh-release@v1\r\n        with:\r\n          tag_name: ${{  github.ref_name }}\r\n          name: ${{  github.ref_name }}\r\n          body: ${{ github.ref_name }}\r\n          draft: false\r\n          prerelease: false\r\n          files: api.${{ github.ref_name }}.zip\r\n\u003c/code\u003e\u003c/pre\u003e","tags":null,"title":"[DIY] Git Action 附加編譯檔案到 Release Tag (Dotnet)"},{"categories":null,"contents":"效果：新增一個 v 開頭的 Tag，等 Action 結束之後該 Release 會獲得相對應的 Release 壓縮檔案。\n步驟 新增檔案.github/workflow/Release.yml\nname: Release\r# 新增 tag 的時候觸發\ron:\rpush:\rtags:\r- \u0026quot;*\u0026quot;\r# 讓 workflow 獲得上傳檔案的權限\rpermissions:\rcontents: write\rjobs:\rbuild:\rruns-on: ubuntu-latest\r# 判斷 tag 如果是 v 開頭才繼續\rif: startsWith(github.ref, 'refs/tags/v')\rsteps:\r# 取得 Git 中的原始碼\r- uses: actions/checkout@v3\r# 編譯\r- name: Build SPA\rrun: yarn \u0026amp;\u0026amp; yarn build \u0026amp;\u0026amp; mv dist/ app/\r# 壓縮編譯檔\r- name: Compress\rrun: zip -r app.${{ github.ref_name }}.zip ./app\r# 建立 Release 、上傳檔案\r- name: Create Release and Upload Release Asset\ruses: softprops/action-gh-release@v1\rwith:\rtag_name: ${{ github.ref_name }} name: ${{ github.ref_name }}\rbody: ${{ github.ref_name }}\rdraft: false\rprerelease: false\rfiles: app.${{ github.ref_name }}.zip\r","date":"January 18, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/devops/git-action-release-vue/","summary":"\u003cp\u003e效果：新增一個 v 開頭的 Tag，等 Action 結束之後該 Release 會獲得相對應的 Release 壓縮檔案。\u003c/p\u003e\n\u003ch2 id=\"步驟\"\u003e步驟\u003c/h2\u003e\n\u003cp\u003e新增檔案\u003ccode\u003e.github/workflow/Release.yml\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003ename: Release\r\n\r\n# 新增 tag 的時候觸發\r\non:\r\n  push:\r\n    tags:\r\n      - \u0026quot;*\u0026quot;\r\n# 讓 workflow 獲得上傳檔案的權限\r\npermissions:\r\n  contents: write\r\n\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-latest\r\n    # 判斷 tag 如果是 v 開頭才繼續\r\n    if: startsWith(github.ref, 'refs/tags/v')\r\n    steps:\r\n      # 取得 Git 中的原始碼\r\n      - uses: actions/checkout@v3\r\n      # 編譯\r\n      - name: Build SPA\r\n        run: yarn \u0026amp;\u0026amp; yarn build \u0026amp;\u0026amp; mv dist/ app/\r\n      # 壓縮編譯檔\r\n      - name: Compress\r\n        run: zip -r app.${{ github.ref_name }}.zip ./app\r\n      # 建立 Release 、上傳檔案\r\n      - name: Create Release and Upload Release Asset\r\n        uses: softprops/action-gh-release@v1\r\n        with:\r\n          tag_name: ${{  github.ref_name }} \r\n          name: ${{ github.ref_name }}\r\n          body: ${{ github.ref_name }}\r\n          draft: false\r\n          prerelease: false\r\n          files: app.${{ github.ref_name }}.zip\r\n\u003c/code\u003e\u003c/pre\u003e","tags":null,"title":"[DIY] Git Action 附加編譯檔案到 Release Tag (Vue)"},{"categories":null,"contents":"採用的映象檔是 bitnami/keycloak ，因為我需要使用網址來區分服務(同一個 port 的情況下)，所以採取反向代理的方式，一方面讓之後要部屬其他應用、加上憑證、等等操作都交給 nginx 比較方便。\n建立 docker 網路 mynetwork，如果設定其他名稱，以下步驟再自行調整對應。\ndocker create network mynetwork\r建立 docker-compose 環境 keycloak/.env\nKEYCLOCK_IMAGE=bitnami/keycloak:23.0.3\rKEYCLOAK_DATABASE_VENDOR=postgresql\rKEYCLOAK_DATABASE_PORT=5432\rKEYCLOAK_DATABASE_USER=keycloak\rKEYCLOAK_DATABASE_PASSWORD=password\rKEYCLOAK_DATABASE_NAME=keycloak\rKEYCLOAK_ADMIN_USER=admin\rKEYCLOAK_ADMIN_PASSWORD=admin\rkeycloak/docker-compose.yml\nversion: '3'\rvolumes:\rpostgres_data:\rdriver: local\rservices:\rkeycloak_db:\rimage: postgres\rrestart: always\rvolumes:\r- postgres_data:/var/lib/postgresql/data\renvironment:\rPOSTGRES_DB: ${KEYCLOAK_DATABASE_NAME}\rPOSTGRES_USER: ${KEYCLOAK_DATABASE_USER}\rPOSTGRES_PASSWORD: ${KEYCLOAK_DATABASE_PASSWORD}\rnetworks:\r- mynetwork\rkeycloak:\rimage: ${KEYCLOCK_IMAGE}\renvironment:\rKEYCLOAK_DATABASE_VENDOR: ${KEYCLOAK_DATABASE_VENDOR}\rKEYCLOAK_DATABASE_HOST: keycloak_db\rKEYCLOAK_DATABASE_PORT: ${KEYCLOAK_DATABASE_PORT}\rKEYCLOAK_DATABASE_NAME: ${KEYCLOAK_DATABASE_NAME}\rKEYCLOAK_DATABASE_USER: ${KEYCLOAK_DATABASE_USER}\rKEYCLOAK_DATABASE_PASSWORD: ${KEYCLOAK_DATABASE_PASSWORD}\rKEYCLOAK_DATABASE_SCHEMA: public\rKEYCLOAK_ADMIN_USER: ${KEYCLOAK_ADMIN_USER}\rKEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD}\rKEYCLOAK_ENABLE_HEALTH_ENDPOINTS: 'true'\rKEYCLOAK_ENABLE_STATISTICS: 'true'\rKC_PROXY: edge\rKC_PROXY_ADDRESS_FORWARDING: 'true'\rKC_HTTP_ENABLED: 'true'\rrestart: unless-stopped\rnetworks:\r- mynetwork\rdepends_on:\r- keycloak_db\rnetworks:\rmynetwork:\rexternal: true\r建立 nginx/nginx.conf，這裡我把 keycloak.docker.vm 給 keycloak，裡面有一些設置 ssl 用得到的區塊放置在註解。\nevents {\r}\rhttp {\rupstream keycloak {\rserver keycloak:8080;\r}\rerror_log /etc/nginx/error_log.log warn;\rclient_max_body_size 20m;\r# proxy_cache_path /etc/nginx/cache keys_zone=one:500m max_size=1000m;\rproxy_cache off;\rserver {\rserver_name localhost;\rlocation / {\rroot /usr/share/nginx/html;\rindex index.html index.htm;\rtry_files $uri $uri/ /index.html;\r}\r}\rserver {\rlisten 80;\r# listen 443 ssl;\rserver_name keycloak.docker.vm;\r# SSL certificate and key configuration\r# ssl_certificate /secret/crt.crt;\r# ssl_certificate_key /secret/key.key;\r# Additional SSL configurations (e.g., enable secure ciphers, etc.)\r# ssl_protocols TLSv1.2 TLSv1.3;\r# for let's encrypt challenge\r#location /.well-known/acme-challenge {\r# root /usr/share/nginx/html;\r#}\rset_real_ip_from 0.0.0.0/0;\rreal_ip_header X-Real-IP;\rreal_ip_recursive on;\rlocation / {\rproxy_pass http://keycloak;\rproxy_redirect off;\rproxy_set_header Host $host;\rproxy_set_header X-Real-IP $remote_addr;\rproxy_set_header X-Forwarded-For $remote_addr;\rproxy_set_header X-Forwarded-Proto $scheme;\rproxy_set_header X-Forwarded-Port 443;\r}\r}\r}\rnginx/docker-compose.yml\nversion: '3'\rservices:\rweb:\rimage: nginx\rrestart: always\rvolumes:\r- ./nginx.conf:/etc/nginx/nginx.conf\r#- /secret:/secret # for ssl\rnetworks:\r- mynetwork\rports:\r- \u0026quot;80:80\u0026quot;\r- \u0026quot;443:443\u0026quot;\renvironment:\r- NGINX_ENVSUBST_TEMPLATE_SUFFIX=.conf\r- NGINX_PORT=80\rnetworks:\rmynetwork:\rexternal: true\r依序啟動：\n# 啟動 keycloak\rdocker-compose up -f keycloak/docker-compose.yml -d\r# 啟動 nginx\rdocker-compose up -f nginx/docker-compose.yml -d\r設置 hostname\nwindows 加入 C:\\Windows\\System32\\drivers\\etc\\host linux 加入 /etc/hosts 192.168.68.158 keycloak.docker.vm\r至此已設置完成可以嘗試登入 http://keycloak.docker.vm/ 了，如果要銜接 https 的前端應用程式，則 keycloak 必須要設置憑證使用 https 才行。\nReference Bitnami package for Keycloak ","date":"January 1, 2023","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/web/keycloak-docker-compose/","summary":"\u003cp\u003e採用的映象檔是 \u003ccode\u003ebitnami/keycloak\u003c/code\u003e ，因為我需要使用網址來區分服務(同一個 port 的情況下)，所以採取反向代理的方式，一方面讓之後要部屬其他應用、加上憑證、等等操作都交給 nginx 比較方便。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e建立 docker 網路 \u003ccode\u003emynetwork\u003c/code\u003e，如果設定其他名稱，以下步驟再自行調整對應。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003edocker create network mynetwork\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e建立 docker-compose 環境 \u003ccode\u003ekeycloak/.env\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eKEYCLOCK_IMAGE=bitnami/keycloak:23.0.3\r\nKEYCLOAK_DATABASE_VENDOR=postgresql\r\nKEYCLOAK_DATABASE_PORT=5432\r\nKEYCLOAK_DATABASE_USER=keycloak\r\nKEYCLOAK_DATABASE_PASSWORD=password\r\nKEYCLOAK_DATABASE_NAME=keycloak\r\n\nKEYCLOAK_ADMIN_USER=admin\r\nKEYCLOAK_ADMIN_PASSWORD=admin\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ekeycloak/docker-compose.yml\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003eversion: '3'\r\n\nvolumes:\r\n  postgres_data:\r\n      driver: local\r\n\nservices:\r\n  keycloak_db:\r\n    image: postgres\r\n    restart: always\r\n    volumes:\r\n      - postgres_data:/var/lib/postgresql/data\r\n    environment:\r\n      POSTGRES_DB: ${KEYCLOAK_DATABASE_NAME}\r\n      POSTGRES_USER: ${KEYCLOAK_DATABASE_USER}\r\n      POSTGRES_PASSWORD: ${KEYCLOAK_DATABASE_PASSWORD}\r\n    networks:\r\n      - mynetwork\r\n  keycloak:\r\n    image: ${KEYCLOCK_IMAGE}\r\n    environment:\r\n      KEYCLOAK_DATABASE_VENDOR: ${KEYCLOAK_DATABASE_VENDOR}\r\n      KEYCLOAK_DATABASE_HOST: keycloak_db\r\n      KEYCLOAK_DATABASE_PORT: ${KEYCLOAK_DATABASE_PORT}\r\n      KEYCLOAK_DATABASE_NAME: ${KEYCLOAK_DATABASE_NAME}\r\n      KEYCLOAK_DATABASE_USER: ${KEYCLOAK_DATABASE_USER}\r\n      KEYCLOAK_DATABASE_PASSWORD: ${KEYCLOAK_DATABASE_PASSWORD}\r\n      KEYCLOAK_DATABASE_SCHEMA: public\r\n      KEYCLOAK_ADMIN_USER: ${KEYCLOAK_ADMIN_USER}\r\n      KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD}\r\n      KEYCLOAK_ENABLE_HEALTH_ENDPOINTS: 'true'\r\n      KEYCLOAK_ENABLE_STATISTICS: 'true'\r\n      KC_PROXY: edge\r\n      KC_PROXY_ADDRESS_FORWARDING: 'true'\r\n      KC_HTTP_ENABLED: 'true'\r\n    restart: unless-stopped\r\n    networks:\r\n      - mynetwork\r\n    depends_on:\r\n      - keycloak_db\r\n\nnetworks:\r\n  mynetwork:\r\n    external: true\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e建立 \u003ccode\u003enginx/nginx.conf\u003c/code\u003e，這裡我把 \u003ccode\u003ekeycloak.docker.vm\u003c/code\u003e 給 keycloak，裡面有一些設置 ssl 用得到的區塊放置在註解。\u003c/p\u003e","tags":null,"title":"[Keycloak] docker 安裝"},{"categories":null,"contents":"Vue 的作法 app.component('component-name', component)\rQuasar2 的做法 Vite/Typescript\n建立 src/boot/register-my-component.ts\nimport { boot } from 'quasar/wrappers';\rimport BasicBtnVue from 'src/components/BasicBtn.vue';\r// \u0026quot;async\u0026quot; is optional;\r// more info on params: https://v2.quasar.dev/quasar-cli/boot-files\rexport default boot(async ({ app }) =\u0026gt; {\rapp.component('x-btn', BasicBtnVue);\r});\r在 quasar.conf.js 內新增設定\nmodule.exports = configure(function (/* ctx */) {\rreturn {\r// ...上略\r// https://v2.quasar.dev/quasar-cli-vite/boot-files\rboot: ['i18n', 'register-my-component'],\r// ... 下略\r};\r});\r建立型別定義檔，我放在 src/components 下 components.d.ts\nimport BasicBtn from './BasicBtn.vue';\rdeclare module '@vue/runtime-core' {\rexport interface GlobalComponents {\rXBtn: typeof BasicBtn;\r}\r}\r","date":"December 13, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/frontend-vue/vue-comp-global/","summary":"\u003ch2 id=\"vue-的作法\"\u003eVue 的作法\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eapp.component('component-name', component)\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"quasar2-的做法\"\u003eQuasar2 的做法\u003c/h2\u003e\n\u003cp\u003eVite/Typescript\u003c/p\u003e\n\u003cp\u003e建立 src/boot/register-my-component.ts\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eimport { boot } from 'quasar/wrappers';\r\nimport BasicBtnVue from 'src/components/BasicBtn.vue';\r\n\r\n// \u0026quot;async\u0026quot; is optional;\r\n// more info on params: https://v2.quasar.dev/quasar-cli/boot-files\r\nexport default boot(async ({ app }) =\u0026gt; {\r\n  app.component('x-btn', BasicBtnVue);\r\n});\r\n\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 quasar.conf.js 內新增設定\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003emodule.exports = configure(function (/* ctx */) {\r\n  return {\r\n    // ...上略\r\n    // https://v2.quasar.dev/quasar-cli-vite/boot-files\r\n    boot: ['i18n', 'register-my-component'],\r\n    // ... 下略\r\n  };\r\n});\r\n\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e建立型別定義檔，我放在 src/components 下\ncomponents.d.ts\u003c/p\u003e","tags":null,"title":"[元件] 全域元件"},{"categories":null,"contents":"軟體系統價值 行為價值、架構價值\n行為價值 工程師的首要責任 需求實現、可用性保障(功能性 Bug、性能、穩定性) 業務明確、穩定的前提下，可忽略架構價值\n架構價值 更容易適應:需求變更。 變更實作難度和變更的範圍成正比、跟變更的具體形狀無關。 ?? 業務需求通常不明確、時常變動，因此架構非常重要。 不關注架構價值會隨著版本迭代、變更每一行程式成本升高，因此投入的人力成本增加。\n知乎-架构整洁之道, 看这一篇就够了！ 架构整洁之道超詳細關係圖 ","date":"December 12, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/software/arch-clean-arch-review/","summary":"\u003ch2 id=\"軟體系統價值\"\u003e軟體系統價值\u003c/h2\u003e\n\u003cp\u003e行為價值、架構價值\u003c/p\u003e\n\u003ch3 id=\"行為價值\"\u003e行為價值\u003c/h3\u003e\n\u003cp\u003e工程師的首要責任\n需求實現、可用性保障(功能性 Bug、性能、穩定性)\n業務明確、穩定的前提下，可忽略架構價值\u003c/p\u003e\n\u003ch3 id=\"架構價值\"\u003e架構價值\u003c/h3\u003e\n\u003cp\u003e更容易適應:需求變更。\n變更實作難度和變更的範圍成正比、跟變更的具體形狀無關。 ??\n業務需求通常不明確、時常變動，因此架構非常重要。\n不關注架構價值會隨著版本迭代、變更每一行程式成本升高，因此投入的人力成本增加。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/65658089\" target=\"_blank\" rel=\"noopener\"\u003e知乎-架构整洁之道, 看这一篇就够了！\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://alitech-public.oss-cn-beijing.aliyuncs.com/1557040476898/jiagouzhengjie-siweidaotu.png\" target=\"_blank\" rel=\"noopener\"\u003e架构整洁之道超詳細關係圖\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[架構] 無暇的程式碼-讀書心得"},{"categories":null,"contents":"巢狀程式結構會使程式可讀性差、且難以維護，可讀性高的程式碼深度最多不超過三層，嚴格管控程式碼深度的程式設計師又稱為 Never Nester。\n消除巢狀程式手法： Extraction Inversion 依據契約式程式設計，移除不必要判斷 Extraction 從複查的結構抽出程式碼\nInversion 把跳出函式的判斷移動到最上面\n依據契約式程式設計，移除不必要判斷 依據契約式程式設計，以程式碼使用者會傳入的參數合法性為前提，移除不必要判斷\n","date":"December 11, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/software/quality-nest/","summary":"\u003cp\u003e巢狀程式結構會使程式可讀性差、且難以維護，可讀性高的程式碼深度最多不超過三層，嚴格管控程式碼深度的程式設計師又稱為 Never Nester。\u003c/p\u003e\n\u003ch2 id=\"消除巢狀程式手法\"\u003e消除巢狀程式手法：\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eExtraction\u003c/li\u003e\n\u003cli\u003eInversion\u003c/li\u003e\n\u003cli\u003e依據契約式程式設計，移除不必要判斷\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"extraction\"\u003eExtraction\u003c/h3\u003e\n\u003cp\u003e從複查的結構抽出程式碼\u003c/p\u003e\n\u003ch3 id=\"inversion\"\u003eInversion\u003c/h3\u003e\n\u003cp\u003e把跳出函式的判斷移動到最上面\u003c/p\u003e\n\u003ch3 id=\"依據契約式程式設計移除不必要判斷\"\u003e依據契約式程式設計，移除不必要判斷\u003c/h3\u003e\n\u003cp\u003e依據契約式程式設計，以程式碼使用者會傳入的參數合法性為前提，移除不必要判斷\u003c/p\u003e","tags":null,"title":"[Program] 巢狀結構"},{"categories":null,"contents":"OAuth 是一個開發標準(Open Standard)，用來處理有關「授權」（Authorization）相關的問題 允許授權當下的APP取得使用者在平台的相關資訊 OAuth2 有很多變化\n腳色：\nResource Owner，也就是使用者。 Client，要向使用者取得權限的應用程式，有自己的 Client ID、 Client Secret。 Authorization Server，負責驗證使用者身分、發 Access Token 給應用程式 Resource Server，存放資源的伺服器，認 Token 給使用者存取資源 用詞\nAuthorization Grant 同意應用程式取得資源 Redirect URI 驗證伺服器驗證、授權完畢後，返回應用程式的路徑 Scope 授權範圍 OAuth2.0 四種授權類型流程(Grant Types)： Authorization Code 最常見，步驟：\n應用程式(Client) 將使用者導向 Authorization Server，提供 Redirect URL, scope, 應用程式的 client id\u0026hellip; Authorization Server 驗證使用者身分，通過之後發給 Authorization Grant，將網址列帶上 Authorization Grant 後將使用者導回 Redirect URI 回到應用程式(Client)。 應用程式(Client)拿 Authorization Grant 和 Authorization Server 換取 Access Token，Authorization Server 會透過應用程式(Client)專屬的 Client ID、 Client Secret 驗證應用程式身分。 應用程式(Client)帶著 Access Token 向 Resource Server 存取資源 Implicit 適合在 Client-side 運行的應用程式適合使用，例如 SPA(Single Page Application) 跳過交換 Access Token 的過程，由 Authorization Server 直接給予 Access Token 比較不安全\nResource Owner Password Credentials 使用者透過應用程式(Client)，提供帳號密碼給 Authorization Server拿到 Access Token\nClient Credentials M2M (machine-to-machine) 通常是應用程式向 Authorization Server 請求取得獲取自己相關資源的 Access Token，而不是為了獲取使用者的資源。 不需要驗證使用者身分，單純應用程式向 Authorization Server 驗證自己的資訊。\nReference [筆記] 認識 OAuth 2.0：一次了解各角色、各類型流程的差異 ","date":"December 2, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/other/auth-oauth2/","summary":"\u003cp\u003eOAuth 是一個開發標準(Open Standard)，用來處理有關「授權」（Authorization）相關的問題\n允許授權當下的APP取得使用者在平台的相關資訊\nOAuth2 有很多變化\u003c/p\u003e\n\u003cp\u003e腳色：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eResource Owner，也就是使用者。\u003c/li\u003e\n\u003cli\u003eClient，要向使用者取得權限的應用程式，有自己的 Client ID、 Client Secret。\u003c/li\u003e\n\u003cli\u003eAuthorization Server，負責驗證使用者身分、發 Access Token 給應用程式\u003c/li\u003e\n\u003cli\u003eResource Server，存放資源的伺服器，認 Token 給使用者存取資源\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e用詞\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAuthorization Grant 同意應用程式取得資源\u003c/li\u003e\n\u003cli\u003eRedirect URI 驗證伺服器驗證、授權完畢後，返回應用程式的路徑\u003c/li\u003e\n\u003cli\u003eScope 授權範圍\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"oauth20-四種授權類型流程grant-types\"\u003eOAuth2.0 四種授權類型流程(Grant Types)：\u003c/h2\u003e\n\u003ch3 id=\"authorization-code\"\u003eAuthorization Code\u003c/h3\u003e\n\u003cp\u003e最常見，步驟：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e應用程式(Client) 將使用者導向 Authorization Server，提供 Redirect URL, scope, 應用程式的 client id\u0026hellip;\u003c/li\u003e\n\u003cli\u003eAuthorization Server 驗證使用者身分，通過之後發給 Authorization Grant，將網址列帶上 Authorization Grant 後將使用者導回 Redirect URI 回到應用程式(Client)。\u003c/li\u003e\n\u003cli\u003e應用程式(Client)拿 Authorization Grant 和 Authorization Server 換取 Access Token，Authorization Server 會透過應用程式(Client)專屬的 Client ID、 Client Secret 驗證應用程式身分。\u003c/li\u003e\n\u003cli\u003e應用程式(Client)帶著 Access Token 向 Resource Server 存取資源\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"implicit\"\u003eImplicit\u003c/h3\u003e\n\u003cp\u003e適合在 Client-side 運行的應用程式適合使用，例如 SPA(Single Page Application)\n跳過交換 Access Token 的過程，由 Authorization Server 直接給予 Access Token\n比較不安全\u003c/p\u003e","tags":null,"title":"[授權] OAuth2.0"},{"categories":null,"contents":"這裡是假設手邊已經有一台安裝 docker、docker-compose 的 Linux 系統。 採用的映象檔是 ghcr.io/home-assistant/home-assistant:stable ，因為我需要使用網址來區分服務(同一個 443 port 的情況下)，所以採取反向代理的方式，一方面讓之後要部屬其他應用、加上憑證、等等操作都交給 nginx 比較方便，因此不會將 8123 port 直接對外。\n建立 mynetwork docker create network mynetwork\r建立 ha ha/docker-compose.yml version: '3'\rservices:\rha:\rcontainer_name: homeassistant\r#image: \u0026quot;homeassistant/home-assistant:stable\u0026quot;\rimage: ${HA_IMAGE}\rvolumes:\r- ./volume/ha/config:/config\r- /etc/localtime:/etc/localtime:ro\r- /run/dbus:/run/dbus:ro\rrestart: unless-stopped\rprivileged: true\rnetworks:\r- mynetwork\rnetworks:\rmynetwork:\rexternal: true\rha/.env HA_IMAGE=\u0026quot;homeassistant/home-assistant:stable\u0026quot;\rha/.gitignore volume/\r建立 nginx nginx/docker-compose.yml version: '3'\rservices:\rweb:\rimage: nginx\rvolumes:\r# - ./templates:/etc/nginx/templates\r- /usr/share/nginx/html:/usr/share/nginx/html\r- ./nginx.conf:/etc/nginx/nginx.conf\r- /etc/letsencrypt:/etc/letsencrypt\rnetworks:\r- mynetwork\rports:\r- \u0026quot;80:80\u0026quot;\r- \u0026quot;443:443\u0026quot;\renvironment:\r- NGINX_ENVSUBST_TEMPLATE_SUFFIX=.conf\r- NGINX_PORT=80\rnetworks:\rmynetwork:\rexternal: true\rnginx/nginx.conf events {\r}\rhttp {\rupstream ha {\rserver ha:8123;\r}\rerror_log /etc/nginx/error_log.log warn;\rclient_max_body_size 20m;\r# proxy_cache_path /etc/nginx/cache keys_zone=one:500m max_size=1000m;\rproxy_cache off;\rserver {\rserver_name localhost;\rlocation / {\rroot /usr/share/nginx/html;\rindex index.html index.htm;\rtry_files $uri $uri/ /index.html;\r}\r}\rserver {\rlisten 80;\r#listen 443 ssl;\r#server_name home.example.com;\r# SSL certificate and key configuration\r#ssl_certificate /etc/letsencrypt/live/home.example.com/fullchain.pem;\r#ssl_certificate_key /etc/letsencrypt/live/home.example.com/privkey.pem;\r# Additional SSL configurations (e.g., enable secure ciphers, etc.)\r#ssl_protocols TLSv1.2 TLSv1.3;\r#ssl_ciphers 'TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384';\rlocation /.well-known/acme-challenge {\rroot /usr/share/nginx/html;\r}\rlocation / {\rproxy_pass http://ha;\rproxy_set_header Host $host;\rproxy_http_version 1.1;\rproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\rproxy_set_header X-Forwarded-Proto $scheme;\rproxy_set_header Upgrade $http_upgrade;\rproxy_set_header Connection \u0026quot;Upgrade\u0026quot;;\r}\r}\r}\r啟動服務 docker-compose -f ha/docker-compose.yml up -d\rdocker-compose -f nginx/docker-compose.yml up -d\r創建帳號 例如我的 IP 是 192.168.56.100 現在可以進入 http://192.168.56.100/ 開始創建帳號。\nReference home-assistant.io - installation configuring-the-mosquitto-mqtt-docker-container-for-use-with-home-assistant home-assistant-docker-zigbee2mqtt Zigbee2MQTT - Configuration ","date":"November 22, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/other/homeassistant/ha-install/","summary":"\u003cp\u003e這裡是假設手邊已經有一台安裝 docker、docker-compose 的 Linux 系統。\n採用的映象檔是 \u003ccode\u003eghcr.io/home-assistant/home-assistant:stable\u003c/code\u003e ，因為我需要使用網址來區分服務(同一個 443 port 的情況下)，所以採取反向代理的方式，一方面讓之後要部屬其他應用、加上憑證、等等操作都交給 nginx 比較方便，因此不會將 8123 port 直接對外。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e建立 \u003ccode\u003emynetwork\u003c/code\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003edocker create network mynetwork\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e建立 \u003ccode\u003eha\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eha/docker-compose.yml\u003c/code\u003e\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003eversion: '3'\r\nservices:\r\n  ha:\r\n    container_name: homeassistant\r\n    #image: \u0026quot;homeassistant/home-assistant:stable\u0026quot;\r\n    image: ${HA_IMAGE}\r\n    volumes:\r\n      - ./volume/ha/config:/config\r\n      - /etc/localtime:/etc/localtime:ro\r\n      - /run/dbus:/run/dbus:ro\r\n    restart: unless-stopped\r\n    privileged: true\r\n    networks:\r\n      - mynetwork\r\nnetworks:\r\n  mynetwork:\r\n    external: true\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eha/.env\u003c/code\u003e\n\u003cpre\u003e\u003ccode\u003eHA_IMAGE=\u0026quot;homeassistant/home-assistant:stable\u0026quot;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eha/.gitignore\u003c/code\u003e\n\u003cpre\u003e\u003ccode\u003evolume/\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e建立 \u003ccode\u003enginx\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enginx/docker-compose.yml\u003c/code\u003e\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003eversion: '3'\r\nservices:\r\n  web:\r\n    image: nginx\r\n    volumes:\r\n      # - ./templates:/etc/nginx/templates\r\n      - /usr/share/nginx/html:/usr/share/nginx/html\r\n      - ./nginx.conf:/etc/nginx/nginx.conf\r\n      - /etc/letsencrypt:/etc/letsencrypt\r\n    networks:\r\n      - mynetwork\r\n    ports:\r\n    - \u0026quot;80:80\u0026quot;\r\n    - \u0026quot;443:443\u0026quot;\r\n    environment:\r\n    - NGINX_ENVSUBST_TEMPLATE_SUFFIX=.conf\r\n    - NGINX_PORT=80\r\n\nnetworks:\r\n  mynetwork:\r\n    external: true\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enginx/nginx.conf\u003c/code\u003e\n\u003cpre\u003e\u003ccode\u003eevents {\r\n}\r\n\nhttp {\r\n  upstream ha {\r\n      server ha:8123;\r\n  }\r\n  error_log /etc/nginx/error_log.log warn;\r\n  client_max_body_size 20m;\r\n\n  # proxy_cache_path /etc/nginx/cache keys_zone=one:500m max_size=1000m;\r\n  proxy_cache off;\r\n  server {\r\n    server_name localhost;\r\n    location / {\r\n      root   /usr/share/nginx/html;\r\n      index  index.html index.htm;\r\n      try_files $uri $uri/ /index.html;\r\n    }\r\n  }\r\n  server {\r\n    listen 80;\r\n    #listen 443 ssl;\r\n    #server_name home.example.com;\r\n\n    # SSL certificate and key configuration\r\n    #ssl_certificate /etc/letsencrypt/live/home.example.com/fullchain.pem;\r\n    #ssl_certificate_key /etc/letsencrypt/live/home.example.com/privkey.pem;\r\n\n    # Additional SSL configurations (e.g., enable secure ciphers, etc.)\r\n    #ssl_protocols TLSv1.2 TLSv1.3;\r\n    #ssl_ciphers 'TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384';\r\n\n    location /.well-known/acme-challenge {\r\n      root   /usr/share/nginx/html;\r\n    }\r\n    location / {\r\n        proxy_pass http://ha;\r\n        proxy_set_header Host $host;\r\n        proxy_http_version 1.1;\r\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n        proxy_set_header X-Forwarded-Proto $scheme;\r\n        proxy_set_header Upgrade $http_upgrade;\r\n        proxy_set_header Connection \u0026quot;Upgrade\u0026quot;;\r\n    }\r\n  }\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e啟動服務\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003edocker-compose -f ha/docker-compose.yml up -d\r\ndocker-compose -f nginx/docker-compose.yml up -d\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"創建帳號\"\u003e創建帳號\u003c/h2\u003e\n\u003cp\u003e例如我的 IP 是 192.168.56.100\n現在可以進入 \u003ccode\u003ehttp://192.168.56.100/\u003c/code\u003e 開始創建帳號。\u003c/p\u003e","tags":null,"title":"[HA] 使用 Docker Compose 安裝 Home Assistant"},{"categories":null,"contents":"Working with Reactivity 上游元件\n\u0026lt;script lang=\u0026quot;ts\u0026quot;\u0026gt;\rimport { InjectionKey, provide, Ref, reactive } from 'vue';\r// State\rexport interface IState {\rdrawer: boolean;\r}\rexport const stateKey: InjectionKey\u0026lt;Ref\u0026lt;IState\u0026gt;\u0026gt; = Symbol();\rconst state = reactive\u0026lt;IState\u0026gt;({\rdrawer: false,\r});\rprovide\u0026lt;IState\u0026gt;(stateKey, computed(()=\u0026gt;state));\r\u0026lt;/script\u0026gt;\r下游元件\n\u0026lt;script setup lang=\u0026quot;ts\u0026quot;\u0026gt;\rimport { inject, ref } from 'vue';\rimport { stateKey } from './Parent.vue';\rconst state = inject(stateKey, ref({ drawer: false }));\r\u0026lt;/script\u0026gt;\rReference Vue.js/guild - Provide / Inject Vue.js/api - Composition API: Dependency Injection ","date":"November 17, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/frontend-vue/vue-ts-provide/","summary":"\u003cp\u003eWorking with Reactivity\n上游元件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;script lang=\u0026quot;ts\u0026quot;\u0026gt;\r\nimport { InjectionKey, provide, Ref, reactive } from 'vue';\r\n// State\r\nexport interface IState {\r\n  drawer: boolean;\r\n}\r\nexport const stateKey: InjectionKey\u0026lt;Ref\u0026lt;IState\u0026gt;\u0026gt; = Symbol();\r\nconst state = reactive\u0026lt;IState\u0026gt;({\r\n  drawer: false,\r\n});\r\nprovide\u0026lt;IState\u0026gt;(stateKey, computed(()=\u0026gt;state));\r\n\u0026lt;/script\u0026gt;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e下游元件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;script setup lang=\u0026quot;ts\u0026quot;\u0026gt;\r\nimport { inject, ref } from 'vue';\r\nimport { stateKey } from './Parent.vue';\r\n\r\nconst state = inject(stateKey, ref({ drawer: false }));\r\n\u0026lt;/script\u0026gt;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"reference\"\u003eReference\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://vuejs.org/guide/components/provide-inject.html\" target=\"_blank\" rel=\"noopener\"\u003eVue.js/guild - Provide / Inject\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://vuejs.org/api/composition-api-dependency-injection.html\" target=\"_blank\" rel=\"noopener\"\u003eVue.js/api - Composition API: Dependency Injection\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[Typescript] Typescript 用 InjectionKey 達成強型別 provide"},{"categories":null,"contents":"更改 port 可以直接修改/etc/ssh/sshd_config裡面的 Port 設定(解開註解修改)，或直接新增一個檔案：\nsudo echo \u0026quot;Port 22\u0026quot; \u0026gt;\u0026gt; /etc/ssh/sshd_config.d/port.conf\rsudo ufw status verbose\rsudo ufw allow 22\r重啟 sshd\nservice sshd restart\rhttps://www.hostinger.com/tutorials/how-to-change-ssh-port-vps\n","date":"November 15, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/linux/ubuntu22-ssh/","summary":"\u003ch2 id=\"更改-port\"\u003e更改 port\u003c/h2\u003e\n\u003cp\u003e可以直接修改\u003ccode\u003e/etc/ssh/sshd_config\u003c/code\u003e裡面的 Port 設定(解開註解修改)，或直接新增一個檔案：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003esudo echo \u0026quot;Port 22\u0026quot; \u0026gt;\u0026gt; /etc/ssh/sshd_config.d/port.conf\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003esudo ufw status verbose\r\nsudo ufw allow 22\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e重啟 sshd\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eservice sshd restart\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca href=\"https://www.hostinger.com/tutorials/how-to-change-ssh-port-vps\" target=\"_blank\" rel=\"noopener\"\u003ehttps://www.hostinger.com/tutorials/how-to-change-ssh-port-vps\u003c/a\u003e\u003c/p\u003e","tags":null,"title":"[Linux] Ubuntu SSH 連線"},{"categories":null,"contents":"從 Install Docker Engine on Ubuntu 總結出腳本，直接執行就好：\n#!/bin/bash\r# Uninstall old versions\rsudo apt-get remove docker docker-engine docker.io containerd runc\r# Set up the repository\r# Update the apt package index and install packages to allow apt to use a repository over HTTPS\rsudo apt-get update\rsudo apt-get install \\\rca-certificates \\\rcurl \\\rgnupg \\\rlsb-release\r# Add Docker’s official GPG key\rsudo mkdir -p /etc/apt/keyrings\rcurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\r# set up the repository\recho \\\r\u0026quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\r$(lsb_release -cs) stable\u0026quot; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null\r# Install Docker Engine\rsudo apt-get update\rsudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin -y\r# 把當前使用者加到 docker 群組\rsudo usermod -aG docker ${USER}\r# Verify that the Docker Engine installation is successful by running the hello-world image\rsudo docker run hello-world\rReference Install Docker Engine on Ubuntu ","date":"November 15, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/container/docker-install/","summary":"\u003cp\u003e從 \u003ca href=\"https://docs.docker.com/engine/install/ubuntu/\" target=\"_blank\" rel=\"noopener\"\u003eInstall Docker Engine on Ubuntu\u003c/a\u003e 總結出腳本，直接執行就好：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\r\n# Uninstall old versions\r\nsudo apt-get remove docker docker-engine docker.io containerd runc\r\n\r\n# Set up the repository\r\n# Update the apt package index and install packages to allow apt to use a repository over HTTPS\r\nsudo apt-get update\r\nsudo apt-get install \\\r\n    ca-certificates \\\r\n    curl \\\r\n    gnupg \\\r\n    lsb-release\r\n\r\n# Add Docker’s official GPG key\r\nsudo mkdir -p /etc/apt/keyrings\r\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\r\n\r\n# set up the repository\r\necho \\\r\n  \u0026quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\r\n  $(lsb_release -cs) stable\u0026quot; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null\r\n\r\n# Install Docker Engine\r\nsudo apt-get update\r\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin -y\r\n\r\n# 把當前使用者加到 docker 群組\r\nsudo usermod -aG docker ${USER}\r\n\r\n# Verify that the Docker Engine installation is successful by running the hello-world image\r\nsudo docker run hello-world\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"reference\"\u003eReference\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.docker.com/engine/install/ubuntu/\" target=\"_blank\" rel=\"noopener\"\u003eInstall Docker Engine on Ubuntu\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[Docker] 在 Ubuntu 安裝 Docker"},{"categories":null,"contents":"有用過 sweetalert2 的話，應該會喜歡可以同步等待對話框回傳值的方式， 這裡做一個 Vue2 元件，呼叫該元件的方法會彈出對話框等待使用者輸入，並且回傳 Promise， 如此一來就能夠在同一個函式當中處理使用者輸入值。\nDialog 元件設計原理:\n元件方法 GetConfirm() 顯示 Dialog 元件並回傳一個 Promise，。 設置watcher讓元件取得使用者輸入後 resolve promise 得利於上述元件的設計，實際上的效益是將複雜度封裝到子元件裡面(watcher移動到元件內)， 如此不需在上層元件撰寫使用者輸入取值的監視邏輯， 讓我們得以在上層元件直接 await GetConfirm 同步取得值進行操作。\n這個概念的用途非常廣，例如 Vue router 的 component route guard，在離開表單頁面前跳出使用者確認的 Dialog。\nVue3 實作 \u0026lt;template\u0026gt;\r\u0026lt;v-dialog v-model=\u0026quot;dialog\u0026quot; v-bind=\u0026quot;$attrs\u0026quot;\u0026gt;\r\u0026lt;slot v-bind=\u0026quot;{ Resolve }\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\r\u0026lt;/v-dialog\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script setup\u0026gt;\rimport { ref } from \u0026quot;vue\u0026quot;;\rconst dialog = ref(false);\rlet resolve = null;\rconst Resolve = (v) =\u0026gt; {\rresolve(v);\rdialog.value = false;\r};\rconst GetResult = async () =\u0026gt; {\rdialog.value = true;\rreturn new Promise((res) =\u0026gt; (resolve = res));\r};\rdefineExpose({ GetResult, Resolve });\r\u0026lt;/script\u0026gt;\r[舊]Vuejs 實作 \u0026lt;button id=\u0026quot;xBtn\u0026quot;\u0026gt;執行測試\u0026lt;/button\u0026gt;\r\u0026lt;div id=\u0026quot;xApp\u0026quot; class=\u0026quot;modal\u0026quot; :style=\u0026quot;{display: dialog?'block':'none'}\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;modal-content\u0026quot;\u0026gt;\r\u0026lt;span class=\u0026quot;close\u0026quot;\u0026gt;Test Modal\u0026lt;/span\u0026gt;\r\u0026lt;p\u0026gt;The value selected will resolve by promise.\u0026lt;/p\u0026gt;\r\u0026lt;button @click=\u0026quot;choose(1)\u0026quot;\u0026gt;1\u0026lt;/button\u0026gt;\r\u0026lt;button @click=\u0026quot;choose(2)\u0026quot;\u0026gt;2\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script\u0026gt;\rlet data = { result: null, dialog: false }\rlet dialog = new Vue({\rel: '#xApp',\rdata:() =\u0026gt; data,\rmethods: {\rgetConfirm() {\r// 先清空 result (避免兩次選中一樣的值無法觸發 watcher)\rthis.result = null // open dialog\rthis.dialog = true return new Promise((resolve, reject) =\u0026gt; {\rtry {\rconst watcher = this.$watch(\r// 設置監視的對象為 result\r() =\u0026gt; this.result ,\r// 一旦 result 的值有改變，就 resolve promise，並啟動下一輪 watcher (newVal) =\u0026gt; resolve(newVal) \u0026amp;\u0026amp; watcher()\r)\r} catch (error) {\r// 如果出錯就 reject promise\rreject(error)\r}\r})\r},\rchoose(value) {\r// 為 result 設置值觸發 watcher 解開 promise\rthis.result = value // 關閉 dialog\rthis.dialog = false\r}\r}\r})\rdocument.getElementById('xBtn')\r.addEventListener( 'click', async e =\u0026gt; alert( await dialog.getConfirm() )\r);\r\u0026lt;/script\u0026gt;\r/* The Modal (background) */\r.modal {\rdisplay: none; /* Hidden by default */\rposition: fixed; /* Stay in place */\rz-index: 1; /* Sit on top */\rpadding-top: 100px; /* Location of the box */\rleft: 0;\rtop: 0;\rwidth: 100%; /* Full width */\rheight: 100%; /* Full height */\roverflow: auto; /* Enable scroll if needed */\rbackground-color: rgb(0,0,0); /* Fallback color */\rbackground-color: rgba(0,0,0,0.4); /* Black w/ opacity */\r}\r/* Modal Content */\r.modal-content {\rbackground-color: #fefefe;\rmargin: auto;\rpadding: 20px;\rborder: 1px solid #888;\rwidth: 80%;\r}\r[舊]Vue-next 實作 這裡使用 vue-next/setup/quasar/typescript\n程式碼 \u0026lt;template\u0026gt;\r\u0026lt;q-dialog v-model=\u0026quot;model\u0026quot; :persistent=\u0026quot;persistent\u0026quot;\u0026gt;\r\u0026lt;q-card\u0026gt;\r\u0026lt;slot\u0026gt;\r\u0026lt;q-card-section\u0026gt; {{ textComputed }} \u0026lt;/q-card-section\u0026gt;\r\u0026lt;/slot\u0026gt;\r\u0026lt;q-card-actions align=\u0026quot;right\u0026quot;\u0026gt;\r\u0026lt;slot name=\u0026quot;action\u0026quot; :setter=\u0026quot;SetResult\u0026quot;\u0026gt;\r\u0026lt;q-btn dense color=\u0026quot;primary\u0026quot; label=\u0026quot;確認\u0026quot; @click=\u0026quot;SetResult(true)\u0026quot; /\u0026gt;\r\u0026lt;q-btn dense color=\u0026quot;info\u0026quot; label=\u0026quot;取消\u0026quot; @click=\u0026quot;SetResult(false)\u0026quot; /\u0026gt;\r\u0026lt;/slot\u0026gt;\r\u0026lt;/q-card-actions\u0026gt;\r\u0026lt;/q-card\u0026gt;\r\u0026lt;/q-dialog\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script setup lang=\u0026quot;ts\u0026quot;\u0026gt;\rimport { computed, ref, watch } from 'vue';\rconst model = ref(false);\rconst result = ref\u0026lt;unknown\u0026gt;(null);\rinterface IProps {\rtext?: string;\rpersistent?: boolean;\rwidth?: 'xs' | 'sm' | 'md' | 'lg' | 'max';\r}\rconst props = withDefaults(defineProps\u0026lt;IProps\u0026gt;(), {\rtext: '確認或取消？',\rpersistent: true,\rwidth: 'max',\r});\rdefineEmits(['input']);\rconst SetResult = (v: unknown) =\u0026gt; (result.value = v);\rconst textTmp = ref\u0026lt;string | null\u0026gt;(null);\rconst textComputed = computed(() =\u0026gt; textTmp.value || props.text);\rasync function GetResult(text: string | null = null) {\rtextTmp.value = text || null;\rresult.value = null;\rmodel.value = true;\rreturn new Promise((resolve, reject) =\u0026gt; {\rconsole.log('new promise...');\rtry {\rconst watcher = watch(\r() =\u0026gt; result.value,\r(cur) =\u0026gt; {\rresolve(cur);\rwatcher();\rmodel.value = false;\r}\r);\r} catch (error) {\rreject(error);\r}\r});\r}\rdefineExpose({ SetResult, GetResult, model });\r\u0026lt;/script\u0026gt;\r使用方法 \u0026lt;template\u0026gt;\r\u0026lt;!-- 確認 Dialog --\u0026gt;\r\u0026lt;DialogAsync ref=\u0026quot;dlg\u0026quot; width=\u0026quot;sm\u0026quot; /\u0026gt;\r\u0026lt;q-btn @click=\u0026quot;getUserInput()\u0026quot;\u0026gt; \u0026lt;/q-btn\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script setup lang=\u0026quot;ts\u0026quot;\u0026gt;\rimport DialogAsync from '../../components/DialogAsync/IndexPage.vue';\rimport { ref, Ref } from 'vue';\rconst dlg = ref(null);\r// 顯示文字並取得使用者輸入的 true 或 false\rconst check = async (str?: string | null) =\u0026gt;\rawait (dlg.value as typeof DialogAsync | null)?.GetResult(str);\rconst getUserInput = async () =\u0026gt; {\rlet result = await check('請確認')\rconsole.log('使用者選擇了：', result)\r}\r\u0026lt;/script\u0026gt;\r","date":"August 26, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/frontend-vue/vue-comp-promise/","summary":"\u003cp\u003e有用過 \u003ca href=\"https://sweetalert2.github.io/\" target=\"_blank\" rel=\"noopener\"\u003esweetalert2\u003c/a\u003e 的話，應該會喜歡可以同步等待對話框回傳值的方式，\n這裡做一個 Vue2 元件，呼叫該元件的方法會彈出對話框等待使用者輸入，並且回傳 Promise，\n如此一來就能夠在同一個函式當中處理使用者輸入值。\u003c/p\u003e\n\u003cp\u003eDialog 元件設計原理:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e元件方法 GetConfirm() 顯示 Dialog 元件並回傳一個 Promise，。\u003c/li\u003e\n\u003cli\u003e設置\u003ca href=\"https://vuejs.org/v2/api/#vm-watch\" target=\"_blank\" rel=\"noopener\"\u003ewatcher\u003c/a\u003e讓元件取得使用者輸入後 resolve promise\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e得利於上述元件的設計，實際上的效益是將複雜度封裝到子元件裡面(watcher移動到元件內)，\n如此不需在上層元件撰寫使用者輸入取值的監視邏輯，\n讓我們得以在上層元件直接 await GetConfirm 同步取得值進行操作。\u003c/p\u003e\n\u003cp\u003e這個概念的用途非常廣，例如 Vue router 的 component route guard，在離開表單頁面前跳出使用者確認的 Dialog。\u003c/p\u003e\n\u003ch2 id=\"vue3-實作\"\u003eVue3 實作\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;template\u0026gt;\r\n  \u0026lt;v-dialog v-model=\u0026quot;dialog\u0026quot; v-bind=\u0026quot;$attrs\u0026quot;\u0026gt;\r\n    \u0026lt;slot v-bind=\u0026quot;{ Resolve }\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\r\n  \u0026lt;/v-dialog\u0026gt;\r\n\u0026lt;/template\u0026gt;\r\n\r\n\u0026lt;script setup\u0026gt;\r\nimport { ref } from \u0026quot;vue\u0026quot;;\r\n\r\nconst dialog = ref(false);\r\nlet resolve = null;\r\n\r\nconst Resolve = (v) =\u0026gt; {\r\n  resolve(v);\r\n  dialog.value = false;\r\n};\r\n\r\nconst GetResult = async () =\u0026gt; {\r\n  dialog.value = true;\r\n  return new Promise((res) =\u0026gt; (resolve = res));\r\n};\r\ndefineExpose({ GetResult, Resolve });\r\n\u0026lt;/script\u0026gt;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"舊vuejs-實作\"\u003e[舊]Vuejs 實作\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;button id=\u0026quot;xBtn\u0026quot;\u0026gt;執行測試\u0026lt;/button\u0026gt;\r\n\u0026lt;div id=\u0026quot;xApp\u0026quot; class=\u0026quot;modal\u0026quot; :style=\u0026quot;{display: dialog?'block':'none'}\u0026quot;\u0026gt;\r\n  \u0026lt;div class=\u0026quot;modal-content\u0026quot;\u0026gt;\r\n    \u0026lt;span class=\u0026quot;close\u0026quot;\u0026gt;Test Modal\u0026lt;/span\u0026gt;\r\n    \u0026lt;p\u0026gt;The value selected will resolve by promise.\u0026lt;/p\u0026gt;\r\n    \u0026lt;button @click=\u0026quot;choose(1)\u0026quot;\u0026gt;1\u0026lt;/button\u0026gt;\r\n    \u0026lt;button @click=\u0026quot;choose(2)\u0026quot;\u0026gt;2\u0026lt;/button\u0026gt;\r\n  \u0026lt;/div\u0026gt;\r\n\u0026lt;/div\u0026gt;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\n \r\n\u0026lt;script\u0026gt;\r\nlet data = { result: null, dialog: false }\r\nlet dialog = new Vue({\r\n  el: '#xApp',\r\n  data:() =\u0026gt; data,\r\n  methods: {\r\n   getConfirm() {\r\n     // 先清空 result (避免兩次選中一樣的值無法觸發 watcher)\r\n     this.result = null \r\n     // open dialog\r\n     this.dialog = true \r\n     return new Promise((resolve, reject) =\u0026gt; {\r\n       try {\r\n         const watcher = this.$watch(\r\n           // 設置監視的對象為 result\r\n           () =\u0026gt; this.result ,\r\n           // 一旦 result 的值有改變，就 resolve promise，並啟動下一輪 watcher \r\n           (newVal) =\u0026gt; resolve(newVal) \u0026amp;\u0026amp; watcher()\r\n         )\r\n       } catch (error) {\r\n         // 如果出錯就 reject promise\r\n         reject(error)\r\n       }\r\n     })\r\n   },\r\n   choose(value) {\r\n     // 為 result 設置值觸發 watcher 解開 promise\r\n     this.result = value \r\n     // 關閉 dialog\r\n     this.dialog = false\r\n   }\r\n  }\r\n})\r\ndocument.getElementById('xBtn')\r\n  .addEventListener( 'click', \r\n      async e =\u0026gt; alert( await dialog.getConfirm() )\r\n    );\r\n\u0026lt;/script\u0026gt;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-css\"\u003e/* The Modal (background) */\r\n.modal {\r\n  display: none; /* Hidden by default */\r\n  position: fixed; /* Stay in place */\r\n  z-index: 1; /* Sit on top */\r\n  padding-top: 100px; /* Location of the box */\r\n  left: 0;\r\n  top: 0;\r\n  width: 100%; /* Full width */\r\n  height: 100%; /* Full height */\r\n  overflow: auto; /* Enable scroll if needed */\r\n  background-color: rgb(0,0,0); /* Fallback color */\r\n  background-color: rgba(0,0,0,0.4); /* Black w/ opacity */\r\n}\r\n\r\n/* Modal Content */\r\n.modal-content {\r\n  background-color: #fefefe;\r\n  margin: auto;\r\n  padding: 20px;\r\n  border: 1px solid #888;\r\n  width: 80%;\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"舊vue-next-實作\"\u003e[舊]Vue-next 實作\u003c/h2\u003e\n\u003cp\u003e這裡使用 vue-next/setup/quasar/typescript\u003c/p\u003e","tags":null,"title":"[DIY] 設計一個可回傳 Promise 的 Dialog 元件方法"},{"categories":null,"contents":"目前使用 docker 疊前端的編譯環境比較複雜，不比本機端方便，本篇的把 SSG 發布流程移植到前端專案。\n一鍵產生前端靜態資源到特定分支，可設定該分支進入 CI/CD 流程。 在同一 Git Repo 管理部屬的靜態資源與原始碼。 P.S.這裡是以 quasar CLI 為例，專案放在 gitlab，腳本可在 git bash 環境執行，build 指令是 quasar build，輸出的 路徑是 dist/spa，不同專案架構需要作相對應調整。 Git 設定 建立一個 spa orphan branch P.S. 不需在 gitlab 上事先新增相對應的 branch\ngit checkout --orphan spa\rgit reset --hard\rgit commit --allow-empty -m \u0026quot;Initializing gh-pages branch\u0026quot;\rgit push origin spa\rgit checkout master\r新增部屬腳本 deploy.sh 新增到專案跟目錄\n#!/bin/bash\r# 如果要檢查是否有 commit才進行部屬，就取消註解\r# if [ \u0026quot;`git status -s`\u0026quot; ]\r# then # echo \u0026quot;The working directory is dirty. Please commit any pending changes.\u0026quot;\t# exit 1;\r# fi\recho \u0026quot;Deleting old publication\u0026quot;\rrm -rf dist\rmkdir dist\r# 清空 worktree\rgit worktree prune rm -rf .git/worktrees/dist/\r# 新增 worktree\recho \u0026quot;Checking out spa branch into /dist\u0026quot;\rgit worktree add -B spa dist origin/spa\recho \u0026quot;Generating site\u0026quot;\rquasar build \u0026amp;\u0026amp; cp -r deploy/. dist/\recho \u0026quot;Updating spa branch\u0026quot;\rcd dist \u0026amp;\u0026amp; git add --all \u0026amp;\u0026amp; git commit -m \u0026quot;Publishing to spa \u0026quot;\r#echo \u0026quot;Pushing to github\u0026quot;\rgit push --all\r修改 package.json 新增一項 script：deploy \u0026quot;deploy\u0026quot;: \u0026quot;bash deploy.sh\u0026quot;,\r把 branch 設置為 Protected 先執行一次 npm run deploy，讓 git 上產生 spa 這個 orphan branch 再到這裡把 spa 設定為 Protected Branche：Settings-\u0026gt;Repository-\u0026gt;Protected Branches\nCICD 設定 新增 deploy 資料夾 mkdir deploy\r新增 Docker 檔案 在 deploy 下新增 Dockerfile\n# production stage\rFROM nginx:stable-alpine as production-stage\rCOPY spa/ /usr/share/nginx/html\rEXPOSE 80\rCMD [\u0026quot;nginx\u0026quot;, \u0026quot;-g\u0026quot;, \u0026quot;daemon off;\u0026quot;]\r在 deploy 下新增 .dockerignore\n.gitlab-ci.yml\rdeployment.yaml\r至此前端 CLI 專案的容器化設定完成了， 可以進一步依照 DepOps 流程設定 gitlab-runner、CICD Variable、.gitlab-ci.yml、deployment.yml 等等\u0026hellip;，串接 CI/CD 其中 .gitlab-ci.ycm 當中需要把 stage 的 -only 指定給 spa branch 等等\u0026hellip;\n使用 設定完畢一行指令就能部屬，如此能夠在同一個專案管理原始碼和發布的靜態資源，如果 gitlab 上有設置 CICD 流程也可以把 spa branch 設定進自動部屬。\nnpm run deploy\r","date":"August 25, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/devops/git-orphan-worktree/","summary":"\u003cp\u003e目前使用 docker 疊前端的編譯環境比較複雜，不比本機端方便，本篇的把 SSG 發布流程移植到前端專案。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一鍵產生前端靜態資源到特定分支，可設定該分支進入 CI/CD 流程。\u003c/li\u003e\n\u003cli\u003e在同一 Git Repo 管理部屬的靜態資源與原始碼。\nP.S.這裡是以 quasar CLI 為例，專案放在 gitlab，腳本可在 git bash 環境執行，build 指令是 quasar build，輸出的 路徑是 dist/spa，不同專案架構需要作相對應調整。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"git-設定\"\u003eGit 設定\u003c/h2\u003e\n\u003ch3 id=\"建立一個-spa-orphan-branch\"\u003e建立一個 spa orphan branch\u003c/h3\u003e\n\u003cp\u003eP.S. 不需在 gitlab 上事先新增相對應的 branch\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit checkout --orphan spa\r\ngit reset --hard\r\ngit commit --allow-empty -m \u0026quot;Initializing gh-pages branch\u0026quot;\r\ngit push origin spa\r\ngit checkout master\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"新增部屬腳本-deploysh\"\u003e新增部屬腳本 deploy.sh\u003c/h3\u003e\n\u003cp\u003e新增到專案跟目錄\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\r\n# 如果要檢查是否有 commit才進行部屬，就取消註解\r\n# if [ \u0026quot;`git status -s`\u0026quot; ]\r\n# then \r\n# \techo \u0026quot;The working directory is dirty. Please commit any pending changes.\u0026quot;\t\r\n# \texit 1;\r\n# fi\r\n\r\necho \u0026quot;Deleting old publication\u0026quot;\r\nrm -rf dist\r\nmkdir dist\r\n# 清空 worktree\r\ngit worktree prune \r\nrm -rf .git/worktrees/dist/\r\n\r\n# 新增 worktree\r\necho \u0026quot;Checking out spa branch into /dist\u0026quot;\r\ngit worktree add -B spa dist origin/spa\r\n\r\necho \u0026quot;Generating site\u0026quot;\r\nquasar build \u0026amp;\u0026amp; cp -r deploy/. dist/\r\n\r\necho \u0026quot;Updating spa branch\u0026quot;\r\ncd dist \u0026amp;\u0026amp; git add --all \u0026amp;\u0026amp; git commit -m \u0026quot;Publishing to spa \u0026quot;\r\n\r\n#echo \u0026quot;Pushing to github\u0026quot;\r\ngit push --all\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"修改-packagejson-新增一項-scriptdeploy\"\u003e修改 package.json 新增一項 script：deploy\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e\u0026quot;deploy\u0026quot;: \u0026quot;bash deploy.sh\u0026quot;,\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"把-branch-設置為-protected\"\u003e把 branch 設置為 Protected\u003c/h3\u003e\n\u003cp\u003e先執行一次 \u003ccode\u003enpm run deploy\u003c/code\u003e，讓 git 上產生 spa 這個 orphan branch\n再到這裡把 spa 設定為 Protected Branche：\u003ccode\u003eSettings-\u0026gt;Repository-\u0026gt;Protected Branches\u003c/code\u003e\u003c/p\u003e","tags":null,"title":"[DIY] 利用 orphan branch 和 worktree 在同一 Git 儲存庫控管原始碼與靜態資源分支"},{"categories":null,"contents":"基於資訊安全的理由，密碼等敏感性資訊不應該出現在程式碼裡面， 應該把敏感性資料儲存在專案以外的地方，防止對 Git Server 提交專案程式碼的時候把密碼推送到伺服器上， 因此程式開發、部屬階段都應該用適當的策略存放敏感性資料讓程式讀取使用， .NET 儲存敏感性資料大致上來說可以用這兩種方式：\n環境變數 Secret Manager 這裡紀錄要如何在 .NET 開發環境以 Secret 儲存敏感性資料，以及程式讀取的方式。\nSecret Manager Secret Manager 就是在本地端特定路徑存放 secret.json 檔案：\n%APPDATA%\\Microsoft\\UserSecrets\\\u0026lt;user_secrets_id\u0026gt;\\secrets.json\r~/.microsoft/usersecrets/\u0026lt;user_secrets_id\u0026gt;/secrets.json\r需要先針對個別專案啟用專案的 Secret Storage 支援，切換到專案目錄執行：\ndotnet user-secrets init\r在專案檔裡的 UserSecretsId 區段會得到一段 GUID，這個要作為 user_secrets_id 資料夾名稱。\n\u0026lt;PropertyGroup\u0026gt;\r\u0026lt;TargetFramework\u0026gt;netcoreapp3.1\u0026lt;/TargetFramework\u0026gt;\r\u0026lt;UserSecretsId\u0026gt;79a3edd0-2092-40a2-a04d-dcb46d5ca9ed\u0026lt;/UserSecretsId\u0026gt;\r\u0026lt;/PropertyGroup\u0026gt;\r以指令設置一組 secret，例如連線字串：\ndotnet user-secrets set \u0026quot;ConnectionStrings:POSTGRES\u0026quot; \u0026quot;User ID=root;Password=myPassword;Host=localhost;Port=5432;Database=myDataBase;Pooling=true;Min Pool Size=0;Max Pool Size=100;Connection Lifetime=0;\u0026quot; --project \u0026quot;D:\\workspace\\MySolution\\MyProject\u0026quot;\r以檔案直接設置 secret windows\ntype .\\input.json | dotnet user-secrets set\rLinux/MacOS\ncat ./input.json | dotnet user-secrets set\r在程式裡面存在 secret.json 裡面，感覺就像寫在 appsettings.json 裡面一樣，存取方式沒有有任何差別：\n// 用讀取 appsetting.json 的方法讀取設定區段值取得連線字串\rvar connectionString = Configuration.GetSection(\u0026quot;ConnectionStrings:POSTGRES\u0026quot;).Get\u0026lt;string\u0026gt;();\r// 如果設定區段是連線字串也可以直接使用 GetConnectionString\rvar connectionString = Configuration.GetConnectionString(\u0026quot;POSTGRES\u0026quot;);\rReference MSDN - Safe storage of app secrets in development in ASP.NET Core ","date":"July 29, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/secret/","summary":"\u003cp\u003e基於資訊安全的理由，密碼等敏感性資訊不應該出現在程式碼裡面，\n應該把敏感性資料儲存在專案以外的地方，防止對 Git Server 提交專案程式碼的時候把密碼推送到伺服器上，\n因此程式開發、部屬階段都應該用適當的策略存放敏感性資料讓程式讀取使用，\n.NET 儲存敏感性資料大致上來說可以用這兩種方式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e環境變數\u003c/li\u003e\n\u003cli\u003eSecret Manager\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e這裡紀錄要如何在 .NET 開發環境以 Secret 儲存敏感性資料，以及程式讀取的方式。\u003c/p\u003e\n\u003ch2 id=\"secret-manager\"\u003eSecret Manager\u003c/h2\u003e\n\u003cp\u003eSecret Manager 就是在本地端特定路徑存放 secret.json 檔案：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bat\"\u003e%APPDATA%\\Microsoft\\UserSecrets\\\u0026lt;user_secrets_id\u0026gt;\\secrets.json\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-Linux/MacOS\"\u003e~/.microsoft/usersecrets/\u0026lt;user_secrets_id\u0026gt;/secrets.json\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e需要先針對個別專案啟用專案的 Secret Storage 支援，切換到專案目錄執行：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003edotnet user-secrets init\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在專案檔裡的 UserSecretsId 區段會得到一段 GUID，這個要作為 user_secrets_id 資料夾名稱。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;PropertyGroup\u0026gt;\r\n  \u0026lt;TargetFramework\u0026gt;netcoreapp3.1\u0026lt;/TargetFramework\u0026gt;\r\n  \u0026lt;UserSecretsId\u0026gt;79a3edd0-2092-40a2-a04d-dcb46d5ca9ed\u0026lt;/UserSecretsId\u0026gt;\r\n\u0026lt;/PropertyGroup\u0026gt;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e以指令設置一組 secret，例如連線字串：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003edotnet user-secrets set \u0026quot;ConnectionStrings:POSTGRES\u0026quot; \u0026quot;User ID=root;Password=myPassword;Host=localhost;Port=5432;Database=myDataBase;Pooling=true;Min Pool Size=0;Max Pool Size=100;Connection Lifetime=0;\u0026quot; --project \u0026quot;D:\\workspace\\MySolution\\MyProject\u0026quot;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e以檔案直接設置 secret\nwindows\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bat\"\u003etype .\\input.json | dotnet user-secrets set\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLinux/MacOS\u003c/p\u003e","tags":null,"title":"[.NET] 開發階段管理應用程式的敏感資料"},{"categories":null,"contents":"準備/安裝兩台 Server ( 使用 VM clone 然後修改 hostname ) 一台為 Master (主控)，另外一台為 Node ( 節點 ) 安裝 kubelet/kubeadm ( Master 與 node 皆要執行此步驟 )\n# 設定 k8s server上網路\rcat \u0026lt;\u0026lt;EOF | sudo tee /etc/sysctl.d/k8s.conf\rnet.bridge.bridge-nf-call-ip6tables = 1\rnet.bridge.bridge-nf-call-iptables = 1\rEOF\rsudo sysctl --system\r# 安裝 kubeadm / kubelet\rsudo apt-get update \u0026amp;\u0026amp; sudo apt-get install -y apt-transport-https curl\rcurl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -\rcat \u0026lt;\u0026lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list\rdeb https://apt.kubernetes.io/ kubernetes-xenial main\rEOF\rsudo apt-get update\rsudo apt-get install -y kubelet kubeadm kubectl\rsudo apt-mark hold kubelet kubeadm kubectl\r# 安裝 Docker\rsudo apt-get install apt-transport-https ca-certificates curl software-properties-common\rcurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\rsudo add-apt-repository \u0026quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026quot;\rsudo apt update\rsudo apt-get install docker-ce -y\rdocker --version\rsudo systemctl start docker\rsudo chmod 666 /var/run/docker.sock\rsudo systemctl enable docker\rcat \u0026lt;\u0026lt;EOF | sudo tee /etc/docker/daemon.json\r{\r\u0026quot;exec-opts\u0026quot;: [\u0026quot;native.cgroupdriver=systemd\u0026quot;]\r}\rEOF\rsudo systemctl restart docker\r# 關閉 swap\rsudo swapoff -a\rsudo sed -i '/\\/swap/s/^/#/' /etc/fstab\r# 設定服務自動重啟\rsystemctl enable kubelet\r# Master Node 啟動\rsudo kubeadm init --pod-network-cidr=192.168.0.0/16\rkubectl taint nodes --all node-role.kubernetes.io/master-\r# kubeconfig\rmkdir -p $HOME/.kube\rsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\rsudo chown $(id -u):$(id -g) $HOME/.kube/config\r# Deploying a pod network\rkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml\r","date":"July 23, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/container/k8s-basc-install/","summary":"\u003cp\u003e準備/安裝兩台 Server ( 使用 VM clone 然後修改 hostname )\n一台為 Master (主控)，另外一台為 Node ( 節點 )\n安裝 kubelet/kubeadm ( Master 與 node 皆要執行此步驟 )\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 設定 k8s server上網路\r\ncat \u0026lt;\u0026lt;EOF | sudo tee /etc/sysctl.d/k8s.conf\r\nnet.bridge.bridge-nf-call-ip6tables = 1\r\nnet.bridge.bridge-nf-call-iptables = 1\r\nEOF\r\nsudo sysctl --system\r\n\r\n# 安裝 kubeadm / kubelet\r\nsudo apt-get update \u0026amp;\u0026amp; sudo apt-get install -y apt-transport-https curl\r\ncurl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -\r\ncat \u0026lt;\u0026lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list\r\ndeb https://apt.kubernetes.io/ kubernetes-xenial main\r\nEOF\r\nsudo apt-get update\r\nsudo apt-get install -y kubelet kubeadm kubectl\r\nsudo apt-mark hold kubelet kubeadm kubectl\r\n\r\n# 安裝 Docker\r\nsudo apt-get install apt-transport-https ca-certificates curl software-properties-common\r\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\r\nsudo add-apt-repository \u0026quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026quot;\r\nsudo apt update\r\nsudo apt-get install docker-ce -y\r\ndocker --version\r\nsudo systemctl start docker\r\nsudo chmod 666 /var/run/docker.sock\r\nsudo systemctl enable docker\r\ncat \u0026lt;\u0026lt;EOF | sudo tee /etc/docker/daemon.json\r\n{\r\n  \u0026quot;exec-opts\u0026quot;: [\u0026quot;native.cgroupdriver=systemd\u0026quot;]\r\n}\r\nEOF\r\n\r\nsudo systemctl restart docker\r\n\r\n# 關閉 swap\r\nsudo swapoff -a\r\nsudo sed -i '/\\/swap/s/^/#/' /etc/fstab\r\n\r\n# 設定服務自動重啟\r\nsystemctl enable kubelet\r\n\r\n# Master Node 啟動\r\nsudo kubeadm init --pod-network-cidr=192.168.0.0/16\r\nkubectl taint nodes --all node-role.kubernetes.io/master-\r\n\r\n# kubeconfig\r\nmkdir -p $HOME/.kube\r\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\r\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\r\n\r\n# Deploying a pod network\r\nkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml\r\n\u003c/code\u003e\u003c/pre\u003e","tags":null,"title":"[K8S] 自架 Kubernetes 使用 VM 模擬多台 Server"},{"categories":null,"contents":"安裝 nuget.exe CLI 安裝 nuget.exe CLI，並在環境變數 PATH 新增路徑。\n建立 nuspec 設定檔 example\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;package \u0026gt;\r\u0026lt;metadata\u0026gt;\r\u0026lt;id\u0026gt;MyPackage\u0026lt;/id\u0026gt; \u0026lt;!--package id --\u0026gt;\r\u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;!--版本號--\u0026gt;\r\u0026lt;title\u0026gt;MyPackage\u0026lt;/title\u0026gt; \u0026lt;!-- package title --\u0026gt;\r\u0026lt;authors\u0026gt;Chen, Yu Cheng\u0026lt;/authors\u0026gt; \u0026lt;!-- 作者 --\u0026gt;\r\u0026lt;requireLicenseAcceptance\u0026gt;false\u0026lt;/requireLicenseAcceptance\u0026gt;\r\u0026lt;license type=\u0026quot;expression\u0026quot;\u0026gt;MIT\u0026lt;/license\u0026gt;\r\u0026lt;!-- \u0026lt;icon\u0026gt;icon.png\u0026lt;/icon\u0026gt; --\u0026gt;\r\u0026lt;!--\u0026lt;projectUrl\u0026gt;http://project_url_here_or_delete_this_line/\u0026lt;/projectUrl\u0026gt;--\u0026gt;\r\u0026lt;description\u0026gt;MyPackage\u0026lt;/description\u0026gt;\r\u0026lt;releaseNotes\u0026gt;Test release of MyPackage package.\u0026lt;/releaseNotes\u0026gt;\r\u0026lt;copyright\u0026gt;-\u0026lt;/copyright\u0026gt;\r\u0026lt;tags\u0026gt;\u0026lt;/tags\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;!-- 定義 .net framework 4.0 使用時需要的相依姓套件 --\u0026gt;\r\u0026lt;group targetFramework=\u0026quot;.NETFramework4.0.0\u0026quot; \u0026gt;\r\u0026lt;dependency id=\u0026quot;Dapper\u0026quot; version=\u0026quot;1.50.2\u0026quot; /\u0026gt;\r\u0026lt;dependency id=\u0026quot;Newtonsoft.Json\u0026quot; version=\u0026quot;7.0.1\u0026quot; /\u0026gt;\r\u0026lt;/group\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r\u0026lt;/metadata\u0026gt;\r\u0026lt;/package\u0026gt;\r打包檔案 假設最低系統需求為 .net framework 4.0，將 Release 複製檔案複製到對應版本的資料夾內，目錄結構如下：\n根目錄\r├─MyPack.1.0.0.nupkg\r└─lib\r└─net40\r└─MyPack.dll\r編譯專案，打包指令：\nnuget pack MyPack.nuspec\r會多一個 MyPack.1.0.0.nupkg\n根目錄\r├─MyPack.nuspec\r├─MyPack.1.0.0.nupkg\r└─lib\r└─net40\r└─MyPack.dll\r上傳到 nuget 用指令上傳(要先拿到 API-KEY)\nnuget push YourPackage.nupkg --source http://nuget.com.tw/api/v3/index.json --api-key API-KEY\rReference MSDN - Create package-Create a package using the nuget.exe CLI MSDN - Nuspace ","date":"July 22, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/nuget/","summary":"\u003ch2 id=\"安裝-nugetexe-cli\"\u003e安裝 nuget.exe CLI\u003c/h2\u003e\n\u003cp\u003e安裝 \u003ca href=\"https://docs.microsoft.com/en-us/nuget/install-nuget-client-tools#nugetexe-cli\" target=\"_blank\" rel=\"noopener\"\u003enuget.exe CLI\u003c/a\u003e，並在環境變數 PATH 新增路徑。\u003c/p\u003e\n\u003ch2 id=\"建立-nuspec-設定檔\"\u003e建立 nuspec 設定檔\u003c/h2\u003e\n\u003cp\u003eexample\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\n\u0026lt;package \u0026gt;\r\n  \u0026lt;metadata\u0026gt;\r\n    \u0026lt;id\u0026gt;MyPackage\u0026lt;/id\u0026gt; \u0026lt;!--package id --\u0026gt;\r\n    \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;!--版本號--\u0026gt;\r\n    \u0026lt;title\u0026gt;MyPackage\u0026lt;/title\u0026gt; \u0026lt;!-- package title --\u0026gt;\r\n    \u0026lt;authors\u0026gt;Chen, Yu Cheng\u0026lt;/authors\u0026gt; \u0026lt;!-- 作者 --\u0026gt;\r\n    \u0026lt;requireLicenseAcceptance\u0026gt;false\u0026lt;/requireLicenseAcceptance\u0026gt;\r\n    \u0026lt;license type=\u0026quot;expression\u0026quot;\u0026gt;MIT\u0026lt;/license\u0026gt;\r\n    \u0026lt;!-- \u0026lt;icon\u0026gt;icon.png\u0026lt;/icon\u0026gt; --\u0026gt;\r\n    \u0026lt;!--\u0026lt;projectUrl\u0026gt;http://project_url_here_or_delete_this_line/\u0026lt;/projectUrl\u0026gt;--\u0026gt;\r\n    \u0026lt;description\u0026gt;MyPackage\u0026lt;/description\u0026gt;\r\n    \u0026lt;releaseNotes\u0026gt;Test release of MyPackage package.\u0026lt;/releaseNotes\u0026gt;\r\n    \u0026lt;copyright\u0026gt;-\u0026lt;/copyright\u0026gt;\r\n    \u0026lt;tags\u0026gt;\u0026lt;/tags\u0026gt;\r\n\t  \u0026lt;dependencies\u0026gt;\r\n\t    \u0026lt;!-- 定義 .net framework 4.0 使用時需要的相依姓套件 --\u0026gt;\r\n\t\t\u0026lt;group targetFramework=\u0026quot;.NETFramework4.0.0\u0026quot; \u0026gt;\r\n\t\t  \u0026lt;dependency id=\u0026quot;Dapper\u0026quot; version=\u0026quot;1.50.2\u0026quot; /\u0026gt;\r\n\t\t  \u0026lt;dependency id=\u0026quot;Newtonsoft.Json\u0026quot; version=\u0026quot;7.0.1\u0026quot; /\u0026gt;\r\n\t\t\u0026lt;/group\u0026gt;\r\n\t  \u0026lt;/dependencies\u0026gt;\r\n  \u0026lt;/metadata\u0026gt;\r\n\u0026lt;/package\u0026gt;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"打包檔案\"\u003e打包檔案\u003c/h2\u003e\n\u003cp\u003e假設最低系統需求為 .net framework 4.0，將 Release 複製檔案複製到對應版本的資料夾內，目錄結構如下：\u003c/p\u003e","tags":null,"title":"[.NET] 製作 Nuget package"},{"categories":null,"contents":"Introduction Managed ODP.NET 連線資料庫標榜不需要額外安裝 Oracle Client，資料庫連線資訊可以透過：\n程式內直接設定 connection string。 解析環境變數 TNS_ADMIN 所指資料夾下的 tnsnames.ora。 考慮到可維護性，一旦連線資訊有所變動(Ip/Domain/Port/Service Name/SID)，如果直接將連線字串寫在程式裡面，就需要重新佈署每個程式專案， 因此如果讓 Managed ODP.NET 讀取共用的設定就能夠擁有只維護一份連線資訊的方便性。\n單主機的做法是部屬 tnsnames.ora 檔案，但因為 K8S 中 pod 都是隔離的環境，要共用連線資訊透過研究可能有這幾種方式：\nExternalName Service 對應外部的資料庫位址，無法因應 ip, service name, sid 修改。 Service + Endpoints 轉送 ip 和 port。 Secret Volume 共用 tnsnames.ora。 三種連線資訊共用策略是否能反映連線資訊修改：\nExternalName Service Service + Endpoints Secret Volume Ip/Domain 可 可 可 Port 不能 可 可 Service Name/SID 不能 不能 可 Step Secret 用處：\n作為容器的環境變數 (但只會在 pod 啟動的時候載入，無法反映動態更改) 作為檔案，可被掛載在其他 Pod 的檔案路徑下，此時 key 視為檔案名稱，value 視為檔案內容，可動態反映修改 作為 deployment 的一部分，敏感資料統一存放在 Docker image，讓其他 pod 可以 pull 存取(也無法動態反映修改，要重新 pull) 因此如果要維護 tnsnames.ora，又不需要重啟每個應用程式，必須採取 Secret Volume 共用 tnsnames.ora P.S. 另外資料庫的使用者帳號、密碼機敏資訊的儲存也可以透過 Secret 提供給 Pod P.S. 不能是 subPath\n創建 Secrete $ kubectl create secret generic db-secret --from-file=tnsnames.ora\rsecret/db-secret created\r$ kubectl get secret\rNAME TYPE DATA AGE\rdb-secrete Opaque 1 14s\rdeployment.yaml apiVersion : apps/v1\rkind : Deployment\rmetadata : name : testap-deployment\rspec : selector : matchLabels : app : testap\rreplicas : 1\rtemplate : metadata : labels : app : testap\rspec : containers : - name : testap\rimage : testap\rports : - containerPort : 80\rimagePullPolicy: Never\renv:\r- name: TZ\rvalue: Asia/Taipei\r- name: TNS_ADMIN\rvalue: /etc/oracle\rvolumeMounts:\r- name: tnsora\rmountPath: \u0026quot;/etc/oracle\u0026quot;\rreadOnly: true\rvolumes:\r- name: tnsora\rsecret:\rsecretName: db-secrete\roptional: false # default setting; \u0026quot;mysecret\u0026quot; must exist\r---\rapiVersion: v1\rkind: Service\rmetadata:\rname: testap-service\rspec:\rtype: ClusterIP\rselector:\rapp: testap\rports:\r- protocol: TCP\rport: 80 targetPort: 80 AP code var datasource = \u0026quot;\u0026quot;;\rvar userid = \u0026quot;\u0026quot;;\rvar password = \u0026quot;\u0026quot;;\rvar cnstr = $\u0026quot;Data Source={datasource};;USER ID={userid};PASSWORD={password};;\u0026quot;;\rusing (var cn = new OracleConnection(cnstr)) {\ropname = cn.QueryFirstOrDefault\u0026lt;string\u0026gt;(\u0026quot;select 1 from dual\u0026quot;);\r}\rkubectl apply -f testap.yml\rminikube kubectl -- expose deployment testap-deployment --type=NodePort --port=80\rminikube kubectl -- port-forward testap-deployment-66797fd85b-gx64z 8080:80\r這時可以打開 http://{k8s ip}:8080，看\nReference ithome - [Day 12] 敏感的資料怎麼存在k8s?! - Secrets kubernetes - Secrets kubernetes - Configure Service Accounts for Pods Oracle - Oracle Data Provider for .NET Core Configuration Oracle tnsnames.ora Distribution Management System! IIS 環境 (Window Server) 有下面兩種做法：\n以 NFS 共用 tnsnames.ora (網路斷線就讀不到) 連線資訊有更動時，直接利用腳本更新每台機器的 tnsnames.ora Reference Oracle tnsnames.ora Distribution Management System! ","date":"July 21, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/container/k8s-example-tnsnames.ora/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eManaged ODP.NET 連線資料庫標榜不需要額外安裝 Oracle Client，資料庫連線資訊可以透過：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e程式內直接設定 connection string。\u003c/li\u003e\n\u003cli\u003e解析環境變數 TNS_ADMIN 所指資料夾下的 tnsnames.ora。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e考慮到可維護性，一旦連線資訊有所變動(Ip/Domain/Port/Service Name/SID)，如果直接將連線字串寫在程式裡面，就需要重新佈署每個程式專案，\n因此如果讓 Managed ODP.NET 讀取共用的設定就能夠擁有只維護一份連線資訊的方便性。\u003c/p\u003e\n\u003cp\u003e單主機的做法是部屬 tnsnames.ora 檔案，但因為 K8S 中 pod 都是隔離的環境，要共用連線資訊透過研究可能有這幾種方式：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eExternalName Service\u003c/strong\u003e 對應外部的資料庫位址，無法因應 ip, service name, sid 修改。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eService + Endpoints\u003c/strong\u003e 轉送 ip 和 port。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSecret Volume\u003c/strong\u003e 共用 tnsnames.ora。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e三種連線資訊共用策略是否能反映連線資訊修改：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c/th\u003e\n          \u003cth\u003eExternalName Service\u003c/th\u003e\n          \u003cth\u003eService + Endpoints\u003c/th\u003e\n          \u003cth\u003eSecret Volume\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eIp/Domain\u003c/td\u003e\n          \u003ctd\u003e可\u003c/td\u003e\n          \u003ctd\u003e可\u003c/td\u003e\n          \u003ctd\u003e可\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ePort\u003c/td\u003e\n          \u003ctd\u003e不能\u003c/td\u003e\n          \u003ctd\u003e可\u003c/td\u003e\n          \u003ctd\u003e可\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eService Name/SID\u003c/td\u003e\n          \u003ctd\u003e不能\u003c/td\u003e\n          \u003ctd\u003e不能\u003c/td\u003e\n          \u003ctd\u003e可\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"step\"\u003eStep\u003c/h2\u003e\n\u003cp\u003eSecret 用處：\u003c/p\u003e","tags":null,"title":"[K8s] 以 Secrete 共享 tnsnames.ora"},{"categories":null,"contents":"添加 Swagger dotnet add web-logger.csproj package Swashbuckle.AspNetCore -v 6.2.3\rProgram.cs\nbuilder.Services.AddControllers();\rbuilder.Services.AddEndpointsApiExplorer();\rbuilder.Services.AddSwaggerGen();\rhttps://localhost:\u0026lt;port\u0026gt;/swagger/index.html 添加一行 uniFormat 設置，讓專案除錯啟動的時候打開 swagger 讓Swagger 認得 IActionResult 的 api 接收/回傳型別 https://stackoverflow.com/questions/53105513/swagger-not-generating-model-for-object-wrapped-by-iactionresult\n\u0026quot;serverReadyAction\u0026quot;: {\r\u0026quot;action\u0026quot;: \u0026quot;openExternally\u0026quot;,\r\u0026quot;pattern\u0026quot;: \u0026quot;^\\\\s*Now listening on:\\\\s+(https?://\\\\S+)\u0026quot;,\r\u0026quot;uriFormat\u0026quot;: \u0026quot;%s/swagger\u0026quot;\r}\rASP.NET Core doesn\u0026rsquo;t include a logging provider for writing logs to files. To write logs to files from an ASP.NET Core app, consider using a third-party logging provider. https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-6.0 .NET Standard 2.0 之後內建沒有 ConfigurationManager ，需要額外安裝 dotnet add package System.Configuration.ConfigurationManager --version 6.0.0 https://stackoverflow.com/questions/46360716/cant-use-system-configuration-configuration-manager-in-a-net-standard2-0-libra\nReference https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-6.0\u0026tabs=visual-studio-code\n","date":"July 18, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/startup-webapi/","summary":"\u003ch2 id=\"添加-swagger\"\u003e添加 Swagger\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003edotnet add web-logger.csproj package Swashbuckle.AspNetCore -v 6.2.3\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eProgram.cs\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c#\"\u003ebuilder.Services.AddControllers();\r\n\r\nbuilder.Services.AddEndpointsApiExplorer();\r\nbuilder.Services.AddSwaggerGen();\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ehttps://localhost:\u0026lt;port\u0026gt;/swagger/index.html\u003c/code\u003e\n添加一行 uniFormat 設置，讓專案除錯啟動的時候打開 swagger\n讓Swagger 認得 IActionResult 的 api 接收/回傳型別\n\u003ca href=\"https://stackoverflow.com/questions/53105513/swagger-not-generating-model-for-object-wrapped-by-iactionresult\" target=\"_blank\" rel=\"noopener\"\u003ehttps://stackoverflow.com/questions/53105513/swagger-not-generating-model-for-object-wrapped-by-iactionresult\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e\u0026quot;serverReadyAction\u0026quot;: {\r\n    \u0026quot;action\u0026quot;: \u0026quot;openExternally\u0026quot;,\r\n    \u0026quot;pattern\u0026quot;: \u0026quot;^\\\\s*Now listening on:\\\\s+(https?://\\\\S+)\u0026quot;,\r\n    \u0026quot;uriFormat\u0026quot;: \u0026quot;%s/swagger\u0026quot;\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eASP.NET Core doesn\u0026rsquo;t include a logging provider for writing logs to files. To write logs to files from an ASP.NET Core app, consider using a third-party logging provider.\n\u003ca href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-6.0\" target=\"_blank\" rel=\"noopener\"\u003ehttps://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-6.0\u003c/a\u003e\n.NET Standard 2.0 之後內建沒有 ConfigurationManager ，需要額外安裝\n\u003ccode\u003edotnet add package System.Configuration.ConfigurationManager --version 6.0.0\u003c/code\u003e\n\u003ca href=\"https://stackoverflow.com/questions/46360716/cant-use-system-configuration-configuration-manager-in-a-net-standard2-0-libra\" target=\"_blank\" rel=\"noopener\"\u003ehttps://stackoverflow.com/questions/46360716/cant-use-system-configuration-configuration-manager-in-a-net-standard2-0-libra\u003c/a\u003e\u003c/p\u003e","tags":null,"title":"[.NET] .NET 6 Web API 專案"},{"categories":null,"contents":"Reference Best practices in cloud applications\n","date":"July 11, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/web/web-api-design/","summary":"\u003ch2 id=\"reference\"\u003eReference\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/azure/architecture/best-practices/index-best-practices\" target=\"_blank\" rel=\"noopener\"\u003eBest practices in cloud applications\u003c/a\u003e\u003c/p\u003e","tags":null,"title":"[Web] API Design"},{"categories":null,"contents":"網址列參數洩漏風險 目前網頁後端資源存取大多以 RESTful Api 開發， REST 標準下 API 的設計需符合冪等性(idempotent)， SSL 連線連接 TCP 層與 HTTP 層，因此透過 HTTPS 傳輸的網頁，網址進入 TCP 層之後是被加密的， 即使封包被截取也只能看見要傳送的目標主機 那麼敏感性資料可以透過 GET 參數傳送嗎？\n如果將機敏性資料夾帶於網址列當中會有洩漏的安全性風險，諸如：\n被 Shoulder surfers 竊取。(你的螢幕被偷看) 隨著頁面列印被印出。 使用者將連結加入書籤。 儲存在瀏覽器瀏覽歷史紀錄。 被記錄在 Web Server 的 Log，而 Log 本身可能不安全。 隱藏 RESTful GET 參數 因此避免這些資料外洩的可能，根本的做法就是讓機敏性資料從網址列消失，最好的做法是依據 OWASP 的建議把 參數夾帶在 Header 裡面，其他手段整理：\n將機敏性資料加密，但加密也會破壞 API RESTful 特性，在後端需要先解密無法直接對應回物件。 以 POST 的一部份傳輸(透過 HTTPS)，但會直接破壞 API 的 RESTful 特性。 根據 OWASP REST Security Cheat Sheet，應該把敏感性參數夾帶在 GET 請求的 HTTP Header 裡面透過 HTTPS 傳輸。 P.S. OWASP 的 Cheat Sheet 可看出並非所有資料都要不能出現在網址列，只有機敏性資料才需要考慮從網址列移除。`\nReference stackoverflow - Are HTTPS URLs encrypted? stackoverflow - Should sensitive data ever be passed in the query string? OWASP - REST Security Cheat Sheet ","date":"July 11, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/web/security-get/","summary":"\u003ch2 id=\"網址列參數洩漏風險\"\u003e網址列參數洩漏風險\u003c/h2\u003e\n\u003cp\u003e目前網頁後端資源存取大多以 RESTful Api 開發，\nREST 標準下 API 的設計需符合冪等性(idempotent)，\nSSL 連線連接 TCP 層與 HTTP 層，因此透過 HTTPS 傳輸的網頁，網址進入 TCP 層之後是被加密的，\n即使封包被截取也只能看見要傳送的目標主機\n那麼敏感性資料可以透過 GET 參數傳送嗎？\u003c/p\u003e\n\u003cp\u003e如果將機敏性資料夾帶於網址列當中會有洩漏的安全性風險，諸如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e被 Shoulder surfers 竊取。(你的螢幕被偷看)\u003c/li\u003e\n\u003cli\u003e隨著頁面列印被印出。\u003c/li\u003e\n\u003cli\u003e使用者將連結加入書籤。\u003c/li\u003e\n\u003cli\u003e儲存在瀏覽器瀏覽歷史紀錄。\u003c/li\u003e\n\u003cli\u003e被記錄在 Web Server 的 Log，而 Log 本身可能不安全。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"隱藏-restful-get-參數\"\u003e隱藏 RESTful GET 參數\u003c/h2\u003e\n\u003cp\u003e因此避免這些資料外洩的可能，根本的做法就是讓機敏性資料從網址列消失，最好的做法是依據 OWASP 的建議把 參數夾帶在 Header 裡面，其他手段整理：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e將機敏性資料加密，但加密也\u003cstrong\u003e會破壞 API RESTful 特性\u003c/strong\u003e，在後端需要先解密無法直接對應回物件。\u003c/li\u003e\n\u003cli\u003e以 POST 的一部份傳輸(透過 HTTPS)，但\u003cstrong\u003e會直接破壞 API 的 RESTful 特性\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e根據 \u003ca href=\"https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html\" target=\"_blank\" rel=\"noopener\"\u003eOWASP REST Security Cheat Sheet\u003c/a\u003e，應該把敏感性參數夾帶在 GET 請求的 HTTP Header 裡面透過 HTTPS 傳輸。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eP.S. OWASP 的 Cheat Sheet 可看出並非所有資料都要不能出現在網址列，只有機敏性資料才需要考慮從網址列移除。`\u003c/p\u003e","tags":null,"title":"[Web] RESTful 敏感性 GET 參數"},{"categories":null,"contents":"先建立一個練習表格：\nCREATE TABLE Department\r(\rid SERIAL PRIMARY KEY, name VARCHAR NOT NULL\r);\rCREATE TABLE Employee\r(\rid SERIAL PRIMARY KEY, name VARCHAR NOT NULL, salary INT, dep_id INT, );\rINSERT INTO Employee(name, salary, dep_id) VALUES ('Mandy', 45000, 2);\rINSERT INTO Employee(name, salary, dep_id) VALUES ('Emily', 43000, 1);\rINSERT INTO Employee(name, salary, dep_id) VALUES ('Sylvia', 26000, 2);\rINSERT INTO Employee(name, salary, dep_id) VALUES ('Eva', 48000, 3);\rINSERT INTO Employee(name, salary, dep_id) VALUES ('Sandra', 33000, 3);\rINSERT INTO Employee(name, salary, dep_id) VALUES ('Lily', 28000, 2);\rINSERT INTO Employee(name, salary, dep_id) VALUES ('April', 50000, 1);\rINSERT INTO Employee(name, salary, dep_id) VALUES ('Cindy', 43000, 1);\rINSERT INTO Employee(name, salary, dep_id) VALUES ('Kay', 40000, 3);\rINSERT INTO Department(name) VALUES ('IT');\rINSERT INTO Department(name) VALUES ('RD');\rINSERT INTO Department(name) VALUES ('QA');\r資料排序 直接用 ORDER BY 無法得到秩(排名)\nSELECT ID, NAME, SALARY FROM EMPLOYEE ORDER BY SALARY DESC\rid\tname\tsalary 4\t\u0026#34;April\u0026#34;\t50000 3\t\u0026#34;Eva\u0026#34;\t48000 2\t\u0026#34;Mandy\u0026#34;\t45000 7\t\u0026#34;Cindy\u0026#34;\t43000 1\t\u0026#34;Emily\u0026#34;\t43000 9\t\u0026#34;Kay\u0026#34;\t40000 6\t\u0026#34;Sandra\u0026#34;\t33000 8\t\u0026#34;Lily\u0026#34;\t28000 5\t\u0026#34;Sylvia\u0026#34;\t26000 秩函式 ROW_NUMBER ROW_NUMBER 按照資料行號排序，同一個值可能會給不同數字\nSELECT ROW_NUMBER() OVER (ORDER BY SALARY DESC) RANK, ID, NAME, SALARY FROM EMPLOYEE\rrank\tid\tname\tsalary 1\t4\t\u0026#34;April\u0026#34;\t50000 2\t3\t\u0026#34;Eva\u0026#34;\t48000 3\t2\t\u0026#34;Mandy\u0026#34;\t45000 4\t7\t\u0026#34;Cindy\u0026#34;\t43000 5\t1\t\u0026#34;Emily\u0026#34;\t43000 6\t9\t\u0026#34;Kay\u0026#34;\t40000 7\t6\t\u0026#34;Sandra\u0026#34;\t33000 8\t8\t\u0026#34;Lily\u0026#34;\t28000 9\t5\t\u0026#34;Sylvia\u0026#34;\t26000 RANK 連號之後跳號\nSELECT RANK() OVER (ORDER BY SALARY DESC) RANK, ID, NAME, SALARY FROM EMPLOYEE\rrank\tid\tname\tsalary 1\t4\t\u0026#34;April\u0026#34;\t50000 2\t3\t\u0026#34;Eva\u0026#34;\t48000 3\t2\t\u0026#34;Mandy\u0026#34;\t45000 4\t7\t\u0026#34;Cindy\u0026#34;\t43000 4\t1\t\u0026#34;Emily\u0026#34;\t43000 6\t9\t\u0026#34;Kay\u0026#34;\t40000 7\t6\t\u0026#34;Sandra\u0026#34;\t33000 8\t8\t\u0026#34;Lily\u0026#34;\t28000 9\t5\t\u0026#34;Sylvia\u0026#34;\t26000 DENSE_RANK 連號之後不跳號\nSELECT DENSE_RANK() OVER (ORDER BY SALARY DESC) RANK, ID, NAME, SALARY FROM EMPLOYEE\rrank\tid\tname\tsalary 1\t4\t\u0026#34;April\u0026#34;\t50000 2\t3\t\u0026#34;Eva\u0026#34;\t48000 3\t2\t\u0026#34;Mandy\u0026#34;\t45000 4\t7\t\u0026#34;Cindy\u0026#34;\t43000 4\t1\t\u0026#34;Emily\u0026#34;\t43000 5\t9\t\u0026#34;Kay\u0026#34;\t40000 6\t6\t\u0026#34;Sandra\u0026#34;\t33000 7\t8\t\u0026#34;Lily\u0026#34;\t28000 8\t5\t\u0026#34;Sylvia\u0026#34;\t26000 NTILE 排序然後分成N組\nSELECT NTILE(3) OVER (ORDER BY SALARY DESC) RANK, ID, NAME, SALARY FROM EMPLOYEE rank\tid\tname\tsalary 1\t4\t\u0026#34;April\u0026#34;\t50000 1\t3\t\u0026#34;Eva\u0026#34;\t48000 1\t2\t\u0026#34;Mandy\u0026#34;\t45000 2\t7\t\u0026#34;Cindy\u0026#34;\t43000 2\t1\t\u0026#34;Emily\u0026#34;\t43000 2\t9\t\u0026#34;Kay\u0026#34;\t40000 3\t6\t\u0026#34;Sandra\u0026#34;\t33000 3\t8\t\u0026#34;Lily\u0026#34;\t28000 3\t5\t\u0026#34;Sylvia\u0026#34;\t26000 分組排名(Partition By) SELECT RANK() OVER (PARTITION BY A.DEP_ID ORDER BY A.SALARY) RANK, B.NAME DEP_NAME, A.NAME, A.SALARY FROM EMPLOYEE A\rLEFT JOIN DEPARTMENT B ON A.DEP_ID=B.ID\rrank\tdep\tname\tsalary 1\t\u0026#34;IT\u0026#34;\t\u0026#34;Emily\u0026#34;\t43000 1\t\u0026#34;IT\u0026#34;\t\u0026#34;Cindy\u0026#34;\t43000 3\t\u0026#34;IT\u0026#34;\t\u0026#34;April\u0026#34;\t50000 1\t\u0026#34;RD\u0026#34;\t\u0026#34;Sylvia\u0026#34;\t26000 2\t\u0026#34;RD\u0026#34;\t\u0026#34;Lily\u0026#34;\t28000 3\t\u0026#34;RD\u0026#34;\t\u0026#34;Mandy\u0026#34;\t45000 1\t\u0026#34;QA\u0026#34;\t\u0026#34;Sandra\u0026#34;\t33000 2\t\u0026#34;QA\u0026#34;\t\u0026#34;Kay\u0026#34;\t40000 3\t\u0026#34;QA\u0026#34;\t\u0026#34;Eva\u0026#34;\t48000 Reference sqlshack-Overview Of Sql Rank Functions ","date":"June 17, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/database/sql-ranking/","summary":"\u003cp\u003e先建立一個練習表格：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eCREATE TABLE Department\r\n(\r\n  id SERIAL PRIMARY KEY, \r\n  name VARCHAR NOT NULL\r\n);\r\nCREATE TABLE Employee\r\n(\r\n  id SERIAL PRIMARY KEY, \r\n  name VARCHAR NOT NULL, \r\n  salary INT, \r\n  dep_id INT, \r\n);\r\nINSERT INTO Employee(name, salary, dep_id) VALUES ('Mandy', 45000, 2);\r\nINSERT INTO Employee(name, salary, dep_id) VALUES ('Emily', 43000, 1);\r\nINSERT INTO Employee(name, salary, dep_id) VALUES ('Sylvia', 26000, 2);\r\nINSERT INTO Employee(name, salary, dep_id) VALUES ('Eva', 48000, 3);\r\nINSERT INTO Employee(name, salary, dep_id) VALUES ('Sandra', 33000, 3);\r\nINSERT INTO Employee(name, salary, dep_id) VALUES ('Lily', 28000, 2);\r\nINSERT INTO Employee(name, salary, dep_id) VALUES ('April', 50000, 1);\r\nINSERT INTO Employee(name, salary, dep_id) VALUES ('Cindy', 43000, 1);\r\nINSERT INTO Employee(name, salary, dep_id) VALUES ('Kay', 40000, 3);\r\n\r\nINSERT INTO Department(name) VALUES ('IT');\r\nINSERT INTO Department(name) VALUES ('RD');\r\nINSERT INTO Department(name) VALUES ('QA');\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"資料排序\"\u003e資料排序\u003c/h2\u003e\n\u003cp\u003e直接用 ORDER BY 無法得到秩(排名)\u003c/p\u003e","tags":null,"title":"[SQL] Ranking"},{"categories":null,"contents":"一段神奇的語法，可以指定對舊資料、新的資料分別進行不同的動作(通常是更新、新增)， 不指定的話預設是 BY TARGET， 動作目標都是 TARGET。\n在更新清單的時候特別好用。\nMERGE INTO TABLE1 DEST -- 目標表格\rUSING( SELECT :K1 K1, :K2 K2, :K3 K3, :K4 K4, FROM DUAL) SRC\rON( DEST.K1 = SRC.K1 AND DEST.K2 = SRC.K2 AND DEST.K4 = SRC.K4 )\r-- TARGET 有，SOURCE 沒有，更新 TARGET 裡面的紀錄\rWHEN MATCHED THEN\rUPDATE SET F1 = SRC.F1, F2 = SRC.F2,\r-- TARGET 沒有，SOURCE 有，SOURCE 新增到 TARGET\rWHEN NOT MATCHED THEN\rINSERT ( K1, K2, K4, K3, F1, F2 ) VALUES ( :K1, :K2, :K4, :K3, :F1, :F2) Reference [StackOverflow] Performing MERGE with Dapper.net ","date":"June 14, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/database/sql-merge/","summary":"\u003cp\u003e一段神奇的語法，可以指定對舊資料、新的資料分別進行不同的動作(通常是更新、新增)，\n不指定的話預設是 BY TARGET，\n動作目標都是 TARGET。\u003c/p\u003e\n\u003cp\u003e在更新清單的時候特別好用。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eMERGE INTO TABLE1 DEST -- 目標表格\r\n  USING( SELECT :K1 K1, :K2 K2, :K3 K3, :K4 K4, FROM DUAL) SRC\r\n  ON( DEST.K1 = SRC.K1 AND DEST.K2 = SRC.K2 AND DEST.K4 = SRC.K4 )\r\n-- TARGET 有，SOURCE 沒有，更新 TARGET 裡面的紀錄\r\nWHEN MATCHED THEN\r\n  UPDATE SET F1 = SRC.F1, F2 = SRC.F2,\r\n-- TARGET 沒有，SOURCE 有，SOURCE 新增到 TARGET\r\nWHEN NOT MATCHED THEN\r\n  INSERT ( K1, K2, K4, K3, F1, F2 ) \r\n  VALUES ( :K1, :K2, :K4, :K3, :F1, :F2) \r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"reference\"\u003eReference\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://stackoverflow.com/questions/43738324/performing-merge-with-dapper-net\" target=\"_blank\" rel=\"noopener\"\u003e[StackOverflow] Performing MERGE with Dapper.net\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[SQL] MERGE"},{"categories":null,"contents":" DockerHub Docker文件 K8S ","date":"April 25, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/container/basic-resource/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\"\u003eDockerHub\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.docker.com/\" target=\"_blank\" rel=\"noopener\"\u003eDocker文件\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener\"\u003eK8S\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[Container] 學習資源"},{"categories":null,"contents":"執行容器\ndocker run [image] [overwrite defalut commain]\r列出正在執行的容器， \u0026ndash;all 可以列出曾經執行過的容器\ndocker ps [--all]\rdocker run\rdocker ps --all\rdocker create\rdocker start (what different from docker run?)\rdocker system prune\rdocker logs\rdocker stop (send sigterm) 10s then docker kill\rdocker kill\rdocker build -t \u0026lt;dockerid\u0026gt;/\u0026lt;project\u0026gt;:latest .\rdocker exec -it \u0026lt;containerId\u0026gt; /bin/bash (i, t stands for?)\r# execute new command\rbuild context! port mapping 是為了處理 into docker，docker 出來從來沒有被限制\nDocker Compose 所有的 docker-compose 都要在 yml 資料夾下作用 可啟動多個 Contailner 並連接 Container 之間的網路 docker-compose.yml docker-compose up docker-compose up -d # start container in the background docker-compose up \u0026ndash;build docker-compose down docker-compose ps (需要 yml ，因此要在 yml 所在的資料夾下才能下) network service\nrestart policy \u0026ldquo;no\u0026rdquo; (no 在 yaml 裡面代表 false，所以要傳入帶括號的 \u0026ldquo;no\u0026rdquo;) always (reuse old container，例如 web server) on-failure (用於例如完成任務就退出的 worker container) unless-stopped pull request = merge ??? Travis CI Merge PR ?\ndevelopment server configuration: use \u0026lsquo;Dockerfile.dev\u0026rsquo; only for development and specify filename by -f In front end development, use Docker Volumes to let hot reload\ndocker run \\\r-p 3000:3000 \\\r-v [bookmark] \\ # bookmark volumes, means dont map this dir -v[localDir]:[containerDir] # with :\r用 docker-compose 管理這些(build, port, volumes) development 用 docker-compose 的話 production 用什麼？\nDockerfile 留下 COPY . . 可降低對 docker compose 的耦合度，另作他用 docker attatch \u0026ndash; attatch to the container terminal(stdin/stdout/strerr) of primary proccess npm run test 會跑在不同的 process，導致無法 attatch 到所有的 stdin/stdout/stderr npm \u0026lt;= attatch to this primary process sart.js \u0026lt;= real run test, second process start by npm !!there are no workaround for npm run test of react project\nmulti-step build process FROM xxx as COPY \u0026ndash;from= /app/build \u0026hellip;distination\nTravis CI/circleci ? 只能有一個 FROM 沒有加 as xxx Travis CI，可推到 AWS 上 GitHub App?\nbefore_install script\nelastic beanstalk? easy to run single container elastic beanstalk 內建 load balancer automatically scale up everything S3 bucket? 放 zip file 的地方 IAM manage api key\n","date":"April 25, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/container/docker-command/","summary":"\u003cp\u003e執行容器\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker run [image] [overwrite defalut commain]\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e列出正在執行的容器， \u0026ndash;all 可以列出曾經執行過的容器\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edocker ps [--all]\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003edocker run\r\ndocker ps --all\r\ndocker create\r\ndocker start (what different from docker run?)\r\ndocker system prune\r\ndocker logs\r\ndocker stop   (send sigterm) 10s then docker kill\r\ndocker kill\r\ndocker build -t \u0026lt;dockerid\u0026gt;/\u0026lt;project\u0026gt;:latest .\r\n\r\ndocker exec -it \u0026lt;containerId\u0026gt; /bin/bash (i, t stands for?)\r\n# execute new command\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebuild context!\nport mapping 是為了處理 into docker，docker 出來從來沒有被限制\u003c/p\u003e","tags":null,"title":"[Docker] Docker Basic Command"},{"categories":null,"contents":"建立一個暫存表 testCTE，並暫存查詢語句(所有資料)的結果 MSSQL CTE 名稱前不需加上 RECURSEIVE 關鍵字，必須使用 UNION ALL PostgreSQL：CTE 名稱前需加上 RECURSIVE 關鍵字，可用 UNION 或 UNION ALL\nWITH CTE (id, name, parentId, lvl) AS\r(\r-- 取得第一層的資料(Anchor member)(假設沒有 parentId 的是第一層)\rSELECT id, name parentId, 0 AS lvl FROM menus WHERE parentId IS NULL\rUNION ALL\r-- 遞迴取得 Recursive member\r(\rSELECT A.id, A.name, A.parentId, B.lvl + 1 AS lvl FROM menus A\rINNER JOIN CTE B on A.parentIdi = B.d\r)\r)\rSELECT * FROM CTE WHERE id=1 ORDER BY LEVEL\rReference [StackOverflow] How to create a query from a menu tree using RECURSIVE CTE? [SQL] 使用 CTE 遞迴查詢 (PostgreSQL / MSSQL) ","date":"April 25, 2022","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/database/sql-cte/","summary":"\u003cp\u003e建立一個暫存表 testCTE，並暫存查詢語句(所有資料)的結果\nMSSQL CTE 名稱前不需加上 RECURSEIVE 關鍵字，必須使用 UNION ALL\nPostgreSQL：CTE 名稱前需加上 RECURSIVE 關鍵字，可用 UNION 或 UNION ALL\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eWITH CTE (id, name, parentId, lvl) AS\r\n(\r\n  -- 取得第一層的資料(Anchor member)(假設沒有 parentId 的是第一層)\r\n  SELECT id, name parentId, 0 AS lvl FROM menus WHERE parentId IS NULL\r\n  UNION ALL\r\n  -- 遞迴取得 Recursive member\r\n  (\r\n    SELECT A.id, A.name, A.parentId, B.lvl + 1 AS lvl FROM menus A\r\n    INNER JOIN CTE B on A.parentIdi = B.d\r\n  )\r\n)\r\nSELECT * FROM CTE WHERE id=1 ORDER BY LEVEL\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"reference\"\u003eReference\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://stackoverflow.com/questions/32681915/how-to-create-a-query-from-a-menu-tree-using-recursive-cte\" target=\"_blank\" rel=\"noopener\"\u003e[StackOverflow] How to create a query from a menu tree using RECURSIVE CTE?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.gss.com.tw/blog/sql-cte-recursive-query-postgresql-mssql\" target=\"_blank\" rel=\"noopener\"\u003e[SQL] 使用 CTE 遞迴查詢 (PostgreSQL / MSSQL)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[SQL] 用 CTE (Common Table Expression) 達成遞迴查詢，建立 MenuTree"},{"categories":["DevOps"],"contents":"環境 硬體部分官方提到: RAM \u0026gt; 256NB，最好 2GB，空間留至少 10GB 放置 Docker 映像檔。 環境部分需要安裝 Java (8 或 11) 和 Docker\n安裝 Docker # 卸載舊的 docker\rsudo apt-get remove -y docker docker-engine docker.io containerd runc\r# 安裝必要的套件\r# apt-transport-https 讓套件管理程式可以透過 https 協定使用 repo\rsudo apt-get update\rsudo apt-get install -y \\\rapt-transport-https \\\rca-certificates \\\rcurl \\\rgnupg \\\rlsb-release\r# 添加 Docker 官方 GPG key\rcurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\r# 設置 stable 版本的 docker repository\recho \\\r\u0026quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\\r$(lsb_release -cs) stable\u0026quot; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null\r# 安裝 Docker Engine\rsudo apt-get update\rsudo apt-get install -y docker-ce docker-ce-cli containerd.io\r# 下載測試 image 並執行，預期會得到輸出然後 container 就會結束\rsudo docker run hello-world\r執行 Jenkins 接著執行 Jenkins image，取得首次登入密碼\n# 拉最新的 docker image\rdocker pull jenkins/jenkins\r# 建立 Jenkins 在 host 使用的目錄 /data/jenkins\rsudo mkdir -p /data/jenkins\rsudo chown -R $USER:$GROUP /data\r# 執行 Jenkins\rdocker run \\\r--name jenkins \\\r-d --restart always \\\r-p 8080:8080 -p 50000:50000 \\\r-v /data/jenkins:/var/jenkins_home \\\rjenkins/jenkins\r# 取得初始登入密碼\rcat /data/jenkins/secrets/initialAdminPassword\r設定 打開 http://localhost:8080，輸入剛剛取得的密碼 接著選擇要安裝的 Plugin()，先從安裝建議的開始吧\n建立另一個管理員帳號\n指定這台機器的 URL，我這裡是 https://jenkins.tigernaxo.com 然後就完成拉！\nReference https://www.jenkins.io/doc/pipeline/tour/getting-started/ https://tso-liang-wu.gitbook.io/learn-ansible-and-jenkins-in-30-days/jenkins/jenkins/jenkins-scm-and-trigger\n","date":"October 18, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/devops/pipeline/01_install_jenkins/","summary":"\u003ch1 id=\"環境\"\u003e環境\u003c/h1\u003e\n\u003cp\u003e硬體部分官方提到: RAM \u0026gt; 256NB，最好 2GB，空間留至少 10GB 放置 Docker 映像檔。\n環境部分需要安裝 Java (8 或 11) 和 Docker\u003c/p\u003e\n\u003ch1 id=\"安裝-docker\"\u003e安裝 Docker\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 卸載舊的 docker\r\nsudo apt-get remove -y docker docker-engine docker.io containerd runc\r\n\r\n# 安裝必要的套件\r\n# apt-transport-https 讓套件管理程式可以透過 https 協定使用 repo\r\nsudo apt-get update\r\nsudo apt-get install -y \\\r\n    apt-transport-https \\\r\n    ca-certificates \\\r\n    curl \\\r\n    gnupg \\\r\n    lsb-release\r\n\r\n# 添加 Docker 官方 GPG key\r\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\r\n\r\n# 設置 stable 版本的 docker repository\r\necho \\\r\n  \u0026quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\\r\n  $(lsb_release -cs) stable\u0026quot; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null\r\n  \r\n# 安裝 Docker Engine\r\nsudo apt-get update\r\nsudo apt-get install -y docker-ce docker-ce-cli containerd.io\r\n\r\n# 下載測試 image 並執行，預期會得到輸出然後 container 就會結束\r\nsudo docker run hello-world\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"執行-jenkins\"\u003e執行 Jenkins\u003c/h1\u003e\n\u003cp\u003e接著執行 Jenkins image，取得首次登入密碼\u003c/p\u003e","tags":["Jenkins","Ubuntu","CI/CD","Docker"],"title":"[DevOps] CI/CD-01 安裝 Jenkins"},{"categories":null,"contents":"弱點掃描時常使用 owasp top 10 作為報告， 然而 owasp 軟體一年要價不菲，委外掃一次也是非常貴， 使用免費的 SonarQube 將弱點掃描整合到 CI/CD 階段， 要交付前再花錢委外掃一次似乎是個折衷的作法，避免一次檢測出來的弱點過多改動過大。\nSonarQube 分為兩個部分 SonarQube Server、Scanner (Client 端程式)。 Scanner 負責進行掃描並將結果上傳 Server， 而 Server 作為負責處理和儲存分析報告的 compute engine 會分析上傳的結果， 並提供 Web 使用者介面、搜尋功能，因此分析完成後就可以直接在 Web 上查看報告， Scanner 除了能夠在 locale 端使用，還能直接整合到 CI/CD Server 上進行程式碼品質掃描。 雖說可以拿 localhost 直接作為 Server 使用， 這裡還是紀錄如何在虛擬機器上實際安裝 SonarQube， 以後在實際機器上安裝就可以作為參考，\n準備 Linux Server 硬體 個人使用或小規模的團隊在一台機器上安裝就足夠使用了， 如果需要架設提供大量服務的伺服器，官網也提供 Cluster 的安裝方式方便做 Loading Balance。\n這裡紀錄在一台 Ubuntu 20.04 上架設。 關於 Linux 安裝過程在這裡不加贅述， 官方提到硬體有幾個注意事項，對現代的硬體來說其實都還好，比較要注意的是硬碟空間：\nRAM 至少要 2G；free RAM 至少要 1G (所以用 Windows server 就要準備大很多喔)。 上傳報告需要一定的空間，因次對硬碟的空間與效能有一定的要求，不夠的話容易太慢。 server side 不支援 32-bit 作業系統；但 Scanner 可以支援 32-bit systems。 安裝 OpenJDK 11 sudo apt update\rsudo apt upgrade\rsudo apt install openjdk-11-jdk\r# 確認 java 版本\rjava --version\r然後在 .bashrc 裡面把 Java 添加到 PATH 變數上。\n安裝 PostgreSQL 13 #添加 apt-key\rwget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -\recho \u0026quot;deb http://apt.postgresql.org/pub/repos/apt/ `lsb_release -cs`-pgdg main\u0026quot; |sudo tee /etc/apt/sources.list.d/pgdg.list\rsudo apt update\r# 安裝資料庫\rsudo apt install postgresql-13 postgresql-client-13\rsystemctl status postgresql.service #查看 postgresql 服務狀態\r設置密碼\n$ sudo -u postgres psql\r# create database sonarqube; -- 建立資料庫\rCREATE DATABASE\r# create user sonarqube with encrypted password 'mypass'; -- 建立資料庫使用者和密碼\rCREATE ROLE\r# grant all privileges on database sonarqube to sonarqube; -- 設定資料庫權限\rGRANT\r# EXIT;\r如果資料庫和 SonarQube Server 不在同一台機器上， 必須透過網路連線則要設定監聽、白名單設定檔：\n# /etc/postgresql/13/main/postgresql.conf\r# 監聽所有位址連線\rlisten_addresses = '*'\r# 或是只監聽特定 IP 的連線\rlisten_addresses = '192.168.10.11'\r# /etc/postgresql/13/main/pg_hba.conf\r# 所有連線都視為白名單\rhost all all 0.0.0.0/0 md5\r# 或是只將特定的 IP 加為白名單\rhost all all 10.10.10.0/24 md5\r調整 Linux 限制 SonarQube 對於 Linux 作為 Server 有下面的要求：\nvm.max_map_count \u0026gt;= 524288 fs.file-max \u0026gt;= 131072 SonarQube user 可開啟的 file descriptors \u0026gt;= 131072 SonarQube user 可開啟的 threads \u0026gt;= 8192 首先查看 Ubuntu 20.04 的預設限制，發現只需要調整 vm.max_map_count 和 ulimit -n\nsysctl vm.max_map_count # 65530\rsysctl fs.file-max # 9223372036854775807\rulimit -n # 1024\rulimit -u #15392\r進行調整，附上其他參數的調整方法：\nsudo sysctl -w vm.max_map_count=524288\r#sudo sysctl -w fs.file-max=131072\r#ulimit -n 131072\rulimit -u 8192\r上面的調整都是只對使用者登入階段暫時發生作用， 因此另外新增 conf 文件為使用者 sonarqube 預設解除限制：\n# /etc/sysctl.d/99-sonarqube.conf\rsonarqube - nofile 131072\rsonarqube - nproc 8192\r安裝 SonarQube Server 9.0.1 下載 Server 端程式 先從這裡找到下載連結， 我下載的是 Community 最新版本。\n# 下載\rwget https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-9.0.1.46107.zip\r# 解壓縮\runzip sonarqube-9.0.1.46107.zip\r設置 修改檔案 $SONARQUBE-HOME/conf/sonar.properties， 設定 PostgreSQL 資料庫的連線， 使用者名稱為 sonarqube，密碼 mypass， 使用的資料庫 sonarqube\n# 資料庫設置\rsonar.jdbc.username=sonarqube\rsonar.jdbc.password=mypass\rsonar.jdbc.url=jdbc:postgresql://localhost/sonarqube\r# 設置 Elasticsearch data 存放位址\rsonar.path.data=/var/sonarqube/data\rsonar.path.temp=/var/sonarqube/temp\r設定密碼 嘗試啟動 SonarQuebe Server\nbin/linux-x86-64/sonar.sh start\r因為我是用連接埠轉送到虛擬機的9000，所以我打開的網址是 http://127.0.0.1:8090， 如果在本地機器上執行就是打開 http://localhost:9000， 開啟後一開始會看到 SonarQube is starting， 需要等待一下下就會出現登入畫面， 用 admin/admin 登入後會馬上要求重設密碼。\n設置開機啟動 新增一個 service 檔案 /etc/systemd/system/sonarqube.service\n[Unit]\rDescription=SonarQube Server\r[Service]\rType=simple\rExecStart=/bin/bash /pkg/sonarqube-9.0.1.46107/bin/linux-x86-64/sonar.sh start\rExecStop=/bin/bash /pkg/sonarqube-9.0.1.46107/bin/linux-x86-64/sonar.sh stop\rExecReload=/bin/bash /pkg/sonarqube-9.0.1.46107/bin/linux-x86-64/sonar.sh restart\rRestart=always\rLimitNOFILE=131072\rLimitNPROC=8192\r[Install]\rWantedBy=multi-user.target\r設置開機啟動\nsudo systemctl enable sonarqube.service\r安裝 Scanner 還沒有將 SonarQube 整合進 CI/CD 流程的需求之前， 可以採取的方式是開發進行到一個階段在程式開發機掃描程式碼， 再將結果上傳到 SonarQube Server， 因為我的 .NET Core 開發環境是 Visual Studio 2019， 所以 Scanner 安裝於 Windows 10 上。\nP.S.因為這裡的情境是在開發機上做分析， 因此前提假設機器上已經安裝相應的 dotnet sdk， 我是裝 3.1。\n安裝 dotnet sonarscanner dotnet tool install --global dotnet-sonarscanner\r安裝 JRE 11 到 Java 網站上抓 JRE 11安裝，這裡一樣要確認系統環境變數新增， 新增 JAVA_HOME 系統變數，值為 C:\\Program Files\\Java\\jdk-11.0.12\n進行分析 從 SonarQube Web 介面新增一個專案，分析方式選擇 Locally： 建立一個分析專案，上面是專案名稱， 下面填入跟其他專案不重複的 project key (這裡我還是用專案名稱)。 設置一組 Token 提供 local 端分析完畢後可以上傳報告： 專案分析設置，設置 .NET、.NET Core， 設置玩畢下面會自動出現程式碼， 第一個區塊是要求先安裝剛剛安裝過的工具 dotnet-sonarqube 所以不需要理會， 第二個區塊共有三行程式碼， 把它複製起來貼到檔案 sonarqube.bat，然後把檔案放在要分析的專案資料夾底下。\ndotnet sonarscanner begin /k:\u0026quot;EVT-api\u0026quot; /d:sonar.host.url=\u0026quot;http://localhost:6080\u0026quot; /d:sonar.login=\u0026quot;05759efdbea31b9abe4e5cba171841d88f2dc689\u0026quot;\rdotnet build\rdotnet sonarscanner end /d:sonar.login=\u0026quot;05759efdbea31b9abe4e5cba171841d88f2dc689\u0026quot;\r最後打開小黑窗，切換到專案所在的工作目錄，執行這個 bat 檔案， 接個 scanner 就會對程式碼進行分析、將結果上傳 SonarQube Server。\nsonarqube.bat\r執行開始到完成大概長這樣： 檢視結果 點選專案會呈現總覽頁面，就可以知道問題出在哪然後點選在意的看。 如果需要客製化的報表， 可以使用 API 抓取資料再將資料用自己的方式呈現， 在此暫不詳述。\n版本控制 再進行一次分析，會把新的程式碼有那些問題列出來，舊的程式碼有那些問題未改善\n不需要執行的事項 Adding the JDBC Driver: 因為是使用 Postgresql，用內建的就好。 Referecne SonarQube SonarQube GitHub ","date":"September 22, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/devops/sonarqube_netcore31/","summary":"\u003cp\u003e弱點掃描時常使用 owasp top 10 作為報告，\n然而 owasp 軟體一年要價不菲，委外掃一次也是非常貴，\n使用免費的 SonarQube 將弱點掃描整合到 CI/CD 階段，\n要交付前再花錢委外掃一次似乎是個折衷的作法，避免一次檢測出來的弱點過多改動過大。\u003c/p\u003e\n\u003cp\u003eSonarQube 分為兩個部分 SonarQube Server、Scanner (Client 端程式)。\nScanner 負責進行掃描並將結果上傳 Server，\n而 Server 作為負責處理和儲存分析報告的 compute engine 會分析上傳的結果，\n並提供 Web 使用者介面、搜尋功能，因此分析完成後就可以直接在 Web 上查看報告，\nScanner 除了能夠在 locale 端使用，還能直接整合到 CI/CD Server 上進行程式碼品質掃描。\n雖說可以拿 localhost 直接作為 Server 使用，\n這裡還是紀錄如何在虛擬機器上實際安裝 SonarQube，\n以後在實際機器上安裝就可以作為參考，\u003c/p\u003e\n\u003ch1 id=\"準備-linux-server\"\u003e準備 Linux Server\u003c/h1\u003e\n\u003ch2 id=\"硬體\"\u003e硬體\u003c/h2\u003e\n\u003cp\u003e個人使用或小規模的團隊在一台機器上安裝就足夠使用了，\n如果需要架設提供大量服務的伺服器，官網也提供 Cluster 的安裝方式方便做 Loading Balance。\u003c/p\u003e\n\u003cp\u003e這裡紀錄在一台 Ubuntu 20.04 上架設。\n關於 Linux 安裝過程在這裡不加贅述，\n官方提到硬體有幾個注意事項，對現代的硬體來說其實都還好，比較要注意的是硬碟空間：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRAM 至少要 2G；free RAM 至少要 1G (所以用 Windows server 就要準備大很多喔)。\u003c/li\u003e\n\u003cli\u003e上傳報告需要一定的空間，因次對硬碟的空間與效能有一定的要求，不夠的話容易太慢。\u003c/li\u003e\n\u003cli\u003eserver side 不支援 32-bit 作業系統；但 Scanner 可以支援 32-bit systems。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"安裝-openjdk-11\"\u003e安裝 OpenJDK 11\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003esudo apt update\r\nsudo apt upgrade\r\nsudo apt install openjdk-11-jdk\r\n# 確認 java 版本\r\njava --version\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然後在 \u003ccode\u003e.bashrc\u003c/code\u003e 裡面把 Java 添加到 PATH 變數上。\u003c/p\u003e","tags":null,"title":"[Security] 利用免費開源資安檢測軟體 SonarQube 檢測 .NET Core 程式碼"},{"categories":null,"contents":"Web 在顯示姓名的時候常會遇到中文難字無法顯示， 此時開發者在本機端如果有安裝造字檔 EUDC.TTE 就可以轉為 woff、woff2、ttf 讓網頁正確顯示難字。 過程需要字型工具軟體 FontForge， 步驟如下：\n拿到造字檔 EUDC.TTE 用 cmd 打開 regedit (win10 搜尋圖示點下後，輸入 cmd，出現小黑窗後再輸入 regedit) 找到機碼 HKEY_CURRENT_USER -\u0026gt; EUDC -\u0026gt; 950 資料夾下的 SystemDefaultEUDCFont 設定檔。 從設定檔的值就是 EUDC 的存放位址取出 EUDC.tte，我這裡是 C:\\CIBEN\\EUDC.tte 安裝 FontForge，找到 fontforge.exe 的位址 (注意，跟桌面捷徑呼叫的執行檔不一樣！)，我的是在 C:/Program Files (x86)/FontForgeBuilds/bin/fontforge.exe 建立一個轉檔腳本 tte-extract.pe，內容如下 # Open EUDC TTE\rOpen(\u0026quot;EUDC.tte\u0026quot;, 4)\r# CHANGE TTFNAME 2 EUDC SetTTFName(0x409,1,\u0026quot;EUDC\u0026quot;)\rSetTTFName(0x409,2,\u0026quot;EUDC\u0026quot;)\rSetTTFName(0x409,3,\u0026quot;EUDC\u0026quot;)\rSetTTFName(0x409,4,\u0026quot;EUDC\u0026quot;)\rSetTTFName(0x404,1,\u0026quot;EUDC\u0026quot;)\rSetTTFName(0x404,2,\u0026quot;EUDC\u0026quot;)\rSetTTFName(0x409,3,\u0026quot;\u0026quot;)\rSetTTFName(0x404,4,\u0026quot;EUDC\u0026quot;)\rSetFontNames(\u0026quot;EUDC\u0026quot;, \u0026quot;EUDC\u0026quot;, \u0026quot;EUDC\u0026quot;, \u0026quot;Regular\u0026quot;, \u0026quot;655\u0026quot;, \u0026quot;1.0.0\u0026quot;)\rGenerate(\u0026quot;EUDC.ttf\u0026quot;)\rGenerate(\u0026quot;EUDC.woff\u0026quot;)\rGenerate(\u0026quot;EUDC.woff2\u0026quot;)\rClose()\r把 EUDC.tte、tte-extract放在同一個位址，在該目錄下用指令執行轉檔 (fontforge.exe 的位址可能需要修改)： C:/Program\\ Files\\ \\(x86\\)/FontForgeBuilds/bin/fontforge.exe -script tte-extract.pe 得到的 woff、woff2、ttf 用 css 設定為網頁字形： 設定網頁字形 font-family: \u0026quot;EUDC\u0026quot;;\rfont-style: normal;\rsrc: url('./fonts/EUDC.woff2') format('woff2'),\rurl('./fonts/EUDC.woff') format('woff'),\rurl('./fonts/EUDC.ttf') format('truetype');\r}\r套用網頁字形 -webkit-font-smoothing: antialiased;\r-moz-osx-font-smoothing: grayscale;\rfont-family: '其他優先使用的字型', 'EUDC', sans-serif;\rfont-display: auto;\r}\r其他：讓 RDLC 可顯示字造難字 windows ttf 丟到 C:\\Windows\\Fonts，可能要重啟 IDE 才抓得到字型。 report 裡面的字型選擇 EUDC ","date":"August 24, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/web/web-tool-eudc-frontforge/eudc/","summary":"\u003cp\u003eWeb 在顯示姓名的時候常會遇到中文難字無法顯示，\n此時開發者在本機端如果有安裝造字檔 EUDC.TTE 就可以轉為 \u003ccode\u003ewoff\u003c/code\u003e、\u003ccode\u003ewoff2\u003c/code\u003e、\u003ccode\u003ettf\u003c/code\u003e 讓網頁正確顯示難字。\n過程需要字型工具軟體 \u003ca href=\"https://fontforge.org/en-US/\" target=\"_blank\" rel=\"noopener\"\u003eFontForge\u003c/a\u003e，\n步驟如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e拿到造字檔 EUDC.TTE\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e用 \u003ccode\u003ecmd\u003c/code\u003e 打開 \u003ccode\u003eregedit\u003c/code\u003e (win10 搜尋圖示點下後，輸入 \u003ccode\u003ecmd\u003c/code\u003e，出現小黑窗後再輸入 \u003ccode\u003eregedit\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e找到機碼 HKEY_CURRENT_USER -\u0026gt; EUDC -\u0026gt; 950 資料夾下的 \u003ccode\u003eSystemDefaultEUDCFont\u003c/code\u003e 設定檔。\u003c/li\u003e\n\u003cli\u003e從設定檔的值就是 EUDC 的存放位址取出 \u003ccode\u003eEUDC.tte\u003c/code\u003e，我這裡是 \u003ccode\u003eC:\\CIBEN\\EUDC.tte\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e安裝 \u003ca href=\"https://fontforge.org/en-US/\" target=\"_blank\" rel=\"noopener\"\u003eFontForge\u003c/a\u003e，找到 \u003ccode\u003efontforge.exe\u003c/code\u003e 的位址 (\u003cstrong\u003e注意，跟桌面捷徑呼叫的執行檔不一樣！\u003c/strong\u003e)，我的是在 \u003ccode\u003eC:/Program Files (x86)/FontForgeBuilds/bin/fontforge.exe\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e建立一個轉檔腳本 \u003ccode\u003ette-extract.pe\u003c/code\u003e，內容如下\n\u003cpre\u003e\u003ccode\u003e# Open EUDC TTE\r\nOpen(\u0026quot;EUDC.tte\u0026quot;, 4)\r\n# CHANGE TTFNAME 2 EUDC \r\nSetTTFName(0x409,1,\u0026quot;EUDC\u0026quot;)\r\nSetTTFName(0x409,2,\u0026quot;EUDC\u0026quot;)\r\nSetTTFName(0x409,3,\u0026quot;EUDC\u0026quot;)\r\nSetTTFName(0x409,4,\u0026quot;EUDC\u0026quot;)\r\nSetTTFName(0x404,1,\u0026quot;EUDC\u0026quot;)\r\nSetTTFName(0x404,2,\u0026quot;EUDC\u0026quot;)\r\nSetTTFName(0x409,3,\u0026quot;\u0026quot;)\r\nSetTTFName(0x404,4,\u0026quot;EUDC\u0026quot;)\r\nSetFontNames(\u0026quot;EUDC\u0026quot;, \u0026quot;EUDC\u0026quot;, \u0026quot;EUDC\u0026quot;, \u0026quot;Regular\u0026quot;, \u0026quot;655\u0026quot;, \u0026quot;1.0.0\u0026quot;)\r\nGenerate(\u0026quot;EUDC.ttf\u0026quot;)\r\nGenerate(\u0026quot;EUDC.woff\u0026quot;)\r\nGenerate(\u0026quot;EUDC.woff2\u0026quot;)\r\nClose()\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e把 \u003ccode\u003eEUDC.tte\u003c/code\u003e、\u003ccode\u003ette-extract\u003c/code\u003e放在同一個位址，在該目錄下用指令執行轉檔 (fontforge.exe 的位址可能需要修改)： \u003ccode\u003eC:/Program\\ Files\\ \\(x86\\)/FontForgeBuilds/bin/fontforge.exe -script tte-extract.pe\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e得到的 \u003ccode\u003ewoff\u003c/code\u003e、\u003ccode\u003ewoff2\u003c/code\u003e、\u003ccode\u003ettf\u003c/code\u003e 用 css 設定為網頁字形：\n\u003cul\u003e\n\u003cli\u003e設定網頁字形\n\u003cpre\u003e\u003ccode\u003efont-family: \u0026quot;EUDC\u0026quot;;\r\nfont-style: normal;\r\nsrc: url('./fonts/EUDC.woff2') format('woff2'),\r\nurl('./fonts/EUDC.woff') format('woff'),\r\nurl('./fonts/EUDC.ttf') format('truetype');\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e套用網頁字形\n\u003cpre\u003e\u003ccode\u003e-webkit-font-smoothing: antialiased;\r\n-moz-osx-font-smoothing: grayscale;\r\nfont-family: '其他優先使用的字型', 'EUDC', sans-serif;\r\nfont-display: auto;\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"其他讓-rdlc-可顯示字造難字\"\u003e其他：讓 RDLC 可顯示字造難字\u003c/h2\u003e\n\u003ch3 id=\"windows\"\u003ewindows\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ettf 丟到 \u003ccode\u003eC:\\Windows\\Fonts\u003c/code\u003e，可能要重啟 IDE 才抓得到字型。\u003c/li\u003e\n\u003cli\u003ereport 裡面的字型選擇 EUDC\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[Web] 把電腦的難字造字檔用 FontForge 轉為字型放到網頁上使用"},{"categories":null,"contents":"工作上需要把每一個路由都加上同一個 query string 第一直覺就是直接寫成這樣：\nrouter.beforeEach(async (to, from, next) =\u0026gt; {\rnext({\rpath: path, query: {...to.queryl ,token: tokenStr}\r})\r})\r結果卻跳出 Maximum call stack size exceeded 的錯誤，判斷程式出現無窮迴圈：\nruntime.js?96cf:285 Uncaught (in promise) RangeError: Maximum call stack size exceeded\r第一個反應是傻眼貓咪，為什麼 next() 不傳入參數的時候不會出現無窮迴圈，但塞進參數就會， 難道說 next() 在傳入參數與不傳入參數的行為並不相同！！ 因此去翻閱官網對 next() 的說明：\nnext: Function: this function must be called to resolve the hook. The action depends on the arguments provided to next:\nnext(): move on to the next hook in the pipeline. If no hooks are left, the navigation is confirmed.\n\u0026hellip; 中略\nnext(\u0026rsquo;/\u0026rsquo;) or next({ path: \u0026lsquo;/\u0026rsquo; }): redirect to a different location. The current navigation will be aborted and a new one will be started. You can pass any location object to next, which allows you to specify options like replace: true, name: \u0026lsquo;home\u0026rsquo; and any option used in router-link\u0026rsquo;s to prop or router.push\n\u0026hellip;下略\nnext() 不帶參數：會直接解開(resolve) Hook 使 navigation 往下繼續， 因此總共只會進入 Navigation Guard 1次； next('/') 或 next({...})，會放棄該次 navigation 進行重新導向(redirect)， 而不是用參數繼續同一個 navigation，因此會再次進入 Navigation Guard。 =\u0026gt;重要：next('/') 或 next({...}) 不會解開 beforeEach hook！！ 重新導向後不帶參數的 next() 才繼續解開下一次的 beforeEach， 因此如果再次進入 Navigation Guard 後又呼叫同一個帶設定參數的 next({...}) 就會造成無窮迴圈了。\n解決方法： 在給予參數的時候寫入判斷，如果參數沒有就加上參數重新 navigation； 如果有參數就呼叫 next() 解開 hook 完成該次 navigation， 因為加上參數重新導向後就可以呼叫 next()，所以不會出現無窮迴圈：\n程式碼： router.beforeEach(async (to, from, next) =\u0026gt; {\rif (!to.query.key) {\rnext({ path: to.path, query: { key: store.state.token } })\r} else {\rnext()\r}\r})\rReference Vue-Router navigation-guards\n","date":"August 19, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/frontend-vue/vue-router_add_query/","summary":"\u003cp\u003e工作上需要把每一個路由都加上同一個 query string\n第一直覺就是直接寫成這樣：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003erouter.beforeEach(async (to, from, next) =\u0026gt; {\r\n  next({\r\n    path: path, \r\n    query: {...to.queryl ,token: tokenStr}\r\n  })\r\n})\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e結果卻跳出 \u003ccode\u003eMaximum call stack size exceeded\u003c/code\u003e 的錯誤，判斷程式出現無窮迴圈：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eruntime.js?96cf:285 Uncaught (in promise) RangeError: Maximum call stack size exceeded\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e第一個反應是傻眼貓咪，為什麼 \u003ccode\u003enext()\u003c/code\u003e 不傳入參數的時候不會出現無窮迴圈，但塞進參數就會，\n難道說 \u003ccode\u003enext()\u003c/code\u003e 在傳入參數與不傳入參數的行為並不相同！！\n因此去翻閱官網對 \u003ccode\u003enext()\u003c/code\u003e 的說明：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003enext: Function: \u003cstrong\u003ethis function must be called to resolve the hook.\u003c/strong\u003e The action depends on the arguments provided to next:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003enext(): move on to the next hook in the pipeline.\u003c/strong\u003e If no hooks are left, the navigation is confirmed.\u003c/p\u003e","tags":null,"title":"[DIY] Vue Router 使用 Navigation Guard 加入查詢參數"},{"categories":null,"contents":"設置 Ubuntu 安裝 .NET Core Runtime wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb sudo apt update sudo apt install apt-transport-https sudo apt install dotnet-runtime-3.1\r安裝 Nginx 新增套件來源，新增檔案 /etc/apt/sources.list.d/nginx.list\n#/etc/apt/sources.list.d/nginx.list.\rdeb https://nginx.org/packages/ubuntu/ focal nginx\rdeb-src https://nginx.org/packages/ubuntu/ focal nginx\r安裝\nsudo apt update\rsudo apt install nginx -y\r啟動、設定開機啟動\n# 啟動 nginx\rsudo systemctl start nginx\r# 設置 nginx 開機啟動\rsudo systemctl enable nginx\r# 確認 nginx 運行狀態\rsudo systemctl status nginx\r設置 Nginx 反向代理本機的 5000 連接埠(之後 Kestrel 的 http 服務端口)\nserver {\rlisten 80;\rserver_name example.com *.example.com;\rlocation / {\rproxy_pass http://127.0.0.1:5000;\rproxy_http_version 1.1;\rproxy_set_header Upgrade $http_upgrade;\rproxy_set_header Connection keep-alive;\rproxy_set_header Host $host;\rproxy_cache_bypass $http_upgrade;\rproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\rproxy_set_header X-Forwarded-Proto $scheme;\r}\r}\r重新載入 nginx 設定\nsudo systemctl reload nginx\r設定 kestrel service 將建置好的發佈檔案上傳，假設上傳到/var/www/helloapp dll檔是helloapp.dll。\n將使用者改成www-data\nsudo chmod -R www-data:www-data /var/www/helloapp\r新增一個服務檔案/etc/systemd/system/kestrel-helloapp.service，設置如下：\n# /etc/systemd/system/kestrel-helloapp.service\r[Unit]\rDescription=Example .NET Web API App running on Ubuntu\r[Service]\rWorkingDirectory=/var/www/helloapp\r# 呼叫安裝的 .net core 環境來執行 helloapp\rExecStart=/usr/bin/dotnet /var/www/helloapp/helloapp.dll\rRestart=always\r# 如果 .net core 服務崩潰的話 10秒後嘗試重新啟動\rRestartSec=10\rKillSignal=SIGINT\rSyslogIdentifier=dotnet-example\rUser=www-data\rEnvironment=ASPNETCORE_ENVIRONMENT=Production\rEnvironment=DOTNET_PRINT_TELEMETRY_MESSAGE=false\r[Install]\rWantedBy=multi-user.target\r把服務設定為開機啟動\nsudo systemctl enable kestrel-helloapp.service\r查看 kestrel service 的執行日誌：journalctl -fu kestrel-helloapp.service\n設置 .NET Core 程式碼 // 只在 Linux 啟用 Reverse Proxy 模式 if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))\r{\rapp.UseForwardedHeaders(new ForwardedHeadersOptions\r{\rForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto\r});\r}\r這裡是預設 nginx、運行 .net core 的 Kestrel 都在同一台機器上， 如果使用 127.0.0.0/8 、 [::1]以外的伺服器作為 proxy，也就是說 nginx 在其他機器上， 則需要在 ConfigureServices 裡面像這樣額外設定信任的伺服器：\nservices.Configure\u0026lt;ForwardedHeadersOptions\u0026gt;(options =\u0026gt;\r{\roptions.KnownProxies.Add(IPAddress.Parse(\u0026quot;10.0.0.100\u0026quot;));\r});\rWeb api template 預設會將 http 導向至 https 協議 (也就是說會把 5000 重新導向至 5001) 因此 Nginx 如果是反向代理 5000 port， 則需要把 web api 當中的 middleware app.UseHttpsRedirection(); 移除 (或是在 nginx 直接設置反向代理 .net core 的 https port) 安裝 Nginx\n如果是用 Web Api 專案搭配前端開發 SPA， 可安裝擴充套件 Microsoft.AspNetCore.SpaServices.Extensions， 並且在 middleware 最後設置路由 app.UseSpa(spa =\u0026gt; { });。 也可以不安裝擴充套件改用以下的程式碼手動進行設定：\n// 搭配 vue router history mode 重寫路徑請求\rapp.Use(async (ctx, next) =\u0026gt;\r{\rawait next();\rbool is404 = ctx.Response.StatusCode == 404;\rbool hasExt = Path.HasExtension(ctx.Request.Path.Value);\rif (is404 \u0026amp;\u0026amp; !hasExt)\r{\rctx.Request.Path = \u0026quot;/index.html\u0026quot;;\rctx.Response.StatusCode = 200;\rawait next();\r}\r});\r強化安全性 設定 https 拿到憑證之後可以進行設定， Nginx 裡面憑證設定方式可以參考 ssl 設定產生器。\n如果要使用到自簽憑證可以用下面的方式產生：\nsudo mkdir /etc/ssl/private\rsudo chmod 700 /etc/ssl/private\rsudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.key -out /etc/ssl/certs/nginx-selfsigned.crt\rsudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048\r接著在 Nginx.conf 檔案裡面設定：\nssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;\rssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;\rssl_dhparam /etc/ssl/certs/dhparam.pem;\r設置防火牆 安裝啟用 Linux 安全性模組 (LSM) 裡面的 ufw 防火牆， 只允許 ssh、http、https(也可以選擇不要允許 http)：\nsudo apt-get install ufw\rsudo ufw allow 22/tcp\rsudo ufw allow 80/tcp\rsudo ufw allow 443/tcp\rsudo ufw enable\r隱藏 Nginx 資訊 編輯 src/http/ngx_http_header_filter_module.c 變更 Nginx 回應名稱：\nstatic char ngx_http_server_string[] = \u0026quot;Server: Web Server\u0026quot; CRLF;\rstatic char ngx_http_server_full_string[] = \u0026quot;Server: Web Server\u0026quot; CRLF;\rReference MSDN - Host ASP.NET Core on Linux with Nginx ","date":"August 11, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/deploy-ubuntu2004-nginx/ubuntu2004_nginx/","summary":"\u003ch1 id=\"設置-ubuntu\"\u003e設置 Ubuntu\u003c/h1\u003e\n\u003ch2 id=\"安裝-net-core-runtime\"\u003e安裝 .NET Core Runtime\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ewget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb \r\nsudo dpkg -i packages-microsoft-prod.deb \r\nsudo apt update \r\nsudo apt install apt-transport-https \r\nsudo apt install dotnet-runtime-3.1\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"安裝-nginx\"\u003e安裝 Nginx\u003c/h2\u003e\n\u003cp\u003e新增套件來源，新增檔案 /etc/apt/sources.list.d/nginx.list\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#/etc/apt/sources.list.d/nginx.list.\r\ndeb https://nginx.org/packages/ubuntu/ focal nginx\r\ndeb-src https://nginx.org/packages/ubuntu/ focal nginx\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e安裝\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003esudo apt update\r\nsudo apt install nginx -y\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e啟動、設定開機啟動\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 啟動 nginx\r\nsudo systemctl start nginx\r\n# 設置 nginx 開機啟動\r\nsudo systemctl enable nginx\r\n# 確認 nginx 運行狀態\r\nsudo systemctl status nginx\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e設置 Nginx 反向代理本機的 5000 連接埠(之後 Kestrel 的 http 服務端口)\u003c/p\u003e","tags":null,"title":"[.NET Core] 在 Ubuntu 20.04 上部署 .NET (使用 Nginx 反向代理)"},{"categories":null,"contents":"在 LINQ 當道的時代雖然 DataTable 比較少用了，但還是難免會碰到， 下面紀錄如何在.NET Core 裡面把 DataTable 的資料轉成 JsonElement，\npublic JsonElement jsonFromDataTable(DataTable dt) {\rusing (var stream = new MemoryStream()) {\rusing (var writer = new Utf8JsonWriter(stream)) {\r// 起始一個裝 JElement 的陣列\rwriter.WriteStartArray(); foreach (DataRow row in dt.Rows) {\r// 開始寫入每個 Row 各自對應的 JElement 寫入程序\rwriter.WriteStartObject(); foreach (DataColumn column in row.Table.Columns) {\r// 先寫入屬性名稱\rwriter.WritePropertyName(column.ColumnName);\r// 判斷欄位值是否為 DBNull 來寫入值或 Null\rif (row[column.ColumnName] == DBNull.Value)\rwriter.WriteNullValue();\relse\rJsonSerializer.Serialize(writer, row[column]);\r}\r// 結束一列資料對應的 JElement 寫入程序\rwriter.WriteEndObject();\r}\r// 結束整個陣列的寫入\rwriter.WriteEndArray();\r}\r// 最後 Stream 讀取的資料會寫成 JsonDocument 的 RootElement\rreturn JsonDocument.Parse( stream.ToArray() ).RootElement;\r}\r}\r使用方式：\nDataTable dt = new DataTable();\r// 下略對 dt 一連串操作\r// 直接把 DataTable 轉換成 JsonElement\rJsonElement je = jsonFromDataTable(dt);\r","date":"August 6, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/snippet-json-dt/","summary":"\u003cp\u003e在 LINQ 當道的時代雖然 DataTable 比較少用了，但還是難免會碰到，\n下面紀錄如何在.NET Core 裡面把 DataTable 的資料轉成 JsonElement，\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c#\"\u003epublic JsonElement jsonFromDataTable(DataTable dt) {\r\n    using (var stream = new MemoryStream()) {\r\n        using (var writer = new Utf8JsonWriter(stream)) {\r\n            // 起始一個裝 JElement 的陣列\r\n            writer.WriteStartArray(); \r\n            foreach (DataRow row in dt.Rows) {\r\n                // 開始寫入每個 Row 各自對應的 JElement 寫入程序\r\n                writer.WriteStartObject(); \r\n                foreach (DataColumn column in row.Table.Columns) {\r\n                    // 先寫入屬性名稱\r\n                    writer.WritePropertyName(column.ColumnName);\r\n                    // 判斷欄位值是否為 DBNull 來寫入值或 Null\r\n                    if (row[column.ColumnName] == DBNull.Value)\r\n                        writer.WriteNullValue();\r\n                    else\r\n                        JsonSerializer.Serialize(writer, row[column]);\r\n                }\r\n                // 結束一列資料對應的 JElement 寫入程序\r\n                writer.WriteEndObject();\r\n            }\r\n            // 結束整個陣列的寫入\r\n            writer.WriteEndArray();\r\n        }\r\n        // 最後 Stream 讀取的資料會寫成 JsonDocument 的 RootElement\r\n        return JsonDocument.Parse( stream.ToArray() ).RootElement;\r\n    }\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用方式：\u003c/p\u003e","tags":null,"title":"[.NET] JsonDocument 與 DataTable 的互相轉換"},{"categories":null,"contents":".NET Core 中對 JsonElement 的操作不像以往 Newtonsoft.Json 一樣直覺， 需要自己建立一個方便的讀寫方法，原理是寫到另一個 JsonDocument， 如果要移除某個屬性也是一樣的道理，變成從從屬性名稱判斷是不是要寫到新的 JsonDocument， 下面是添加一個屬性的範例。\npublic static class JsonExt\r{\rpublic static void Add(ref this JsonElement source, string name, string value)\r{\rusing (MemoryStream ms = new MemoryStream())\r{\rusing (Utf8JsonWriter writer = new Utf8JsonWriter(ms))\r{\rusing (JsonDocument json = JsonDocument.Parse(\u0026quot;{}\u0026quot;))\r{\rwriter.WriteStartObject(); // 開始\rforeach (var el in source.EnumerateObject())\rel.WriteTo(writer);\r// 寫入新屬性\rwriter.WritePropertyName(name);\rwriter.WriteStringValue(value);\rwriter.WriteEndObject(); // 結束\r}\r}\rvar resultStr = Encoding.UTF8.GetString(ms.ToArray());\rvar resultEl = JsonDocument.Parse(resultStr).RootElement;\rsource = resultEl;\r}\r}\r}\r通常我們會解析從其他 api 來的 json 字串，然後再進行一些操作：\n// 解析一個 json string ()，拿到 JsonDocument\rvar jo = JsonDocument.Parse(\u0026quot;{}\u0026quot;) // 從 RootElement 屬性拿到解析出的 JsonElement JsonElement je = jo.RootElement;\r// 對 JsonElement 添加一對 key-value \u0026quot;hello\u0026quot;:\u0026quot;word\u0026quot;\rje.Add(\u0026quot;hello\u0026quot;,\u0026quot;word\u0026quot;); ","date":"August 6, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/snippet-json-operate/","summary":"\u003cp\u003e.NET Core 中對 JsonElement 的操作不像以往 Newtonsoft.Json 一樣直覺，\n需要自己建立一個方便的讀寫方法，原理是寫到另一個 JsonDocument，\n如果要移除某個屬性也是一樣的道理，變成從從屬性名稱判斷是不是要寫到新的 JsonDocument，\n下面是添加一個屬性的範例。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c#\"\u003epublic static class JsonExt\r\n{\r\n\tpublic static void Add(ref this JsonElement source, string name, string value)\r\n\t{\r\n\t\tusing (MemoryStream ms = new MemoryStream())\r\n\t\t{\r\n\t\t\tusing (Utf8JsonWriter writer = new Utf8JsonWriter(ms))\r\n\t\t\t{\r\n\t\t\t\tusing (JsonDocument json = JsonDocument.Parse(\u0026quot;{}\u0026quot;))\r\n\t\t\t\t{\r\n\t\t\t\t\twriter.WriteStartObject(); // 開始\r\n\t\t\t\t\tforeach (var el in source.EnumerateObject())\r\n\t\t\t\t\t\tel.WriteTo(writer);\r\n\t\t\t\t\t// 寫入新屬性\r\n\t\t\t\t\twriter.WritePropertyName(name);\r\n\t\t\t\t\twriter.WriteStringValue(value);\r\n\t\t\t\t\twriter.WriteEndObject(); // 結束\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar resultStr = Encoding.UTF8.GetString(ms.ToArray());\r\n\t\t\tvar resultEl = JsonDocument.Parse(resultStr).RootElement;\r\n\t\t\tsource = resultEl;\r\n\t\t}\r\n\t}\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通常我們會解析從其他 api 來的 json 字串，然後再進行一些操作：\u003c/p\u003e","tags":null,"title":"[.NET] JsonElement 的操作"},{"categories":null,"contents":" 情境1：要選取多個 ckeckbox 對應到資料庫的欄位，欄位值是一串YN代表某個選項是否有被選去，例如： YNNYYNNYYN 情境2：要選取多個 ckeckbox 對應到資料庫的欄位，欄位值只有一個，可能是任何字元，例如： 1 可以打造兩個元件，分別對應至單選、多選 單選元件 程式碼 (Code) Vue.component('x-ck-single', {\rprops: {\rdisabled: { type: Boolean, default: () =\u0026gt; false },\r// checkbox 的標記 [string] || [{text:string, value:any}]\rlabels: { type: Array, default: () =\u0026gt; ['Yes', 'No'] }, value: { default: () =\u0026gt; null },\rtrueValue: { default: () =\u0026gt; 'Y' },\rfalseValue: { default: () =\u0026gt; 'N' },\rinline: { type: Boolean, default: () =\u0026gt; false },\r},\rdata() {\rreturn {\rinnervalue_: this.value,\r}\r},\rwatch: {\rvalue(v) {\rthis.innervalue_ = v\r},\r},\rcomputed: {\rinnervalue: {\rget() {\rreturn this.innervalue_\r},\rset(v) {\rthis.innervalue_ = v\rthis.$emit('input', v)\r},\r},\r},\rrender: function (h) {\rconst self = this\rlet len = self.labels.length // labels 的長度\rlet allStr = self.labels.every((label) =\u0026gt; typeof label == 'string') // 是否為 string\rlet allOkObj = self.labels.every((l) =\u0026gt; !!l.text \u0026amp;\u0026amp; !!l.value) // 是否為合法的物件(如果不是 string)\rlet siblingConf = null\rif (allOkObj) {\rsiblingConf = self.labels.map((l) =\u0026gt; _.pick(l, ['text', 'value']))\r} else if (allStr \u0026amp;\u0026amp; len \u0026lt;= 2) {\rsiblingConf = self.labels.map((text, idx) =\u0026gt; {\rlet value = idx === 0 ? self.trueValue : self.falseValue\rreturn { text, value }\r})\r}\rif (!siblingConf) {\rlet errStr = '無法正確設定元件,len,allStr,allOkObj'\rreturn h('div', errStr, len, allStr, allOkObj)\r}\r// 設定 CheckBox\rlet { disabled } = self\rlet hideDetails = true\rlet dense = true\rconst baseProps = { hideDetails, dense, disabled }\rconst baseClass = self.inline ? ['d-inline-block'] : []\rlet siblings = siblingConf.map((c) =\u0026gt; {\rlet props = {\rlabel: c.text,\rinputValue: self.innervalue === c.value,\r...baseProps,\r}\r// 如果只有一個選項，取消勾選時就顯示 falseValue\rlet valueOnNull = len === 1 ? self.falseValue : null\rlet on = {\rchange: (e) =\u0026gt; (self.innervalue = e ? c.value : valueOnNull),\r}\rreturn h(\u0026quot;v-checkbox\u0026quot;, { props, class: baseClass, on })\r})\r// 傳回整個元件\rreturn h('div', {}, siblings)\r}\r})\r{{value === null ? 'null' : value}}\r多選元件 程式碼 (Code) ","date":"July 29, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/frontend-vue/vue-comp-yncheckbox/","summary":"\u003cul\u003e\n\u003cli\u003e情境1：要選取多個 ckeckbox 對應到資料庫的欄位，欄位值是一串YN代表某個選項是否有被選去，例如： YNNYYNNYYN\u003c/li\u003e\n\u003cli\u003e情境2：要選取多個 ckeckbox 對應到資料庫的欄位，欄位值只有一個，可能是任何字元，例如： 1\n可以打造兩個元件，分別對應至單選、多選\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"單選元件\"\u003e單選元件\u003c/h1\u003e\n\u003ch2 id=\"程式碼-code\"\u003e程式碼 (Code)\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eVue.component('x-ck-single', {\r\n    props: {\r\n    disabled: { type: Boolean, default: () =\u0026gt; false },\r\n    // checkbox 的標記 [string] || [{text:string, value:any}]\r\n    labels: { type: Array, default: () =\u0026gt; ['Yes', 'No'] }, \r\n    value: { default: () =\u0026gt; null },\r\n    trueValue: { default: () =\u0026gt; 'Y' },\r\n    falseValue: { default: () =\u0026gt; 'N' },\r\n    inline: { type: Boolean, default: () =\u0026gt; false },\r\n  },\r\n  data() {\r\n    return {\r\n      innervalue_: this.value,\r\n    }\r\n  },\r\n  watch: {\r\n    value(v) {\r\n      this.innervalue_ = v\r\n    },\r\n  },\r\n  computed: {\r\n    innervalue: {\r\n      get() {\r\n        return this.innervalue_\r\n      },\r\n      set(v) {\r\n        this.innervalue_ = v\r\n        this.$emit('input', v)\r\n      },\r\n    },\r\n  },\r\n  render: function (h) {\r\n    const self = this\r\n\r\n    let len = self.labels.length // labels 的長度\r\n    let allStr = self.labels.every((label) =\u0026gt; typeof label == 'string') // 是否為 string\r\n    let allOkObj = self.labels.every((l) =\u0026gt; !!l.text \u0026amp;\u0026amp; !!l.value) // 是否為合法的物件(如果不是 string)\r\n    let siblingConf = null\r\n\r\n    if (allOkObj) {\r\n      siblingConf = self.labels.map((l) =\u0026gt; _.pick(l, ['text', 'value']))\r\n    } else if (allStr \u0026amp;\u0026amp; len \u0026lt;= 2) {\r\n      siblingConf = self.labels.map((text, idx) =\u0026gt; {\r\n        let value = idx === 0 ? self.trueValue : self.falseValue\r\n        return { text, value }\r\n      })\r\n    }\r\n\r\n    if (!siblingConf) {\r\n      let errStr = '無法正確設定元件,len,allStr,allOkObj'\r\n      return h('div', errStr, len, allStr, allOkObj)\r\n    }\r\n    // 設定 CheckBox\r\n    let { disabled } = self\r\n    let hideDetails = true\r\n    let dense = true\r\n    const baseProps = { hideDetails, dense, disabled }\r\n    const baseClass = self.inline ? ['d-inline-block'] : []\r\n    let siblings = siblingConf.map((c) =\u0026gt; {\r\n      let props = {\r\n        label: c.text,\r\n        inputValue: self.innervalue === c.value,\r\n        ...baseProps,\r\n      }\r\n      // 如果只有一個選項，取消勾選時就顯示 falseValue\r\n      let valueOnNull = len === 1 ? self.falseValue : null\r\n      let on = {\r\n        change: (e) =\u0026gt; (self.innervalue = e ? c.value : valueOnNull),\r\n      }\r\n      return h(\u0026quot;v-checkbox\u0026quot;, { props, class: baseClass, on })\r\n    })\r\n    // 傳回整個元件\r\n    return h('div', {}, siblings)\r\n  }\r\n})\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv id=\"app\"\u003e\r\n  \u003cx-ck-single v-model=\"value\" inline\u003e\u003c/x-ck-single\u003e\r\n  {{value === null ? 'null' : value}}\r\n\u003c/div\u003e\r\n\u003cscript src=\"https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js\"\u003e\u003c/script\u003e\r\n\u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js\"\u003e\u003c/script\u003e\r\n\u003cscript src=\"https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js\"\u003e\u003c/script\u003e\r\n\u003cscript\u003e\r\nVue.component('x-ck-single', {\r\n  props: {\r\n  disabled: { type: Boolean, default: () =\u003e false },\r\n  // checkbox 的標記 [string] || [{text:string, value:any}]\r\n  labels: { type: Array, default: () =\u003e ['Yes', 'No'] }, \r\n  value: { default: () =\u003e null },\r\n  trueValue: { default: () =\u003e 'Y' },\r\n  falseValue: { default: () =\u003e 'N' },\r\n  inline: { type: Boolean, default: () =\u003e false },\r\n  },\r\n  data() {\r\n    return {\r\n      innervalue_: this.value,\r\n    }\r\n  },\r\n  watch: {\r\n    value(v) {\r\n      this.innervalue_ = v\r\n    },\r\n  },\r\n  computed: {\r\n    innervalue: {\r\n      get() {\r\n        return this.innervalue_\r\n      },\r\n      set(v) {\r\n        this.innervalue_ = v\r\n        this.$emit('input', v)\r\n      },\r\n    },\r\n  },\r\n  render: function (h) {\r\n    const self = this\r\n    let len = self.labels.length // labels 的長度\r\n    let allStr = self.labels.every((label) =\u003e typeof label == 'string') // 是否為 string\r\n    let allOkObj = self.labels.every((l) =\u003e !!l.text \u0026\u0026 !!l.value) // 是否為合法的物件(如果不是 string)\r\n    let siblingConf = null\r\n    if (allOkObj) {\r\n      siblingConf = self.labels.map((l) =\u003e _.pick(l, ['text', 'value']))\r\n    } else if (allStr \u0026\u0026 len \u003c= 2) {\r\n      siblingConf = self.labels.map((text, idx) =\u003e {\r\n        let value = idx === 0 ? self.trueValue : self.falseValue\r\n        return { text, value }\r\n      })\r\n    }\r\n    if (!siblingConf) {\r\n      let errStr = '無法正確設定元件,len,allStr,allOkObj'\r\n      return h('div', errStr, len, allStr, allOkObj)\r\n    }\r\n    // 設定 CheckBox\r\n    let { disabled } = self\r\n    let hideDetails = true\r\n    let dense = true\r\n    const baseProps = { hideDetails, dense, disabled }\r\n    const baseClass = self.inline ? ['d-inline-block'] : []\r\n    let siblings = siblingConf.map((c) =\u003e {\r\n      let props = {\r\n        label: c.text,\r\n        inputValue: self.innervalue === c.value,\r\n        ...baseProps,\r\n      }\r\n      // 如果只有一個選項，取消勾選時就顯示 falseValue\r\n      let valueOnNull = len === 1 ? self.falseValue : null\r\n      let on = {\r\n        change: (e) =\u003e (self.innervalue = e ? c.value : valueOnNull),\r\n      }\r\n      return h(\"v-checkbox\", { props, class: baseClass, on })\r\n    })\r\n    // 傳回整個元件\r\n    return h('div', {}, siblings)\r\n  }\r\n})\r\n\u003c/script\u003e\r\n\u003cscript\u003e\r\n  new Vue({\r\n    el: '#app',\r\n    data: { value: '' }\r\n  })\r\n\u003c/script\u003e\r\n\u003ch1 id=\"多選元件\"\u003e多選元件\u003c/h1\u003e\n\u003ch2 id=\"程式碼-code-1\"\u003e程式碼 (Code)\u003c/h2\u003e","tags":null,"title":"[DIY] 用 Render Function 打造靈活的 CheckBox 元件範例"},{"categories":null,"contents":"多層式架構 Multitier Architecture 或稱 N-Tier Architecture， 是 Client–server architecture 的一種， 多層架構的層可以是 layer 或 tier，這兩者之間主要的差別在於 layer 指程式邏輯在應用程式的位置； 而 tier 指 layer 在系統上實際部屬執行的位址，屬於物理層級的指涉。 這一篇的層指的是 tier。\nN-tier model N-tier model，層與層之間的邊界有 N-1 個，而程式跨邊界會造成巨大的效能損失， 一說為光是跨越同一台機器上不同進程(process)邊界存取資源損失就大約1000倍， 如果透過網路進行遠端呼叫勢必損失更多， 因此每跨越一個邊界進行資源存取效能就會以幾何級數損失。 且增加邊界在軟體設計上會增加複雜度，簡單的應用程式使用多層式架構很容易造成過度設計(over design)， 因此如何適當添加層級(tier)也是一門學問，添加層級時必需考量如何在應用程式所部屬的環境獲取最大的成本效益。 軟體是否採用多層式架構必須以多層式架構的優缺點進行取捨(尤其是可擴展性與效能之間)。\n提高可擴展性(scalability)。 提高效能(performance)。 提高容錯率(fault tolerance)。 提高安全性(security)。 1-tier model 所有的 layer 都在同一機器、同一記憶體空間內運行，因此不需考慮網路造成的性能損失。\n2-tier model layer 分配至兩個不同的記憶體空間運行，記憶體空間可能位於相同或兩台不同的機器上(通常是不同機器)，典型的例子是分配到 client、server 上運行。\n3-tier model 多層式架構當中最常使用的就是三層架構(three-tier architecture)。 三層架構與Web應用程式來說明如下：\n表現層(Presentation)：又稱為 UI 層，以Web來說就是呈現出來的前端網頁。 應用程式層(Application)：以 Web 來說相當於伺服器上執行的應用程式。 資料層(Data)：這一層包含資料儲存、呈現機制，以 Web 來說通常指 Database。 Reference wikipedia - Multitier architecture Rockford Lhotka - Should all apps be n-tier? N Tier(Multi-Tier), 3-Tier, 2-Tier Architecture with EXAMPLE ","date":"May 17, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/software/arch-n-tier/","summary":"\u003cp\u003e多層式架構 Multitier Architecture 或稱 N-Tier Architecture，\n是 Client–server architecture 的一種，\n多層架構的層可以是 layer 或 tier，這兩者之間主要的差別在於 layer 指程式邏輯在應用程式的位置；\n而 tier 指 layer 在系統上實際部屬執行的位址，屬於物理層級的指涉。\n這一篇的層指的是 tier。\u003c/p\u003e\n\u003ch1 id=\"n-tier-model\"\u003eN-tier model\u003c/h1\u003e\n\u003cp\u003eN-tier model，層與層之間的邊界有 N-1 個，而程式跨邊界會造成巨大的效能損失，\n一說為光是跨越同一台機器上不同進程(process)邊界存取資源損失就大約1000倍，\n如果透過網路進行遠端呼叫勢必損失更多，\n因此每跨越一個邊界進行資源存取效能就會以幾何級數損失。\n且增加邊界在軟體設計上會增加複雜度，簡單的應用程式使用多層式架構很容易造成過度設計(over design)，\n因此如何適當添加層級(tier)也是一門學問，添加層級時必需考量如何在應用程式所部屬的環境獲取最大的成本效益。\n軟體是否採用多層式架構必須以多層式架構的優缺點進行取捨(尤其是可擴展性與效能之間)。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e提高可擴展性(scalability)。\u003c/li\u003e\n\u003cli\u003e提高效能(performance)。\u003c/li\u003e\n\u003cli\u003e提高容錯率(fault tolerance)。\u003c/li\u003e\n\u003cli\u003e提高安全性(security)。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"1-tier-model\"\u003e1-tier model\u003c/h2\u003e\n\u003cp\u003e所有的 layer 都在同一機器、同一記憶體空間內運行，因此不需考慮網路造成的性能損失。\u003c/p\u003e\n\u003ch2 id=\"2-tier-model\"\u003e2-tier model\u003c/h2\u003e\n\u003cp\u003elayer 分配至兩個不同的記憶體空間運行，記憶體空間可能位於相同或兩台不同的機器上(通常是不同機器)，典型的例子是分配到 client、server 上運行。\u003c/p\u003e\n\u003ch2 id=\"3-tier-model\"\u003e3-tier model\u003c/h2\u003e\n\u003cp\u003e多層式架構當中最常使用的就是三層架構(three-tier architecture)。\n三層架構與Web應用程式來說明如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e表現層(Presentation)：又稱為 UI 層，以Web來說就是呈現出來的前端網頁。\u003c/li\u003e\n\u003cli\u003e應用程式層(Application)：以 Web 來說相當於伺服器上執行的應用程式。\u003c/li\u003e\n\u003cli\u003e資料層(Data)：這一層包含資料儲存、呈現機制，以 Web 來說通常指 Database。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"reference\"\u003eReference\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Multitier_architecture\" target=\"_blank\" rel=\"noopener\"\u003ewikipedia - Multitier architecture\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.lhotka.net/weblog/ShouldAllAppsBeNtier.aspx\" target=\"_blank\" rel=\"noopener\"\u003eRockford Lhotka - Should all apps be n-tier?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.guru99.com/n-tier-architecture-system-concepts-tips.html\" target=\"_blank\" rel=\"noopener\"\u003eN Tier(Multi-Tier), 3-Tier, 2-Tier Architecture with EXAMPLE\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[架構] 多層式架構(Multitier Architecture)"},{"categories":null,"contents":"前後端分離的開發環境以 Ajax 呼叫資源時時會遇到跨網域存取的問題， 一些比較全面的開發環境像是 webpack、vue-cli 等等通常提供內建開發代理伺服器可供設置， 如果要對於不熟悉的開發環境進行快速除錯 (例如 vue 開發者臨時檢查其他框架的程式碼遇到跨網域問題)， 重新研究如何設置開發環境跨網域代理伺服器往往就花費多餘的時間 (不過最終還是要搭建起來阿，喂~~)， 因此紀錄一下怎麼用 node.js 建立一個通用的代理伺服器處理跨網域問題，整個過程不超過5分鐘。\n步驟 首先安裝 node.js 建立專案資料夾 建立一個資料夾叫做 proxy 存放這個專案吧，手動建立也可以。\nmkdir proxy\r起始專案 用指令移動到該專案資料夾下，起始專案：\ncd proxy\rnpm init 安裝相依性 npm i express http-proxy-middleware cors\r建立 app.js const express = require('express');\rconst cors = require('cors');\rconst { createProxyMiddleware } = require('http-proxy-middleware');\r// 建立一個 Express 伺服器\rconst app = express();\rapp.use(cors())\r// 設定 Express 伺服器的 Host、Port\rconst PORT = 3000;\rconst HOST = \u0026quot;localhost\u0026quot;;\r// 設定代理到 google 的 Proxy 端點\rapp.use('/google', createProxyMiddleware({\rtarget: \u0026quot;https://www.google.com/\u0026quot;,\rchangeOrigin: true,\rpathRewrite: {\r[`^/google`]: '',\r},\r}));\r// 設定代理到 yahoo 的 Proxy 端點\rapp.use('/yahoo', createProxyMiddleware({\rtarget: \u0026quot;https://tw.yahoo.com/\u0026quot;,\rchangeOrigin: true,\rpathRewrite: {\r[`^/yahoo`]: '',\r},\r}));\r// 啟動代理伺服器\rapp.listen(PORT, HOST, () =\u0026gt; {\rconsole.log(`Starting Proxy at ${HOST}:${PORT}`);\r});\r啟動代理伺服器 $ node app.js\r[HPM] Proxy created: / -\u0026gt; https://www.google.com/\r[HPM] Proxy rewrite rule created: \u0026quot;^/google\u0026quot; ~\u0026gt; \u0026quot;\u0026quot;\r[HPM] Proxy created: / -\u0026gt; https://tw.yahoo.com/\r[HPM] Proxy rewrite rule created: \u0026quot;^/yahoo\u0026quot; ~\u0026gt; \u0026quot;\u0026quot;\rStarting Proxy at localhost:3000\r測試 打開隨意網頁 F12，用 fetch api 透過 proxy 對 google 或 yahoo 發起 get 請求成功獲得資訊，且 Header 裡面會有Access-Control-Allow-Origin: *：\nfetch('http://localhost:3000/google/')\r.then(response =\u0026gt; response.text())\r.then(data =\u0026gt; console.log(data));\r// Promise {\u0026lt;pending\u0026gt;}\r// \u0026lt;!doctype html\u0026gt;\u0026lt;html itemscope=\u0026quot;\u0026quot; itemtype=\u0026quot;http://schema.org/WebPage\u0026quot; lang=\u0026quot;zh-TW\u0026quot;\u0026gt;\u0026lt;head\u0026gt;\u0026lt;meta charset=\u0026quot;UT...\r如果是直接對 google 發起的 get 請求則會因為跨網域問題不會成功：\nfetch('https://www.google.com/')\r.then(response =\u0026gt; response.text())\r.then(data =\u0026gt; console.log(data));\r// Promise {\u0026lt;pending\u0026gt;}\r// Access to fetch at 'https://www.google.com/' from origin 'https://developer.mozilla.org' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.\r// GET https://www.google.com/ net::ERR_FAILED\r// Using_Fetch:1 Uncaught (in promise) TypeError: Failed to fetch\r","date":"March 20, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/javascript/diy-http-proxy-middleware/","summary":"\u003cp\u003e前後端分離的開發環境以 Ajax 呼叫資源時時會遇到跨網域存取的問題，\n一些比較全面的開發環境像是 webpack、vue-cli 等等通常提供內建開發代理伺服器可供設置，\n如果要對於不熟悉的開發環境進行快速除錯\n(例如 vue 開發者臨時檢查其他框架的程式碼遇到跨網域問題)，\n重新研究如何設置開發環境跨網域代理伺服器往往就花費多餘的時間\n(不過最終還是要搭建起來阿，喂~~)，\n因此紀錄一下怎麼用 node.js 建立一個通用的代理伺服器處理跨網域問題，整個過程不超過5分鐘。\u003c/p\u003e\n\u003ch1 id=\"步驟\"\u003e步驟\u003c/h1\u003e\n\u003ch2 id=\"首先安裝-nodejs\"\u003e首先安裝 \u003ca href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\"\u003enode.js\u003c/a\u003e\u003c/h2\u003e\n\u003ch2 id=\"建立專案資料夾\"\u003e建立專案資料夾\u003c/h2\u003e\n\u003cp\u003e建立一個資料夾叫做 proxy 存放這個專案吧，手動建立也可以。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003emkdir proxy\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"起始專案\"\u003e起始專案\u003c/h2\u003e\n\u003cp\u003e用指令移動到該專案資料夾下，起始專案：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ecd proxy\r\nnpm init \r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"安裝相依性\"\u003e安裝相依性\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm i express http-proxy-middleware cors\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"建立-appjs\"\u003e建立 app.js\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst express = require('express');\r\nconst cors = require('cors');\r\nconst { createProxyMiddleware } = require('http-proxy-middleware');\r\n\r\n// 建立一個 Express 伺服器\r\nconst app = express();\r\napp.use(cors())\r\n\r\n// 設定 Express 伺服器的 Host、Port\r\nconst PORT = 3000;\r\nconst HOST = \u0026quot;localhost\u0026quot;;\r\n\r\n// 設定代理到 google 的 Proxy 端點\r\napp.use('/google', createProxyMiddleware({\r\n    target: \u0026quot;https://www.google.com/\u0026quot;,\r\n    changeOrigin: true,\r\n    pathRewrite: {\r\n        [`^/google`]: '',\r\n    },\r\n}));\r\n\r\n// 設定代理到 yahoo 的 Proxy 端點\r\napp.use('/yahoo', createProxyMiddleware({\r\n    target: \u0026quot;https://tw.yahoo.com/\u0026quot;,\r\n    changeOrigin: true,\r\n    pathRewrite: {\r\n        [`^/yahoo`]: '',\r\n    },\r\n}));\r\n\r\n// 啟動代理伺服器\r\napp.listen(PORT, HOST, () =\u0026gt; {\r\n    console.log(`Starting Proxy at ${HOST}:${PORT}`);\r\n});\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"啟動代理伺服器\"\u003e啟動代理伺服器\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ node app.js\r\n[HPM] Proxy created: /  -\u0026gt; https://www.google.com/\r\n[HPM] Proxy rewrite rule created: \u0026quot;^/google\u0026quot; ~\u0026gt; \u0026quot;\u0026quot;\r\n[HPM] Proxy created: /  -\u0026gt; https://tw.yahoo.com/\r\n[HPM] Proxy rewrite rule created: \u0026quot;^/yahoo\u0026quot; ~\u0026gt; \u0026quot;\u0026quot;\r\nStarting Proxy at localhost:3000\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"測試\"\u003e測試\u003c/h2\u003e\n\u003cp\u003e打開隨意網頁 F12，用 fetch api 透過 proxy 對 google 或 yahoo 發起 get 請求成功獲得資訊，且 Header 裡面會有\u003ccode\u003eAccess-Control-Allow-Origin: *\u003c/code\u003e：\u003c/p\u003e","tags":null,"title":"[Tools] 10分鐘建造 proxy 克服跨網域資源存取(CORS)問題"},{"categories":null,"contents":"ASP .NET Core 當中的 Web 控制器屬於IO密集的應用程式，當中主要使用的 TAP 是一種簡易使用、語言層級的非同步設計模式。 透過 TAP 可設計出非同步(Asynchronous)/非阻塞(Non-Blocking)的 Web API，大幅提高 Web 應用程式的併發性(Concurrency)。\n非同步方法 C# 當中基於 TAP 設計的的非同步方法 (TAP method) 有幾個特性：\n產生可等待 awaitable 型別 (Task, Task\u0026lt;TResult\u0026gt;, ValueTask, 和 ValueTask\u0026lt;TResult\u0026gt;)， 其中以 Task、Task\u0026lt;TResult\u0026gt;最常見。 非同步方法的參數順序通常跟同步版本的方法相同，但方法名稱以 Async 結尾。 async、await await 運算子用來等待非同步行為完成， 或等待非同步行為完成後解析回傳值， await 運算子只能用在非同步方法中， 因此 await 運算子的外層方法必須套用 async 修飾， 否則會出現錯誤。\n非同步 Action 設計原則： 總是加上 async 關鍵字 async 的方法裡面可以等待非同步方法。 action 前加上 async 的作用在於建立一個管理回傳任務的狀態機(state machine)， 當 async 方法擲出例外時會被狀態機捕獲並放到任務中回傳， 而這也是以 Task 作為回傳值的方法的預期行為。 如果沒有 async 關鍵字則擲出的例外會被直接傳遞到呼叫者(caller)， 因此除非確定該 aciton 不會擲出任何例外，否則一律加上 async。\n在Action中使用非同步方法： 在非同步方法中長時間執行同步方法會阻塞造成其他非同步方法初始化執行而降低併發性。 且如果 API 回傳型別是 Task 但卻只使用同步函式， 那該API的行為就只是同步。 以 Dapper 存取資料庫為例子，用 QueryAsync 代替 Query， 可以避免在 Query 在等待回應的時候阻塞其他非同步方法的執行。\n範例 透過建立一個非同步的 Controller 由前端呼叫，可以獲得非阻塞的結果：\n[Route(\u0026quot;api/[controller]\u0026quot;)]\r[ApiController]\rpublic class TaskController : ControllerBase\r{\r[HttpGet(\u0026quot;Delay\u0026quot;)]\rpublic async Task\u0026lt;IActionResult\u0026gt; Delay()\r{\rvar controllerName = \u0026quot;Delay\u0026quot;;\rvar startTime = DateTime.Now.ToString(\u0026quot;HH:MM:ss.fff\u0026quot;);\rawait Task.Delay(5000);\rvar endTime = DateTime.Now.ToString(\u0026quot;HH:MM:ss.fff\u0026quot;);\rreturn Ok(new { controllerName, startTime, endTime });\r}\r}\r在前端以 javscript 程式碼測試可以觀察到非阻塞 api：\nfunction callApi(url){\rfetch(url)\r.then(function(res) {\rreturn res.json();\r})\r.then(function(json) {\rconsole.log(json);\r});\r}\rcallApi('api/Task/Delay')\rcallApi('api/Task/Delay')\r// {controllerName: \u0026quot;Delay\u0026quot;, startTime: \u0026quot;02:03:46.720\u0026quot;, endTime: \u0026quot;02:03:51.764\u0026quot;}\r//{controllerName: \u0026quot;Delay\u0026quot;, startTime: \u0026quot;02:03:46.720\u0026quot;, endTime: \u0026quot;02:03:51.764\u0026quot;}\rP.S. 測試當下無法在Edge瀏覽器中呼叫同一支 api 獲得非阻塞結果， 同時呼叫 api 第二次呼叫會被瀏覽器排在第一次呼叫之後執行， 看起來會像是該 api 在伺服器端發生了阻塞， 但是 Chrome 卻沒有這個情況，可能是瀏覽器政策不同， 無論如何後端回傳 Task 的 Controller 行為都是非阻塞的。\nReference MSDN - Asynchronous programming MSDN - Task-based asynchronous pattern stackoverflow - Task without async/await in controller action method ","date":"March 17, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/basic-async-controller/","summary":"\u003cp\u003eASP .NET Core 當中的 Web 控制器屬於IO密集的應用程式，當中主要使用的 TAP 是一種簡易使用、語言層級的非同步設計模式。\n透過 TAP 可設計出非同步(Asynchronous)/非阻塞(Non-Blocking)的 Web API，大幅提高 Web 應用程式的併發性(Concurrency)。\u003c/p\u003e\n\u003ch1 id=\"非同步方法\"\u003e非同步方法\u003c/h1\u003e\n\u003cp\u003eC# 當中基於 TAP 設計的的非同步方法 (TAP method) 有幾個特性：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e產生可等待 awaitable 型別\n(Task, Task\u0026lt;TResult\u0026gt;, ValueTask, 和 ValueTask\u0026lt;TResult\u0026gt;)，\n其中以 Task、Task\u0026lt;TResult\u0026gt;最常見。\u003c/li\u003e\n\u003cli\u003e非同步方法的參數順序通常跟同步版本的方法相同，但方法名稱以 Async 結尾。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"asyncawait\"\u003easync、await\u003c/h1\u003e\n\u003cp\u003eawait 運算子用來等待非同步行為完成，\n或等待非同步行為完成後解析回傳值，\nawait 運算子只能用在非同步方法中，\n因此 await 運算子的外層方法必須套用 async 修飾，\n否則會出現錯誤。\u003c/p\u003e\n\u003ch1 id=\"非同步-action-設計原則\"\u003e非同步 Action 設計原則：\u003c/h1\u003e\n\u003ch2 id=\"總是加上-async-關鍵字\"\u003e總是加上 async 關鍵字\u003c/h2\u003e\n\u003cp\u003easync 的方法裡面可以等待非同步方法。\naction 前加上 async 的作用在於建立一個管理回傳任務的狀態機(state machine)，\n當 async 方法擲出例外時會被狀態機捕獲並放到任務中回傳，\n而這也是以 Task 作為回傳值的方法的預期行為。\n如果沒有 async 關鍵字則擲出的例外會被直接傳遞到呼叫者(caller)，\n因此除非確定該 aciton 不會擲出任何例外，否則一律加上 async。\u003c/p\u003e","tags":null,"title":"[.NET Core] 不阻塞的非同步控制器(Non-Blocking Asynchronous Controllers)"},{"categories":null,"contents":"驗證方案(Authentication Scheme) 驗證方案包含兩個部分：\n驗證處理函式(Authentication handler)，可能是 IAuthenticationHandler 或 AuthenticationHandler 的實作，相當於驗證方案的行為，責任範圍涵蓋: 驗證使用者， 驗證成功時，建構呈現使用者識別(user identity)的 AuthenticationTicket。 驗證失敗時，回傳 \u0026rsquo;no result\u0026rsquo; 或 \u0026lsquo;failure\u0026rsquo; 負責從請求上下文(request context)中建構使用者識別 (user identity)。 定義了 challenge/forbid action。 驗證處理函式的設定選項(Opitons of Authentication handler)。 驗證方案當中的 authencate action 負責從請求上下文(request context)中建構使用者識別 (user identity)， 常見的例子為：\ncookie authentication scheme 從 cookie 資訊建構 user identity. JWT bearer scheme 反序列化(deserialize)、驗證(validate) token，並從 token 所攜帶資訊建構 user identity 使用驗證方案 在 Startup.ConfigureServices 以 AddAuthentication 註冊驗證服務時會回傳一個 AuthenticationBuilder， AuthenticationBuilder 設定驗證方案的方式有：\n呼叫 scheme-specific 擴充方法，例如 AddJwtBearer、AddCookie，這些擴充方法會自動呼叫 AuthenticationBuilder.AddScheme 設定需要的驗證方式。 以 AuthenticationBuilder 內建方法 AddScheme 手動設定，一般來說較少使用。 P.S.另外可使用 polycy schemes 把多個 scheme 整合到一個使用。\n範例 以上 Scheme 的文字較抽象較難理解記憶，以下直接實作註冊 IAuthenticationService， 並直接呼叫 scheme-specific 擴充方法添加 Cookie、JWT Scheme：\n安裝 scheme 套件 安裝 scheme 套件取得 Cookie、JWT 的 scheme-specific 擴充方法：\ndotnet add package Microsoft.AspNetCore.Authentication.JwtBearer --version 3.1.10\rdotnet add package Microsoft.AspNetCore.Authentication.Cookies --version 2.2.0\r在 Startup.cs 添加對 scheme 的引用\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\rusing Microsoft.AspNetCore.Authentication.Cookies;\r註冊驗證服務 在 Startup.ConfigureServices 加入下面程式碼，AddAuthentication 會將 IAuthenticationService 驗證服務注入服務容器， AddJwtBearer、 AddCookie 分別為驗證服務添加兩種可用的 JWT、Cookie 驗證方案， 並透過 Action (就是那個 options =\u0026gt; \u0026hellip; )設定相關的處理函式與設定選項。\n若 Authorization Attribute 或 Policy 沒有指定 Scheme，預設會使用 AddAuthentication() 方法中傳入作為參數的 Scheme，同理若是服務容器中提供多種驗證服務，可在 Controller 的授權屬性指定套用的 Scheme 或 Policy：\n// 若沒有指定 Scheme 作 Authorization ，預設使用 JwtBearerDefaults.AuthenticationScheme\rservices.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\r// 讓 AP 可使用 JwtBearerDefaults.AuthenticationScheme 作為驗證方法\r.AddJwtBearer(\rJwtBearerDefaults.AuthenticationScheme,\roptions =\u0026gt; {\r// [注意]先解除 MapInboundClaims，否則會因為套件中某些為向前相容而保留的 legacy code 使得 RoleClaimType 無法生效\r// https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/1214\rif (options.SecurityTokenValidators.FirstOrDefault() is JwtSecurityTokenHandler jwtSecurityTokenHandler)\rjwtSecurityTokenHandler.MapInboundClaims = false;\r// 設置 Token 在授權後是否要儲存於 AuthenticationProperties options.SaveToken = true;\r// 設置各Token驗證參數\roptions.TokenValidationParameters = new TokenValidationParameters\r{\rNameClaimType = \u0026quot;userId\u0026quot;, // 設置 Http 請求的 User.Identity.Name、Hub 中 UserIdentifier 取值的 Claim 是 userId\rRoleClaimType = \u0026quot;roles\u0026quot;, // 設置使用者的腳色從 type=\u0026quot;roles\u0026quot; 的 claims 對應\rValidateLifetime = true, // 驗證 Token 有效期間\rValidateIssuerSigningKey = true, // 驗證 token 中的 key\rIssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(config.GetValue\u0026lt;string\u0026gt;(\u0026quot;JWT:SignKey\u0026quot;))), // 從 appsettings.json 拿 SignKey\rValidateIssuer = true, // 驗證簽發者\rValidateAudience = false // 不驗證 Audience (Token接收方)\r};\r// 預設是從 Header 拿 token，如果客戶端用其他方式攜帶 token 例如網址列\r// 就要設置 options.Event 拿取 token 後設置到 MessageReceiveContext 才能抓得到\r})\r// 讓 AP 可使用 CookieAuthenticationDefaults.AuthenticationScheme 作為驗證方法\r.AddCookie(\rCookieAuthenticationDefaults.AuthenticationScheme,\roptions =\u0026gt; {\r// 自訂 Cookie 名稱\roptions.Cookie.Name= \u0026quot;.CookieName\u0026quot;; // 設置未驗證進入點，預設是 /Account/Login\roptions.Cookie.LoginPath = new PathString(\u0026quot;/...\u0026quot;); });\rReference MSDN - Overview of ASP.NET Core authentication MSDN - Microsoft.AspNetCore.Authentication.Cookies Namespace MSDN - CookieAuthenticationOptions Class MSDN - Microsoft.AspNetCore.Authentication.JwtBearer Namespace MSDN - polycy schemes Authentication handler in ASP.Net Core (JWT and Custom) The Will Will Web - 如何在 ASP.NET Core 3 使用 Token-based 身分驗證與授權 (JWT) The Will Will Web - 如何實作沒有 ASP.NET Core Identity 的 Cookie-based 身分驗證機制 ","date":"March 12, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/startup-auth/auth_guild_2/","summary":"\u003ch1 id=\"驗證方案authentication-scheme\"\u003e驗證方案(Authentication Scheme)\u003c/h1\u003e\n\u003cp\u003e驗證方案包含兩個部分：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e驗證處理函式(Authentication handler)，可能是\n\u003ca href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.iauthenticationhandler?view=aspnetcore-3.1\" target=\"_blank\" rel=\"noopener\"\u003eIAuthenticationHandler\u003c/a\u003e 或\n\u003ca href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.authenticationhandler-1?view=aspnetcore-3.1\" target=\"_blank\" rel=\"noopener\"\u003eAuthenticationHandler\u003cTOptions\u003e\u003c/a\u003e\n的實作，相當於驗證方案的\u003cstrong\u003e行為\u003c/strong\u003e，責任範圍涵蓋:\n\u003cul\u003e\n\u003cli\u003e驗證使用者，\u003c/li\u003e\n\u003cli\u003e驗證成功時，建構呈現使用者識別(user identity)的 \u003ca href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.authenticationticket?view=aspnetcore-3.1\" target=\"_blank\" rel=\"noopener\"\u003eAuthenticationTicket\u003c/a\u003e。\u003c/li\u003e\n\u003cli\u003e驗證失敗時，回傳 \u0026rsquo;no result\u0026rsquo; 或 \u0026lsquo;failure\u0026rsquo;\u003c/li\u003e\n\u003cli\u003e負責從請求上下文(request context)中建構使用者識別 (user identity)。\u003c/li\u003e\n\u003cli\u003e定義了 challenge/forbid action。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e驗證處理函式的設定選項(Opitons of Authentication handler)。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e驗證方案當中的 authencate action 負責從請求上下文(request context)中建構使用者識別 (user identity)，\n常見的例子為：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ecookie authentication scheme\u003c/strong\u003e 從 cookie 資訊建構 user identity.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eJWT bearer scheme\u003c/strong\u003e 反序列化(deserialize)、驗證(validate) token，並從 token 所攜帶資訊建構 user identity\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"使用驗證方案\"\u003e使用驗證方案\u003c/h2\u003e\n\u003cp\u003e在 Startup.ConfigureServices 以 AddAuthentication 註冊驗證服務時會回傳一個 AuthenticationBuilder，\nAuthenticationBuilder 設定驗證方案的方式有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e呼叫 \u003cstrong\u003escheme-specific 擴充方法\u003c/strong\u003e，例如 AddJwtBearer、AddCookie，這些擴充方法會自動呼叫 AuthenticationBuilder.AddScheme 設定需要的驗證方式。\u003c/li\u003e\n\u003cli\u003e以 AuthenticationBuilder \u003cstrong\u003e內建方法 AddScheme\u003c/strong\u003e 手動設定，一般來說較少使用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eP.S.另外可使用 \u003ca href=\"https://docs.microsoft.com/zh-tw/aspnet/core/security/authentication/policyschemes?view=aspnetcore-3.1\" target=\"_blank\" rel=\"noopener\"\u003epolycy schemes\u003c/a\u003e 把多個 scheme 整合到一個使用。\u003c/p\u003e","tags":null,"title":"[.NET Core] ASP .NET Core 3.1 驗證與授權(二)-驗證設定"},{"categories":null,"contents":"找 @BotFather 對話打 /newbot，設定 name username，然後就會拿到 API token\nReferance Github-TelegramBots/Telegram.Bot Telegram.Bot-Documentation Telegram Bot API ","date":"January 29, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/other/telegram-bot/","summary":"\u003cp\u003e找 @BotFather 對話打 /newbot，設定 name username，然後就會拿到 API token\u003c/p\u003e\n\u003ch2 id=\"referance\"\u003eReferance\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/TelegramBots/Telegram.Bot\" target=\"_blank\" rel=\"noopener\"\u003eGithub-TelegramBots/Telegram.Bot\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://telegrambots.github.io/book/\" target=\"_blank\" rel=\"noopener\"\u003eTelegram.Bot-Documentation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://core.telegram.org/bots/api\" target=\"_blank\" rel=\"noopener\"\u003eTelegram Bot API\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[Bot] Telegram bot"},{"categories":null,"contents":"重新編譯 gdrive 取得憑證 首先到Google API Console， 建立專案 啟動 Google Drive API。 啟用之後選擇左邊的\u0026quot;設定同意畫面\u0026quot;，填寫必要的欄位其他依照需求設置就好 建立一組 OAth2 憑證，會有 Client ID 和 Secret 編譯專案 1.安裝 Golang 2.下載 gdrive 專案 git clone git@github.com:prasmussen/gdrive.git\r3.修改專案下的handlers_drive.go，把下列兩行改成拿到的 Client ID、Secret const ClientId = \u0026quot;*************************************.com\u0026quot;\rconst ClientSecret = \u0026quot;*************\u0026quot;\r4.取得需要的 golang 套件 go get github.com/prasmussen/gdrive\r5.到專案資料夾下編譯，編譯完後就會有得到執行檔 go build\r設定 設置環境變數 將編譯好的執行檔上傳Linux，假設放在${HOME}/gdrive-linux-x64：\n# 建立${HOME}/bin\r$ mkdir -p ${HOME}/bin\r# 把gdrive-linux-x64放進去重新命名為gdrive\r$ mv ${HOME}/gdrive-linux-x64 ${HOME}/bin/gdrive\r# 賦予gdrive執行權限\r$ chmod u+x ${HOME}/bin/gdrive\r# 如果PATH裡面找不到${HOME}/bin就新增並重新讀取環境設定\r$ echo ${PATH} | grep -qE ${HOME}/bin[^/] \u0026amp;\u0026amp; \\\r\u0026gt; echo \u0026quot;PATH=\\${HOME}/bin:\\${PATH}\u0026quot; \u0026gt;\u0026gt; ~/.bashrc \u0026amp;\u0026amp; \\\r\u0026gt; . ~/.bashrc\r連結google帳戶 安裝好Google drive CLI後需要取得雲端硬碟帳戶授權，gdrive預設會在${HOME}/.gdrive底下找授權檔， 由於目前我們沒有任何授權，所以需要先下簡單的指令觸發token請求， 取得token之後會出現一個檔案叫做${HOME}/.gdrive/token_v2.json， 並且在終端機出現雲端硬碟所有檔案及資料夾清單(預設最多出現30筆)：\n# 以list命令觸發token請求\r# 這裡會得到一個網址，貼到瀏覽器的網址列enter，之後選擇你要連結的帳戶，按照步驟授權後貼上授權碼，成功的話就會出現清單。\r$ gdrive list\rAuthentication needed\rGo to the following url in your browser:\rhttps://accounts.google.com/o/oauth2/auth?access_type=offline\u0026amp;client_id=...\rEnter verification code:7/4wDh2A_4vtaFR9JibaVC-l-lv2sV7SSCj0QsWL-J2-mcTGY9xrTi9rU\r使用 查詢檔案 gdrive除了一些特殊資料夾，像是根目錄沒有ID直接叫做root之外， 對於檔案跟資料夾的操作都基於id，而獲得檔案與資料夾id常用的方式有三種：\n從資料夾網址觀察id：https://drive.google.com/drive/u/1/folders/1D8kkabcEecxxxxxxNSAy8ho97gTRuyNa 對檔案右鍵後選擇\u0026quot;取得檔案共用連結，貼到文字編輯器觀察id：https://drive.google.com/open?id=1QJUxAzep1s4xxxxxxxUWUxf1H3KBrTNO 透過gdrive list指令配合搜尋參數(重要！可參閱文件)查詢，就是以下要介紹的方法。 查詢雲端檔案清單 # 列出雲端硬碟最上層資料夾(root)的內容\r$ ./gdrive-linux-x64 list -q \u0026quot;'root' in parents\u0026quot;\rId Name Type Size Created\r1zY5UMnx-xxxxxxfuetg7cyrY5MU-k8w4 tmp dir 2018-05-29 02:32:33\r1D8kkabcEecxxxxxxNSAy8ho97gTRuyNa Backup dir 2018-03-27 05:14:21\r1gFOCwss-xxxxxxKF5td-g-Ovj_z4JoEcqpVHq1t5u4Y Google 相簿 dir 2017-07-07 14:02:17\r# 列出特定資料夾的內容，1D8kkabcEecxxxxxxNSAy8ho97gTRuyNa是資料夾id\r$ ./gdrive-linux-x64 list -q \u0026quot;'1D8kkabcEecxxxxxxNSAy8ho97gTRuyNa' in parents\u0026quot;\rId Name Type Size Created\r1sqZTRRd5ucxxxxxx7l4ApnlLs4kVOsyF note0001 bin 196.0 B 2018-07-18 06:41:12\r1V-CvduOE9exxxxxxAflObt2wbGbD49zz note0002 bin 199.0 B 2018-07-18 06:41:11\r1SOq0opXxXQxxxxxxiCy5eY3ivO-KFVLy back dir 2018-07-18 06:40:56\r1tyJcRaO9Dfxxxxxxo6yvndSkr8zpos_D test.sh bin 4.6 KB 2018-07-18 06:38:25\r上傳/下載 下載 # 下載某個檔案\r$ gdrive download 1tyJcRaO9Dfxxxxxxo6yvndSkr8zpos_D\rDownloading myTestFile1 -\u0026gt; myTestFile1\rDownloaded 1tyJcRaO9Dfxxxxxxo6yvndSkr8zpos_D at 402.0 B/s, total 402.0 B\r# 下載整個資料夾\r$ gdrive download -r 1D8kkabcEecxxxxxxNSAy8ho97gTRuyNa\rDownloading myTestFile1 -\u0026gt; myTestFolder /myTestFile1\rDownloading myTestFile2 -\u0026gt; myTestFolder /myTestFile2\rDownloading myTestFile3 -\u0026gt; myTestFolder /myTestFile3\rDownloading myTestFile4 -\u0026gt; myTestFolder /myTestFile4\r上傳 # 上傳某個檔案到某個資料夾\r$ gdrive upload -p 1D8kkabcEecxxxxxxNSAy8ho97gTRuyNa myTestFile4\rUploading myTestFile5\rUploaded 1tyJcRaO9Dfxxxxxxo6yvndSkr8zpos_D at 87.8 KB/s, total 151.3 KB\r# 上傳整個資料夾到某個資料夾底下\r$ gdrive upload -r -p 1D8kkabcEecxxxxxxNSAy8ho97gTRuyNa myTestFolder\rCreating directory myTestFolder\rUploading myTestFolder/myTestFile1\rUploading myTestFolder/myTestFile2\rUploading myTestFolder/myTestFile3\rUploading myTestFolder/myTestFile4\r資料夾同步 資料夾同步到雲端 # 建立一個空資料夾並上傳雲端，作為雲端同步資料夾\r$ mkdir syncTest\r$ gdrive upload -r syncTest\r# 查詢剛剛上傳的空資料夾ID\r$ gdrive -q \u0026quot;name = 'syncTest'\u0026quot;\rId Name Type Size Created\r1Uv5MxUXcxxxxxxcjM2nT_3hcuz-SMNnV syncTest dir 2019-02-18 09:52:26\r# 把本地資料夾的內容同步到雲端\r$ gdrive sync upload local_folder 1Uv5MxUXcxxxxxxcjM2nT_3hcuz-SMNnV\rStarting sync...\rCollecting local and remote file information...\rFound 7 local files and 0 remote files\r1 remote directories are missing\r[0001/0001] Creating directory syncTest/ae006468\r6 remote files are missing\r[0001/0006] Uploading ae006468/0.error -\u0026gt; syncTest/ae006468/0.error\r...\rSync finished in 13.435891267s\r雲端同步到資料夾 # 建立一個空資料夾準備接收雲端資料\r$ mkdir syncTest2\r# 把雲端內容同步到本地資料夾\r$ gdrive sync download 1Uv5MxUXcxxxxxxcjM2nT_3hcuz-SMNnV syncTest2\rStarting sync...\rCollecting file information...\rFound 0 local files and 7 remote files\r1 local directories are missing\r[0001/0001] Creating directory syncTest2/ae006468\r6 local files are missing\r[0001/0006] Downloading ae006468/result.ok -\u0026gt; syncTest2/ae006468/result.ok\rSync finished in 7.269982268s\rReference 底棲生物的生物資訊筆記 - [Google] 用Linux CLI操作google drive雲端硬碟 GitHub - prasmussen/gdrive Mount Google Drive using GDrive on Linux Server with Own OAuth Credentials ","date":"January 29, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/other/linux-gdrive-cli/","summary":"\u003ch1 id=\"重新編譯-gdrive\"\u003e重新編譯 gdrive\u003c/h1\u003e\n\u003ch2 id=\"取得憑證\"\u003e取得憑證\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e首先到\u003ca href=\"https://console.developers.google.com/apis/dashboard\" target=\"_blank\" rel=\"noopener\"\u003eGoogle API Console\u003c/a\u003e，\u003c/li\u003e\n\u003cli\u003e建立專案\u003c/li\u003e\n\u003cli\u003e啟動 Google Drive API。\u003c/li\u003e\n\u003cli\u003e啟用之後選擇左邊的\u0026quot;設定同意畫面\u0026quot;，填寫必要的欄位其他依照需求設置就好\u003c/li\u003e\n\u003cli\u003e建立一組 OAth2 憑證，會有 Client ID 和 Secret\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"編譯專案\"\u003e編譯專案\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e1.安裝 \u003ca href=\"https://golang.org/dl/\" target=\"_blank\" rel=\"noopener\"\u003eGolang\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e2.下載 gdrive 專案\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit clone git@github.com:prasmussen/gdrive.git\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e3.修改專案下的\u003ccode\u003ehandlers_drive.go\u003c/code\u003e，把下列兩行改成拿到的 Client ID、Secret\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003econst ClientId = \u0026quot;*************************************.com\u0026quot;\r\nconst ClientSecret = \u0026quot;*************\u0026quot;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e4.取得需要的 golang 套件\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ego get github.com/prasmussen/gdrive\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e5.到專案資料夾下編譯，編譯完後就會有得到執行檔\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ego build\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"設定\"\u003e設定\u003c/h1\u003e\n\u003ch2 id=\"設置環境變數\"\u003e設置環境變數\u003c/h2\u003e\n\u003cp\u003e將編譯好的執行檔上傳Linux，假設放在${HOME}/gdrive-linux-x64：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 建立${HOME}/bin\r\n$ mkdir -p ${HOME}/bin\r\n# 把gdrive-linux-x64放進去重新命名為gdrive\r\n$ mv ${HOME}/gdrive-linux-x64 ${HOME}/bin/gdrive\r\n# 賦予gdrive執行權限\r\n$ chmod u+x ${HOME}/bin/gdrive\r\n\r\n# 如果PATH裡面找不到${HOME}/bin就新增並重新讀取環境設定\r\n$ echo ${PATH} | grep -qE ${HOME}/bin[^/] \u0026amp;\u0026amp; \\\r\n\u0026gt; echo \u0026quot;PATH=\\${HOME}/bin:\\${PATH}\u0026quot; \u0026gt;\u0026gt; ~/.bashrc \u0026amp;\u0026amp; \\\r\n\u0026gt; . ~/.bashrc\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"連結google帳戶\"\u003e連結google帳戶\u003c/h2\u003e\n\u003cp\u003e安裝好Google drive CLI後需要取得雲端硬碟帳戶授權，gdrive預設會在${HOME}/.gdrive底下找授權檔，\n由於目前我們沒有任何授權，所以需要先下簡單的指令觸發token請求，\n取得token之後會出現一個檔案叫做${HOME}/.gdrive/token_v2.json，\n並且在終端機出現雲端硬碟所有檔案及資料夾清單(預設最多出現30筆)：\u003c/p\u003e","tags":null,"title":"[Tools] 在 linux 中使用 google drive cli"},{"categories":null,"contents":"Promise Promise 狀態 Promise function 執行後會立即回傳一個稱為 Promise 的物件， Promise 本身帶有三種狀態：\npending: 已初始化，但尚未成功或失敗。 fulfilled: 操作成功完成。 rejected: 操作失敗結束。 promise 一但被回傳就處於 pending 狀態， promise 的建構式有兩個參數個接收一個 function，可以操作 Promise 的 fulfilled 和 rejected。\n// resolve(value): 放入解析的值\r// reject(reson): 放入拒絕的理由\rfunction test(value){\rlet reason = '找不到 value'\rreturn new Promise((resolve, reject)=\u0026gt;{\rvalue ? resolve(value) :reject(reason)\r})\r}\r將 Promise 繫結回呼函式 若要將某個程式語句安排在 Promise 被滿足之後執行。 可以利用 Promise.prototype 上的三個物件方法(Instance Method)方法繫結回呼函式(callback function)： then catch finally resolve 會被 then 捕獲，reject 會被最近的 catch 捕獲\n管理多個同時執行的 Promise 假設需要同時控管多個需要等待的函數， 讓這些函數都回傳 promise， 判斷這些 promise function 其中一個/全部滿足某某狀態時就進行什麼動作， Promise 上定義的靜態方法(Static Method)常被用來對一個以上的 Promise 進行一波騷操作：\nPromise.All(iterable): iterable 中的 promise 皆被滿足時，Promise.All 本身回傳的 Promise 被滿足。 Promise.allSettled(iterable) Promise.any(iterable) Promise.race(iterable) Promise.resolve(value) Promise.reject(reason) 這兩個方法結合，比起 Promise 建構子能夠更優雅的回傳 Promise：\nfunction test(value){\rlet reason = '找不到 value'\rreturn value ? Promise.resolve(value)\r: Promise.reject(reason);\r}\r將 Promise 操作序列同步化(Async/Await) async 是 promise 的語法糖，標記 async 的 function 本身會自動回傳 promise， 如過有回傳值就發生 resolved 函式；如果收到丟出的錯誤就放進 reject 往外傳遞。 async function 中可以使用 await 等待 promise 被 fulfilled 或 rejected， 使用 await 等待 promise 使函式行為同步化，也可以直接得到 resolve 當中的回傳值或 reject 中擲出的錯誤。 await 一個函式會得到 resolve 或 reject 的結果\nasync function test(value){\rif(value) return value\rthrow '找不到 value'\r}\r如此一來就可以取代以串接 .then() 安排程式執行順序，可以顯著減少 callback 的情況讓程式碼變乾淨。 javascript 沒有 top level await，所以無法在 async function 以外的地方使用 await。\n搭配 try/catch 使用 Reference JavaScript 同步延遲 ( Promise + setTimeout ) 簡單理解 JavaScript Async 和 Await 從 Promise 開始的 JavaScript 異步生活 JavaScript Promise 迷你書（ 中文版 ) MDN - Promise MDN - Using Promises ","date":"January 9, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/javascript/js-async/","summary":"\u003ch1 id=\"promise\"\u003ePromise\u003c/h1\u003e\n\u003ch2 id=\"promise-狀態\"\u003ePromise 狀態\u003c/h2\u003e\n\u003cp\u003ePromise function 執行後會立即回傳一個稱為 Promise 的物件，\nPromise 本身帶有三種狀態：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epending: 已初始化，但尚未成功或失敗。\u003c/li\u003e\n\u003cli\u003efulfilled: 操作成功完成。\u003c/li\u003e\n\u003cli\u003erejected: 操作失敗結束。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003epromise 一但被回傳就處於 pending 狀態，\npromise 的建構式有兩個參數個接收一個 function，可以操作 Promise 的 fulfilled 和 rejected。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// resolve(value): 放入解析的值\r\n// reject(reson): 放入拒絕的理由\r\nfunction test(value){\r\n  let reason  = '找不到 value'\r\n  return new Promise((resolve, reject)=\u0026gt;{\r\n    value ? resolve(value) :reject(reason)\r\n  })\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"將-promise-繫結回呼函式\"\u003e將 Promise 繫結回呼函式\u003c/h2\u003e\n\u003cp\u003e若要將某個程式語句安排在 Promise 被滿足之後執行。\n可以利用 Promise.prototype 上的三個物件方法(Instance Method)方法繫結回呼函式(callback function)：\nthen catch finally\nresolve 會被 then 捕獲，reject 會被最近的 catch 捕獲\u003c/p\u003e","tags":null,"title":"[JS] 非同步程式設計-Promise 與 Async/Await"},{"categories":null,"contents":"網路上時常見到充滿 function 與 var 的 JavaScript 求值題目， 筆者在釐清 Hoisting 和 TDZ 的觀念前時常覺得答案出乎意料， 雖然現在撰寫程式碼都已經避免使用 var，但是維護 legacy code 還是會用到，因此在這裡做個筆記。\nHoisting 對學過伺服器端語言(C#、C/C++\u0026hellip;)的人來說，預期試圖對未宣告的變數取值會出現 ReferenceError是很正常的事， 在 JavaScript 中也是如此：\nconsole.log(x) // ReferenceError: x is not defined\r但 JavaScript 把 var 宣告變數放在後面，x 前面對 x 取值就變成 undefine， 在 JavaScript 當中對變數取值獲得 undefine 代表變數處於宣告後已分配記憶體空間(初始化、initiation)但尚未賦值的狀態， 但是明明 JavaScript 在宣告前就取值，怎麼能夠認得 x、而且知道 x 被初始化為 undefined 呢？\nconsole.log(x) // undefined\rvar x\r原因在於 javascript 會先程式中的蒐集 var(let/const/function) 宣告並釐清對應的作用域， 最後再執行程式碼，這個行為就如同宣告被提升(Hoisting)到前面行數的程式碼中一樣。\nJavaScript 跟傳統 OOP 語言一樣，在變數提升後、宣告初始化、賦值等等時機取用變數會獲得不同輸出結果， 這篇文章(link)中提到， 稱 JavaScript 為直譯式(解釋型)語言實際上是通俗的說法，語言本身沒有規定實現的方式(編/直譯)， 舉例來說 Chrome 瀏覽器所使用的 Google V8 JavaScript engine， 所帶的解釋器 (interpreter) 會將程式編譯 (compile) 成字節碼 (bytecode)， 最後再由編譯器 (compiler) 即時編譯 (JIT;just-in-time compilation) 編譯成機器碼執行， 而 JavaScript 被編譯時宣告會被蒐集到最頂端進行定義並區分作用域(scope)，這個行為就是 Hoisting ，記住重點在於JS編譯後會先定義變數及區分作用域，編譯後的程式看起來就像這樣：\n在 global scope 定義變數 xxx\r在 global scope 定義變數 xxx\r在 global scope 定義函式 xxx\r在 global scope 定義函式 xxx\r在 xxx scope 定義變數 xxx\r在 bbb scope 定義變數 xxx\r在 abc scope 定義函式 xxx\r開始執行程式碼：...\rHoisting 有別 用 var、let、const、function 宣告變數或函式都會獲得提升， 但對於能否初始化、以及變數被歸類的作用域有所分別， var 宣告的變數會被初始化為 undefined，而 let 與 const 的宣告不會被初始化為 undefined， 對比如下：\n宣告方式 作用域 提升時初始化 備註 var global 有(undefined) 初始化為 undefined let locale - 只有 let 宣告的變數會發生沒有被初始化的情況 const locale 不需要 合法的 const 宣告本身就必須包含初始化 function locale 不需要 直接以宣告的函式作為初始值 較常疏忽的一點：錯將 function expression 的賦值當成函式宣告(function declaration)， 兩者的差異：\nfunction declaration: 受惠於函式宣告，第1行 x 同時會被提升且初始化為函式，因此第一行可得到結果\u0026rsquo;x\u0026rsquo;； console.log(x()) // 'x'\rfunction x(){\rreturn 'x'\r}\rfunction expression: 第2行以 function expression 得到的 function reference 作為右值賦值給 x， x 提升的行為就像一般以 var 宣告的變數一樣，提升時只會被初始化為是 undefine 直到第2行才獲得賦值， 因此第2行後才能透過 x 呼叫所指涉的函示，下面第1行可看到時 x 是 undefined，第2行嘗試將 undefined 視為函式呼叫獲得錯誤： console.log(x) // undefined\rconsole.log(x()) // Uncxught TypeError: x is not a function\rvar x = function(){\rreturn 'x'\r}\r執行環境 Execution Context js 引擎開始執行程式碼時會建立一個全域執行環境(Global Execution Content)，內容包含：\n全域物件(global object) 指向全域物件本身的指標 this 指向上層外部環境的參考 outer environment reference，但全域環境已是最外層 存放變數、函式的記憶體空間 而在瀏覽器當中 globel object 就等於 window，所以若是宣告於全域的變數或函式，會成為 global object 的屬性：\n// 瀏覽器中，window === global object:\rconsole.log(this === window); // true\r// 宣告於全域的變數或函式，會成為 global object (window)的屬性：\rvar a = 'a'\rfunction f(){}\rwindow.a\r\u0026quot;a\u0026quot;\rwindow.f\rƒ f(){}\r當js引擎執行程式遇到函式呼叫時，會為函式建立函式所屬的執行環境，稱為作用域環境(lexical environment)， 而作用域執行環境也有屬於自己的物件、外部環境參考等等\u0026hellip; 函式內的程式可以同時存取全域執行環境內的全域物件和作用域環境的物件， 而內層的作用域環境優先權在外層執行環境(例如：全域執行環境)之上， 這個現象稱為執行堆疊 (Execution stack)， 而程式藉由外部環境參考向外搜尋可用資源的過程像鍊條一般環環相扣稱為範圍練 (Scope Chain)。\n在函式內宣告的 x 變數會作用範圍會被侷限在作用域環境內， 當函式執行時存取權會優先於全域執行環境中的 x 變數：\nfunction a() {\r// 使用 a 執行環境當中定義的 x\rvar x = 'a';\rconsole.log(`a(): ${x}`);\rb();\r}\rfunction b() {\r// b 當中未定義 x 因此透過外部環境參考往外取得全域執行環境當中的 x\rconsole.log(`b(): ${x}`);\r}\rvar x = 'x';\ra();\r// a(): a\r// b(): x\r執行環境的所屬階層是以函式建立的位置為準， 如果在最外層定義那麼外部環境參考就是指向 global object， 如果是函式內再定義函式，那麼內層函式的外部環境就是外層函式所創造的作用域環境：\nfunction a(){\rvar x = 'a'\rfunction b(){\r// b 在 a 當中被定義，因此外層環境為 a，取 x 會變成 'a'\rconsole.log(`b(): ${x}`);\r}\rconsole.log(`a(): ${x}`);\rb()\r}\rvar x = 'x';\ra()\r// a(): a\r// b(): a\r各時機取值 變數有生命週期，包含提升後(Hoisted)、宣告Declaration、初始化(分配記憶體空間)Initiation、賦值Assignment， 而在編譯器進行這些行為的時間點前後取值的結果是可以預測的：\n附帶一提，對沒有宣告的變數取值會獲得 ReferenceError: x is not defined：\nconsole.log(x)\r// ReferenceError: x is not defined\rTemporal Dead Zone let/const 會發生提升，但 let 的提升不會初始化(分配記憶體空間)為 undefined， 剛剛提到 let 宣告會被提升到頂端但不會初始化， 所以在提升位置到宣告語句(不是賦值喔)中間的區域如果對取值會發生錯誤， 這個區域稱為暫時性死區(TDZ;Temporal Dead Zone)：\nfunction a(){\r// a 被編譯器提升到這裡(作用域環境的頂端)，a 的 TDZ 從這裡開始...\rconsole.log(a) // TDZ 區域中，a只有被宣告而未被初始化，所以得到錯誤，可參考參照取值結果表\rlet a // a 的 TDZ 結束\ra = 10\r}\ra()\r// Uncaught ReferenceError: Cannot access 'a' before initialization...\r我們可以在宣告之後取值做測試，a 的確被初始化為 undefined：\nfunction a(){\r// a 的 TDZ 從這裡開始...\rlet a // 這裡 a 初始化成為 undefined\rconsole.log(a)\ra = 10\r} a()\r// undefined\rNote Medium - Javascript執行環境 (Execution Context)簡介 TechBridge 技術共筆部落格 - 我知道你懂 hoisting，可是你了解到多深？ MSDN - Hoisting 虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩 Hoisting in JavaScript JavaScript and the Inner Workings of your Browser ","date":"January 9, 2021","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/javascript/js-hoisting/","summary":"\u003cp\u003e網路上時常見到充滿 function 與 var 的 JavaScript 求值題目，\n筆者在釐清 Hoisting 和 TDZ 的觀念前時常覺得答案出乎意料，\n雖然現在撰寫程式碼都已經避免使用 var，但是維護 legacy code 還是會用到，因此在這裡做個筆記。\u003c/p\u003e\n\u003ch1 id=\"hoisting\"\u003eHoisting\u003c/h1\u003e\n\u003cp\u003e對學過伺服器端語言(C#、C/C++\u0026hellip;)的人來說，預期試圖對未宣告的變數取值會出現 ReferenceError是很正常的事，\n在 JavaScript 中也是如此：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econsole.log(x) // ReferenceError: x is not defined\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但 JavaScript 把 var 宣告變數放在後面，x 前面對 x 取值就變成 undefine，\n在 JavaScript 當中對變數取值獲得 undefine 代表變數處於宣告後\u003cstrong\u003e已分配記憶體空間(初始化、initiation)\u003cstrong\u003e但\u003c/strong\u003e尚未賦值\u003c/strong\u003e的狀態，\n但是明明 JavaScript 在宣告前就取值，怎麼能夠認得 x、而且知道 x 被初始化為 undefined 呢？\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econsole.log(x) // undefined\r\nvar x\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e原因在於 javascript 會先程式中的蒐集 var(let/const/function) 宣告並釐清對應的作用域，\n最後再執行程式碼，這個行為就如同宣告被提升(Hoisting)到前面行數的程式碼中一樣。\u003c/p\u003e\n\u003cp\u003eJavaScript 跟傳統 OOP 語言一樣，在變數提升後、宣告初始化、賦值等等時機取用變數會獲得不同輸出結果，\n這篇文章(\u003ca href=\"https://www.iteye.com/blog/rednaxelafx-492667\" target=\"_blank\" rel=\"noopener\"\u003elink\u003c/a\u003e)中提到，\n稱 JavaScript 為直譯式(解釋型)語言實際上是通俗的說法，語言本身沒有規定實現的方式(編/直譯)，\n舉例來說 Chrome 瀏覽器所使用的 Google V8 JavaScript engine，\n所帶的解釋器 (interpreter) 會將程式編譯 (compile) 成字節碼 (bytecode)，\n最後再由編譯器 (compiler) 即時編譯 (JIT;just-in-time compilation) 編譯成機器碼執行，\n而 JavaScript 被編譯時宣告會被蒐集到最頂端進行定義並區分作用域(scope)，這個行為就是 Hoisting\n，記住重點在於\u003cstrong\u003eJS編譯後會先定義變數及區分作用域\u003c/strong\u003e，編譯後的程式看起來就像這樣：\u003c/p\u003e","tags":null,"title":"[JS] 提升(Hoisting)與暫時性死區(Temporal Dead Zone)"},{"categories":null,"contents":"授權(Authorization) 授權(Authorization): 界定用戶可存取資源範圍的程序。 Policy-based authorization ASP .NET Core 的授權以政策 Policy 進行設定\n自訂授權 RBAC Name 記載使用者識別名稱(User Identity) userData 記載以 | 分隔的使用者角色 Role\n驗證與授權 Challenge、Forbid 中間件順序 先驗證、再授權 The Order of UseAuthentication、UseAuthorization\nReference MSDN - Principal and Identity Objects MSDN - IAuthenticationService Interface MSDN - AuthenticationService Class MSDN - Overview of ASP.NET Core Security MSDN - Overview of ASP.NET Core authentication MSDN - Policy-based authorization in ASP.NET Core MSDN - Microsoft.AspNetCore.Authentication.Cookies Namespace MSDN - Microsoft.AspNetCore.Authentication.JwtBearer Namespace [ASP.NET Core] 加上簡單的Cookie登入驗證 https://blog.johnwu.cc/article/ironman-day11-asp-net-core-cookies-session.html\n","date":"December 31, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/startup-auth/auth_guild_4/","summary":"\u003ch1 id=\"授權authorization\"\u003e授權(Authorization)\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e授權(Authorization): 界定用戶可存取資源範圍的程序。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"policy-based-authorization\"\u003ePolicy-based authorization\u003c/h2\u003e\n\u003cp\u003eASP .NET Core 的授權以政策 Policy 進行設定\u003c/p\u003e\n\u003ch2 id=\"自訂授權\"\u003e自訂授權\u003c/h2\u003e\n\u003ch2 id=\"rbac\"\u003eRBAC\u003c/h2\u003e\n\u003cp\u003eName 記載使用者識別名稱(User Identity)\nuserData 記載以 \u003ccode\u003e|\u003c/code\u003e 分隔的使用者角色 Role\u003c/p\u003e\n\u003ch1 id=\"驗證與授權\"\u003e驗證與授權\u003c/h1\u003e\n\u003ch2 id=\"challengeforbid\"\u003eChallenge、Forbid\u003c/h2\u003e\n\u003ch2 id=\"中間件順序\"\u003e中間件順序\u003c/h2\u003e\n\u003cp\u003e先驗證、再授權\nThe Order of UseAuthentication、UseAuthorization\u003c/p\u003e\n\u003ch1 id=\"reference\"\u003eReference\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/en-us/dotnet/standard/security/principal-and-identity-objects\" target=\"_blank\" rel=\"noopener\"\u003eMSDN - Principal and Identity Objects\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/zh-tw/dotnet/api/microsoft.aspnetcore.authentication.iauthenticationservice?view=aspnetcore-3.1\" target=\"_blank\" rel=\"noopener\"\u003eMSDN - IAuthenticationService Interface\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/zh-tw/dotnet/api/microsoft.aspnetcore.authentication.authenticationservice?view=aspnetcore-3.1\" target=\"_blank\" rel=\"noopener\"\u003eMSDN - AuthenticationService Class\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/zh-tw/aspnet/core/security/?view=aspnetcore-3.1\" target=\"_blank\" rel=\"noopener\"\u003eMSDN - Overview of ASP.NET Core Security\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/en-us/aspnet/core/security/authentication/?view=aspnetcore-3.1\" target=\"_blank\" rel=\"noopener\"\u003eMSDN - Overview of ASP.NET Core authentication\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-3.1\" target=\"_blank\" rel=\"noopener\"\u003eMSDN - Policy-based authorization in ASP.NET Core\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.cookies?view=aspnetcore-5.0\" target=\"_blank\" rel=\"noopener\"\u003eMSDN - Microsoft.AspNetCore.Authentication.Cookies Namespace\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.jwtbearer?view=aspnetcore-5.0\" target=\"_blank\" rel=\"noopener\"\u003eMSDN - Microsoft.AspNetCore.Authentication.JwtBearer Namespace\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dotblogs.com.tw/Null/2020/04/09/162252\" target=\"_blank\" rel=\"noopener\"\u003e[ASP.NET Core] 加上簡單的Cookie登入驗證\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://blog.johnwu.cc/article/ironman-day11-asp-net-core-cookies-session.html\" target=\"_blank\" rel=\"noopener\"\u003ehttps://blog.johnwu.cc/article/ironman-day11-asp-net-core-cookies-session.html\u003c/a\u003e\u003c/p\u003e","tags":null,"title":"[.NET Core] ASP .NET Core 3.1 驗證與授權(四)-授權設定"},{"categories":null,"contents":"前兩篇介紹了驗證、授權在 .NET Core 當中的基本的概念，本節實作 Cookie 驗證的設定、簽發、登出\u0026hellip;\nConfiguration 在 Startup.ConfigureServices 方法中設置驗證方案， 並且可以在 AddCookie 當中設置 CookieAuthenticationOptions(見前一節)\n// 設置 cookie 驗證作為應用程式預設的驗證方案\rservices.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)\r// 將 cookie 服務添加到服務容器當中\r.AddCookie();\r在 Startup.Configure 方法中，呼叫 UseAuthentication、UseAuthorization， 啟用驗證中間件並設置 HttpContext.User 屬性， UseAuthentication 必須在 UseAuthorization 之前，且兩者都必須在 UseEndpoints 之前被呼叫：\napp.UseAuthentication(); // 驗證\rapp.UseAuthorization(); // 授權\r// 端點對應\rapp.UseEndpoints(endpoints =\u0026gt;\r{\rendpoints.MapControllers();\rendpoints.MapRazorPages();\r});\rCookie Policy Middleware 在中間件當中設置的驗證政策會作用於全域(每個請求)， 舉例來說，最常用的就是限制應用程式所有 Cookie 的 SameSite 屬性， 所有 Controller 簽發的 Cookie.SamSite 屬性會被限縮為較嚴格(不比 MinimumSameSitePolicy 寬鬆)的設置：\napp.UseCookiePolicy(new CookiePolicyOptions {\r// 所有 Cookie.SamSite 設置都會被提升為 Strict\rMinimumSameSitePolicy = SameSiteMode.Strict, // Cookie.SamSite 設置為 None 的話會被提升為 Lax\r//MinimumSameSitePolicy = SameSiteMode.Lax, // MinimumSameSitePolicy 設置為最寬鬆，因此不會影響 Cookie.SamSite\r//MinimumSameSitePolicy = SameSiteMode.None, });\rCreate an authentication cookie .NET Core 利用 ClaimsPrincipal 將序列化的使用者資訊儲存在 Cookie 當中 而 ClaimsPrincipal 可包含很多 ClaimsIdentity(但通常只有一個)； ClaimsIdentity 可以且通常包含很多 Claims(聲明)， 而每個 Claims 是包含型別(ClaimType)、值(ClaimValue)。 因此為登入使用者建立 Cookie 驗證的步驟如下：\n建構 ClaimsPrincipal、ClaimsIdentity、Claims 呼叫 SignInAsync 為 http 回應加上一個帶有使用者資訊的加密 cookie var claims = new List\u0026lt;Claim\u0026gt; {\rnew Claim(ClaimTypes.Name, user.Email),\rnew Claim(\u0026quot;FullName\u0026quot;, user.FullName),\rnew Claim(ClaimTypes.Role, \u0026quot;Administrator\u0026quot;),\r};\rvar claimsIdentity = new ClaimsIdentity(\rclaims, CookieAuthenticationDefaults.AuthenticationScheme);\rawait HttpContext.SignInAsync(\r// 如果沒有在 SignInAsync 指定 AuthenticationScheme，會使用預設值\rCookieAuthenticationDefaults.AuthenticationScheme, new ClaimsPrincipal(claimsIdentity), new AuthenticationProperties {\r// 這裡可以自訂驗證選項...\r// 是否可自動更新 Cookie(時效?)\r//AllowRefresh = \u0026lt;bool\u0026gt;,\r// IsPersistent 設置 Persistent cookies，否則瀏覽器 session 關閉就失效\r//IsPersistent = true, // Persistent cookie 可進一步設置失效時間：\r//ExpiresUtc = DateTimeOffset.UtcNow.AddMinutes(10),\r//IssuedUtc = \u0026lt;DateTimeOffset\u0026gt;,\r//RedirectUri = \u0026lt;string\u0026gt;\r}\r);\rSign out 登出非常簡單：\nawait HttpContext.SignOutAsync(\rCookieAuthenticationDefaults.AuthenticationScheme);\rP.S. non-persistent cookies 在 瀏覽器(browser) 關閉時會自動清除，但關閉 分頁(tab) 時不會\nReference MSDN - Principal and Identity Objects MSDN - IAuthenticationService Interface MSDN - AuthenticationService Class MSDN - Use cookie authentication without ASP.NET Core Identity [ASP.NET Core] 加上簡單的Cookie登入驗證 Authentication handler in ASP.Net Core (JWT and Custom) ","date":"December 30, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/startup-auth/auth_guild_3/","summary":"\u003cp\u003e前兩篇介紹了驗證、授權在 .NET Core 當中的基本的概念，本節實作 Cookie 驗證的設定、簽發、登出\u0026hellip;\u003c/p\u003e\n\u003ch1 id=\"configuration\"\u003eConfiguration\u003c/h1\u003e\n\u003cp\u003e在 Startup.ConfigureServices 方法中設置驗證方案，\n並且可以在 AddCookie 當中設置 CookieAuthenticationOptions(見前一節)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c#\"\u003e// 設置 cookie 驗證作為應用程式預設的驗證方案\r\nservices.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)\r\n// 將 cookie 服務添加到服務容器當中\r\n    .AddCookie();\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 Startup.Configure 方法中，呼叫 UseAuthentication、UseAuthorization，\n啟用驗證中間件並設置 HttpContext.User 屬性，\nUseAuthentication 必須在 UseAuthorization 之前，且兩者都必須在 UseEndpoints 之前被呼叫：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c#\"\u003eapp.UseAuthentication(); // 驗證\r\napp.UseAuthorization(); // 授權\r\n\r\n// 端點對應\r\napp.UseEndpoints(endpoints =\u0026gt;\r\n{\r\n    endpoints.MapControllers();\r\n    endpoints.MapRazorPages();\r\n});\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"cookie-policy-middleware\"\u003eCookie Policy Middleware\u003c/h1\u003e\n\u003cp\u003e在中間件當中設置的驗證政策會作用於全域(每個請求)，\n舉例來說，最常用的就是限制應用程式所有 Cookie 的 SameSite 屬性，\n所有 Controller 簽發的 Cookie.SamSite 屬性會被限縮為較嚴格(不比 MinimumSameSitePolicy 寬鬆)的設置：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c#\"\u003eapp.UseCookiePolicy(new CookiePolicyOptions {\r\n    // 所有 Cookie.SamSite 設置都會被提升為 Strict\r\n    MinimumSameSitePolicy = SameSiteMode.Strict, \r\n    // Cookie.SamSite 設置為 None 的話會被提升為 Lax\r\n    //MinimumSameSitePolicy = SameSiteMode.Lax,  \r\n    // MinimumSameSitePolicy 設置為最寬鬆，因此不會影響 Cookie.SamSite\r\n    //MinimumSameSitePolicy = SameSiteMode.None, \r\n});\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"create-an-authentication-cookie\"\u003eCreate an authentication cookie\u003c/h1\u003e\n\u003cp\u003e.NET Core 利用 ClaimsPrincipal 將序列化的使用者資訊儲存在 Cookie 當中\n而 ClaimsPrincipal 可包含很多 ClaimsIdentity(但通常只有一個)；\nClaimsIdentity 可以且通常包含很多 Claims(聲明)，\n而每個 Claims 是包含型別(ClaimType)、值(ClaimValue)。\n因此為登入使用者建立 Cookie 驗證的步驟如下：\u003c/p\u003e","tags":null,"title":"[.NET Core] ASP .NET Core 3.1 驗證與授權(三)-Cookie 驗證實例"},{"categories":null,"contents":"Identity Objects Principal Objects IPrincipal 物件帶有 IIdentity 物件的參考 可指定 Authentication Scheme 獲得 Identity\nIAuthenticationService SignOutAsync 清除 Cookie 的 Claims 在 Cookie 寫入 Claims\nToken 登入 登入 API 實作 宣告 ClaimsPrincipal 後，可利用服務容器已注入的認證服務(實作 IAuthencationService 的類別)，進行登入、登出。 使用 SignInAsync 方法登入(寫入認證資訊)需要這些東西：\nClaimsPrincipal(必要)，我們需要 ClaimsPrincipal 攜帶 ClaimsIdentity 及 Claims。 AuthenticationScheme string (Optional)可指定 Scheme，若沒有給就是使用預設的 Scheme。 authProperties (Optional)，可指定自訂認證選項 AuthenticationHttpContextExtensions AuthenticationHttpContextExtensions 類別對 HttpContext 類別擴展出認證方法， 從服務容器中獲取 IAuthenticationService 實體類別，並調用同名方法。\nIAuthenticationService SignOutAsync 清除 Cookie 的 Claims 可儲存 ClaimsPrincipal進行簽發(登入)認證，作為身分識別。\n","date":"November 23, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/startup-auth/auth_guild_memo/","summary":"\u003ch2 id=\"identity-objects\"\u003eIdentity Objects\u003c/h2\u003e\n\u003ch2 id=\"principal-objects\"\u003ePrincipal Objects\u003c/h2\u003e\n\u003cp\u003eIPrincipal 物件帶有 IIdentity 物件的參考\n可指定 Authentication Scheme 獲得 Identity\u003c/p\u003e\n\u003ch2 id=\"iauthenticationservice\"\u003eIAuthenticationService\u003c/h2\u003e\n\u003cp\u003eSignOutAsync 清除 Cookie 的 Claims\n在 Cookie 寫入 Claims\u003c/p\u003e\n\u003ch2 id=\"token-登入\"\u003eToken 登入\u003c/h2\u003e\n\u003ch1 id=\"登入-api-實作\"\u003e登入 API 實作\u003c/h1\u003e\n\u003cp\u003e宣告 ClaimsPrincipal 後，可利用服務容器已注入的認證服務(實作 IAuthencationService 的類別)，進行登入、登出。\n使用 SignInAsync 方法登入(寫入認證資訊)需要這些東西：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eClaimsPrincipal(必要)，我們需要 ClaimsPrincipal 攜帶 ClaimsIdentity 及 Claims。\u003c/li\u003e\n\u003cli\u003eAuthenticationScheme string (Optional)可指定 Scheme，若沒有給就是使用預設的 Scheme。\u003c/li\u003e\n\u003cli\u003eauthProperties (Optional)，可指定自訂認證選項\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"authenticationhttpcontextextensions\"\u003eAuthenticationHttpContextExtensions\u003c/h1\u003e\n\u003cp\u003eAuthenticationHttpContextExtensions 類別對 HttpContext 類別擴展出認證方法，\n從服務容器中獲取 IAuthenticationService 實體類別，並調用同名方法。\u003c/p\u003e\n\u003ch1 id=\"iauthenticationservice-1\"\u003eIAuthenticationService\u003c/h1\u003e\n\u003cp\u003eSignOutAsync 清除 Cookie 的 Claims\n可儲存 ClaimsPrincipal進行簽發(登入)認證，作為身分識別。\u003c/p\u003e","tags":null,"title":"[.NET Core] ASP .NET Core 3.1 驗證與授權(X)-備註頁面"},{"categories":null,"contents":"在進入 ASP .NET Core 3.1 中驗證(Authentication)與授權(Authorization)的作用流程前，應當對兩者有抽象概念上的認識，以及了解兩者的差異。\n驗證(Authentication) 驗證是確認用戶識別碼(User Identity)的程序，通過驗證的用戶可具有一或多個用戶識別碼， 因此驗證服務本身就是使用者識別碼提供者 (User Identity Provider)， ASP.NET Core 3.1 當中以依賴注入(DI; Dependency Injection)將驗證服務注入服務容器 (Service Container)， 使應用程式驗證簽發時能夠取用。\n授權(Authorization) 授權的作用是界定用戶可存取資源範圍，作用描述如下：\n限制所存取的資源是否需要驗證。 已獲得驗證的特定用戶、特定腳色方能存取特定資源。 所存取的資源需要以何種授權政策(Authorizaton Policy)、即驗證方案(Authencation Scheme)。 挑戰和禁止 有些名詞需要先解釋： 驗證方案(Authentication Scheme)當中設置了挑戰(Chellange)與禁止(Forbid)應該進行的動作，這些註冊於驗證方案的動作動作由授權叫用。\n挑戰(Challenge) 未驗證使用者要存取需驗證才能存取的資源時， 授權服務會叫用 IAuthenticationService.ChallengeAsync 發起 challenge， challenge 被發起後所伴隨採取的行動稱為 challenge action， 且 challenge action 應讓使用者知道應該以哪一種驗證機制取得授權，常見的具體範例有：\ncookie 驗證方案將使用者轉址到登入頁面。 JWT 回傳 401 Unauthorized 狀態碼，並在 Header 帶入 www-authenticate: bearer。 禁止(Forbid) 已驗證的使用者要存取授權之外的資源時， 授權會叫用 IAuthenticationService.ForbidAsync 發起 Forbid， Forbid 發起後所伴隨採取的行動稱為 Forbid action， Forbid action 的目的是要讓使用者知道自己已通過認證、且不具權限訪問所請求的資源， 常見的具體範例有：\ncookie 驗證方案：轉址到網站的 Forbidden 頁面。 JWT 驗證方案：回傳 403。 自訂驗證方案：轉址到使用者可存取的特定頁面。 中間件順序 按邏輯必須先進行驗證(身分)、再授權(資源)，因此在 Startup.Configure 當中 middleware 應設定如下：\n// 路由對應(route mapping)，必須在授權之前\rapp.UseRouting();\r// 驗證中間件，以服務容器註冊的驗證服務檢查是否有驗證\rapp.UseAuthentication();\r// 授權中間件，從驗證資訊、路由對應、授權設定判斷是否能夠存取所要求的資源\rapp.UseAuthorization();\r// 進入實際資源存取端點\rapp.UseEndpoints(endpoints =\u0026gt;\r{\r// configure endpoints\r});\rReference MSDN - IAuthenticationService Interface MSDN - AuthenticationService Class MSDN - Overview of ASP.NET Core Security MSDN - Overview of ASP.NET Core authentication ","date":"November 23, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/startup-auth/auth_guild_1/","summary":"\u003cp\u003e在進入 ASP .NET Core 3.1 中驗證(Authentication)與授權(Authorization)的作用流程前，應當對兩者有抽象概念上的認識，以及了解兩者的差異。\u003c/p\u003e\n\u003ch1 id=\"驗證authentication\"\u003e驗證(Authentication)\u003c/h1\u003e\n\u003cp\u003e驗證是確認用戶識別碼(User Identity)的程序，通過驗證的用戶可具有一或多個用戶識別碼，\n因此驗證服務本身就是使用者識別碼提供者 (User Identity Provider)，\nASP.NET Core 3.1 當中以依賴注入(DI; Dependency Injection)將驗證服務注入服務容器 (Service Container)，\n使應用程式驗證簽發時能夠取用。\u003c/p\u003e\n\u003ch1 id=\"授權authorization\"\u003e授權(Authorization)\u003c/h1\u003e\n\u003cp\u003e授權的作用是界定用戶可存取資源範圍，作用描述如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e限制所存取的資源是否需要驗證。\u003c/li\u003e\n\u003cli\u003e已獲得驗證的特定用戶、特定腳色方能存取特定資源。\u003c/li\u003e\n\u003cli\u003e所存取的資源需要以何種授權政策(Authorizaton Policy)、即驗證方案(Authencation Scheme)。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"挑戰和禁止\"\u003e挑戰和禁止\u003c/h1\u003e\n\u003cp\u003e有些名詞需要先解釋：\n驗證方案(Authentication Scheme)當中設置了挑戰(Chellange)與禁止(Forbid)應該進行的動作，這些註冊於驗證方案的動作動作由授權叫用。\u003c/p\u003e\n\u003ch2 id=\"挑戰challenge\"\u003e挑戰(Challenge)\u003c/h2\u003e\n\u003cp\u003e未驗證使用者要存取需驗證才能存取的資源時，\n授權服務會叫用 \u003ca href=\"https://docs.microsoft.com/zh-tw/dotnet/api/microsoft.aspnetcore.authentication.iauthenticationservice.challengeasync?view=aspnetcore-3.1\" target=\"_blank\" rel=\"noopener\"\u003eIAuthenticationService.ChallengeAsync\u003c/a\u003e 發起 challenge，\nchallenge 被發起後所伴隨採取的行動稱為 challenge action，\n且 challenge action 應讓使用者知道應該以哪一種驗證機制取得授權，常見的具體範例有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecookie 驗證方案將使用者轉址到登入頁面。\u003c/li\u003e\n\u003cli\u003eJWT 回傳 401 Unauthorized 狀態碼，並在 Header 帶入 \u003ccode\u003ewww-authenticate: bearer\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"禁止forbid\"\u003e禁止(Forbid)\u003c/h2\u003e\n\u003cp\u003e已驗證的使用者要存取授權之外的資源時，\n授權會叫用 \u003ca href=\"https://docs.microsoft.com/zh-tw/dotnet/api/microsoft.aspnetcore.authentication.iauthenticationservice.forbidasync?view=aspnetcore-3.1\" target=\"_blank\" rel=\"noopener\"\u003eIAuthenticationService.ForbidAsync\u003c/a\u003e 發起 Forbid，\nForbid 發起後所伴隨採取的行動稱為 Forbid action，\nForbid action 的目的是要讓使用者知道自己已通過認證、且不具權限訪問所請求的資源，\n常見的具體範例有：\u003c/p\u003e","tags":null,"title":"[.NET Core] ASP .NET Core 3.1 驗證與授權(一)-驗證與授權"},{"categories":null,"contents":"安裝套件 要進行 Token 的認證，需要先安裝 Microsoft.AspNetCore.Authentication.JwtBearer 套件：\ndotnet add package Microsoft.AspNetCore.Authentication.JwtBearer\r註冊認證服務 新增一個檔案 DependencyInjection.cs，在當中製作 IServiceCollection 的擴充方法來自定義 JWT token 認證服務， 在裡面設置 Token 的認證規則、使用者識別碼對應、使用者群組對應， 而 SignalR 抓取使用者識別碼 (UserIdentifier) 的介面方法是 IUserIdProvider.GetUserId， 因此我們需要另外新增一個實作 IUserProvider 的類別注入服務容器給 SignalR 使用 ，該檔案程式碼如下：\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\rusing Microsoft.AspNetCore.SignalR;\rusing Microsoft.Extensions.Configuration;\rusing Microsoft.Extensions.DependencyInjection;\rusing Microsoft.IdentityModel.Tokens;\rusing System.Diagnostics.CodeAnalysis;\rusing System.IdentityModel.Tokens.Jwt;\rusing System.Linq;\rusing System.Threading.Tasks;\rnamespace SignalR.Extensions.DependencyInjection\r{\rpublic static class MyAddConfig\r{\rpublic static IServiceCollection AddMyJWTAuth(\r[NotNull] this IServiceCollection services,\rIConfiguration config\r)\r{\rservices.AddAuthentication(options =\u0026gt;\r{\r// Identity 預設是使用 Cookie authentication，必須手動設置為 JWT Bearer Auth:\roptions.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\roptions.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\r}).AddJwtBearer(options =\u0026gt;\r{\r// [注意]先解除 MapInboundClaims ，否則會因為套件中某些為向前相容而保留的 legacy code 使得 RoleClaimType 無法生效\r// https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/1214\rif (options.SecurityTokenValidators.FirstOrDefault() is JwtSecurityTokenHandler jwtSecurityTokenHandler)\rjwtSecurityTokenHandler.MapInboundClaims = false;\r// 設置 Token 在授權後是否要儲存於 AuthenticationProperties options.SaveToken = true;\r// 設置各認證參數\roptions.TokenValidationParameters = new TokenValidationParameters\r{\rNameClaimType = \u0026quot;userId\u0026quot;, // 設置 Http 請求的 User.Identity.Name、Hub 中 UserIdentifier 取值的 Claim 是 userId\rRoleClaimType = \u0026quot;roles\u0026quot;, // 設置使用者的腳色從 type=\u0026quot;roles\u0026quot; 的 claims 對應\rValidateLifetime = true, // 認證 Token 有效期間\rValidateIssuerSigningKey = true, //驗證 token 中的 key\rIssuerSigningKey = new SymmetricSecurityKey(System.Text.Encoding.UTF8.GetBytes(config.GetValue\u0026lt;string\u0026gt;(\u0026quot;JWT:SignKey\u0026quot;))), // SignKey\rValidateIssuer = false, // 不驗證簽發者\rValidateAudience = false // 不驗證 Audience (Token接收方)\r};\roptions.Events = new JwtBearerEvents\r{\r// 設定當 OnMessageReceived 事件被觸發時，獲取認證用的 access_token OnMessageReceived = context =\u0026gt;\r{\r// 不同於標準夾帶於 header 的 http token，signalr 會透過網址參數發送 access token // ASP .NET Core 預設會將請求的 URL 皆做成 Log 紀錄，如果不想要網址列的 Token 被 Log 記錄下來必須參考\r// https://docs.microsoft.com/aspnet/core/signalr/security#access-token-logging\rstring accessToken = context.Request.Query[\u0026quot;access_token\u0026quot;];\r// 檢查請求路徑是否為 chathub\rvar path = context.HttpContext.Request.Path;\rif (!string.IsNullOrEmpty(accessToken) \u0026amp;\u0026amp;\r(path.StartsWithSegments(\u0026quot;/chathub\u0026quot;)))\r{\r// 把 token 丟進 MessageReceiveContext 當中\rcontext.Token = accessToken;\r}\rreturn Task.CompletedTask;\r}\r};\r});\rservices.AddSingleton\u0026lt;IUserIdProvider, NameUserIdProvider\u0026gt;();\r// 如果是使用 email claim 作為 user identifier 用下面這行並實作 EmailBasedUserIdProvider\r// services.AddSingleton\u0026lt;IUserIdProvider, EmailBasedUserIdProvider\u0026gt;();\r// NameUserIdProvider 和 EmailBasedUserIdProvider 無法同時使用!!\rreturn services;\r}\r}\r// 實作 SignalR 抓取使用者 Identity 的方法 IUserIdProvider.GetUserId\r// 提供服務容器注入給 SignalR 使用\rpublic class NameUserIdProvider : IUserIdProvider\r{\rpublic string GetUserId(HubConnectionContext connection)\r{\r// 認證設定時設置好 NameClaimType，這裡直接回傳 User.Identity.Name 即可\rreturn connection.User?.Identity?.Name;\r}\r}\r}\r然後在 Startup.cs 當中添加對該類別的引用：\nusing SignalR.Extensions.DependencyInjection;\r在 Startup.ConfigureServices 中使用擴充方法將定義好的 JWT 認證注入 service public void ConfigureServices(IServiceCollection services) { services.AddControllers(); services.AddSignalR(); // 設定 JWT Bearer Auth services.AddMyJWTAuth(Configuration); // 在 service container 當中註冊 JWT Option services.AddOptions\u0026lt;JWTOption\u0026gt;() .Bind(Configuration.GetSection(JWTOption.JWT)); }\n設置驗證中間件 修改 Configure ，在 app.UseAuthorization(); 之前加入 app.UseAuthorization();，順序必須要對，先驗證再授權： app.UseAuthentication(); app.UseAuthorization();\n添加 Hub 驗證屬性 現在不僅可成功添加授權屬性，經上面的設置將 roles claim 對應到使用者腳色，已經可以自動識別使用者群組，方便我們進行 RBAC [Authorize(Roles =\u0026#34;Admin\u0026#34;)] public async Task SendMessage(string user, string message) { await Clients.All.SendAsync(\u0026#34;ReceiveMessage\u0026#34;, user, message); }\n在 Hub 中解析 Claim 在 Hub 的方法內可以這樣取得 Token 相關資訊：\n// 解析\rvar userId = Context.UserIdentifier;\r// 解析 Claims\rvar claims = ((ClaimsIdentity)Context.User.Identity).Claims;\r測試 \u0026hellip;待補\nReference MSDN - Authentication and authorization in ASP.NET Core SignalR 如何在 ASP.NET Core 3 使用 Token-based 身分驗證與授權 (JWT) ASP.NET Core 认证与授权[4]:JwtBearer认证 TokenValidationParameters Class ","date":"November 20, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/startup-signalr/guild_3_validate_token/","summary":"\u003ch1 id=\"安裝套件\"\u003e安裝套件\u003c/h1\u003e\n\u003cp\u003e要進行 Token 的認證，需要先安裝 Microsoft.AspNetCore.Authentication.JwtBearer 套件：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003edotnet add package Microsoft.AspNetCore.Authentication.JwtBearer\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"註冊認證服務\"\u003e註冊認證服務\u003c/h1\u003e\n\u003cp\u003e新增一個檔案 DependencyInjection.cs，在當中製作 IServiceCollection 的擴充方法來自定義 JWT token 認證服務，\n在裡面設置 Token 的認證規則、使用者識別碼對應、使用者群組對應，\n而 SignalR 抓取使用者識別碼 (UserIdentifier) 的介面方法是 IUserIdProvider.GetUserId，\n因此我們需要另外新增一個實作 IUserProvider 的類別注入服務容器給 SignalR 使用\n，該檔案程式碼如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cs\"\u003eusing Microsoft.AspNetCore.Authentication.JwtBearer;\r\nusing Microsoft.AspNetCore.SignalR;\r\nusing Microsoft.Extensions.Configuration;\r\nusing Microsoft.Extensions.DependencyInjection;\r\nusing Microsoft.IdentityModel.Tokens;\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.IdentityModel.Tokens.Jwt;\r\nusing System.Linq;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace SignalR.Extensions.DependencyInjection\r\n{\r\n    public static class MyAddConfig\r\n    {\r\n        public static IServiceCollection AddMyJWTAuth(\r\n            [NotNull] this IServiceCollection services,\r\n            IConfiguration config\r\n            )\r\n        {\r\n\r\n            services.AddAuthentication(options =\u0026gt;\r\n            {\r\n                // Identity 預設是使用 Cookie authentication，必須手動設置為 JWT Bearer Auth:\r\n                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\r\n                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\r\n            }).AddJwtBearer(options =\u0026gt;\r\n            {\r\n                // [注意]先解除 MapInboundClaims ，否則會因為套件中某些為向前相容而保留的 legacy code 使得 RoleClaimType 無法生效\r\n                // https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/1214\r\n                if (options.SecurityTokenValidators.FirstOrDefault() is JwtSecurityTokenHandler jwtSecurityTokenHandler)\r\n                    jwtSecurityTokenHandler.MapInboundClaims = false;\r\n                // 設置 Token 在授權後是否要儲存於 AuthenticationProperties \r\n                options.SaveToken = true;\r\n                // 設置各認證參數\r\n                options.TokenValidationParameters = new TokenValidationParameters\r\n                {\r\n                    NameClaimType = \u0026quot;userId\u0026quot;, // 設置 Http 請求的 User.Identity.Name、Hub 中 UserIdentifier 取值的  Claim 是 userId\r\n                    RoleClaimType = \u0026quot;roles\u0026quot;, // 設置使用者的腳色從 type=\u0026quot;roles\u0026quot; 的 claims 對應\r\n                    ValidateLifetime = true, // 認證 Token 有效期間\r\n                    ValidateIssuerSigningKey = true, //驗證 token 中的 key\r\n                    IssuerSigningKey = new SymmetricSecurityKey(System.Text.Encoding.UTF8.GetBytes(config.GetValue\u0026lt;string\u0026gt;(\u0026quot;JWT:SignKey\u0026quot;))),  // SignKey\r\n                    ValidateIssuer = false, // 不驗證簽發者\r\n                    ValidateAudience = false  // 不驗證 Audience (Token接收方)\r\n                };\r\n\r\n                options.Events = new JwtBearerEvents\r\n                {\r\n                    // 設定當 OnMessageReceived 事件被觸發時，獲取認證用的 access_token \r\n                    OnMessageReceived = context =\u0026gt;\r\n                    {\r\n                        // 不同於標準夾帶於 header 的 http token，signalr 會透過網址參數發送 access token \r\n                        // ASP .NET Core 預設會將請求的 URL 皆做成 Log 紀錄，如果不想要網址列的 Token 被 Log 記錄下來必須參考\r\n                        //  https://docs.microsoft.com/aspnet/core/signalr/security#access-token-logging\r\n                        string accessToken = context.Request.Query[\u0026quot;access_token\u0026quot;];\r\n\r\n                        // 檢查請求路徑是否為 chathub\r\n                        var path = context.HttpContext.Request.Path;\r\n                        if (!string.IsNullOrEmpty(accessToken) \u0026amp;\u0026amp;\r\n                            (path.StartsWithSegments(\u0026quot;/chathub\u0026quot;)))\r\n                        {\r\n                            // 把 token 丟進 MessageReceiveContext 當中\r\n                            context.Token = accessToken;\r\n                        }\r\n                        return Task.CompletedTask;\r\n                    }\r\n                };\r\n            });\r\n\r\n            services.AddSingleton\u0026lt;IUserIdProvider, NameUserIdProvider\u0026gt;();\r\n            // 如果是使用 email claim 作為 user identifier 用下面這行並實作 EmailBasedUserIdProvider\r\n            // services.AddSingleton\u0026lt;IUserIdProvider, EmailBasedUserIdProvider\u0026gt;();\r\n            // NameUserIdProvider 和 EmailBasedUserIdProvider 無法同時使用!!\r\n            return services;\r\n        }\r\n    }\r\n    // 實作 SignalR 抓取使用者 Identity 的方法 IUserIdProvider.GetUserId\r\n    // 提供服務容器注入給 SignalR 使用\r\n    public class NameUserIdProvider : IUserIdProvider\r\n    {\r\n        public string GetUserId(HubConnectionContext connection)\r\n        {\r\n            // 認證設定時設置好 NameClaimType，這裡直接回傳 User.Identity.Name 即可\r\n            return connection.User?.Identity?.Name;\r\n        }\r\n    }\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然後在 Startup.cs 當中添加對該類別的引用：\u003c/p\u003e","tags":null,"title":"[SignalR] Websocket 即時聊天程式(三) - 後端 Token 認證"},{"categories":null,"contents":"安裝 junegunn/vim-plug 管理套件 以指令安裝 junegunn/vim-plug\ncurl -fLo ~/.vim/autoload/plug.vim --create-dirs \\\rhttps://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\r在 ~/.vimrc 加入 Plug \u0026lsquo;ycm-core/YouCompleteMe\u0026rsquo;\n\u0026quot; Specify a directory for plugins\rcall plug#begin('~/.vim/plugged')\rPlug 'ycm-core/YouCompleteMe'\r\u0026quot; Initialize plugin system\rcall plug#end()\r打開 vim，在 vim 命令列輸入安裝 Plugin 的指令下載 YCM，這個時候還沒編譯所以會顯示安裝失敗\n:PlugInstall\r編譯YCM 安裝編譯工具\nsudo apt install -y build-essential cmake vim python3-dev 編譯\n~/.vim/plugged/YouCompleteMe/install.py\r測試 打開 vim 確認，完工~\nReference GitHub - ycm-core/YouCompleteMe GitHub - junegunn/vim-plug ","date":"November 18, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/other/vim-plugin-ycm/","summary":"\u003ch1 id=\"安裝-junegunnvim-plug-管理套件\"\u003e安裝 junegunn/vim-plug 管理套件\u003c/h1\u003e\n\u003cp\u003e以指令安裝 junegunn/vim-plug\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003ecurl -fLo ~/.vim/autoload/plug.vim --create-dirs \\\r\n    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 ~/.vimrc 加入 Plug \u0026lsquo;ycm-core/YouCompleteMe\u0026rsquo;\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026quot; Specify a directory for plugins\r\ncall plug#begin('~/.vim/plugged')\r\n\r\nPlug 'ycm-core/YouCompleteMe'\r\n\r\n\u0026quot; Initialize plugin system\r\ncall plug#end()\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e打開 vim，在 vim 命令列輸入安裝 Plugin 的指令下載 YCM，這個時候還沒編譯所以會顯示安裝失敗\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e:PlugInstall\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"編譯ycm\"\u003e編譯YCM\u003c/h1\u003e\n\u003cp\u003e安裝編譯工具\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003esudo apt install -y build-essential cmake vim python3-dev \r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e編譯\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e~/.vim/plugged/YouCompleteMe/install.py\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"測試\"\u003e測試\u003c/h1\u003e\n\u003cp\u003e打開 vim 確認，完工~\u003c/p\u003e\n\u003ch1 id=\"reference\"\u003eReference\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ycm-core/YouCompleteMe\" target=\"_blank\" rel=\"noopener\"\u003eGitHub - ycm-core/YouCompleteMe\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/junegunn/vim-plug\" target=\"_blank\" rel=\"noopener\"\u003eGitHub - junegunn/vim-plug\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[Linux] 在 Ubuntu 20.04 中設置 vim plugin YouCompleteMe"},{"categories":null,"contents":"要在前端用 JavaScript 將 DOM 的內容複製到剪貼簿有幾種姿勢：\nClipboard API 基本上目前(2020年底)，主流瀏覽器近期版本都支援了，如果不考慮 IE 的話倒是可以使用，語法精簡而且能非同步操作。\n不支援 IE 是非同步方法，會傳回 Promise 支援從變數直接複製到剪貼簿 只有 HTTPS 網頁可以使用此 API Chrome 66 之後透過 Clipboard 複製已經不會彈出提示視窗 只能在 active tab 發生作用 (a.k.a. 開發者無法在 colsole 做測試，會得到 DOMException: Document is not focused.) function copyText(text) {\r// 判斷瀏覽器支援\rif (!navigator.clipboard) {\ralert(\u0026quot;瀏覽器不支援 Clipboard API\u0026quot;)\r// 這裡可以改用 document.execCommand('copy') 的方法\r}\r// 非同步複製至剪貼簿\rlet resolve = () =\u0026gt; { console.log('透過 Clipboard 複製至剪貼簿成功'); }\rlet reject = (err) =\u0026gt; { console.error('透過 Clipboard 複製至剪貼簿失敗:' + err.toString() ); }\rnavigator.clipboard.writeText(text).then(resolve, reject);\r}\r複製隱藏元素 document.execCommand(\u0026lsquo;copy\u0026rsquo;)\n瀏覽器相容性最佳(支援IE) 是同步方法 只能從 DOM 擷取內容放到剪貼簿 只有 IE 會彈出提示視窗 可在 colsole 以指令測試。 // 這個 function 接收要複製的文字，從 dom 取值出來丟進去複製即可\r// 同理可製作接收 dom 為參數直接取值複製的版本，但不太符合單一職責原則\rfunction copyText(text) {\r// 設置一個剪貼用的隱藏 textarea\rvar el = document.createElement(\u0026quot;textarea\u0026quot;);\rel.value = text;\rel.style.display=\u0026quot;none\u0026quot;;\r// 選取該 textarea\rdocument.body.appendChild(el);\rel.focus();\rel.select();\r// 複製文字內容\rdocument.execCommand('copy');\r// 移除該元素\rdocument.body.removeChild(el);\r}\r比較 Clipboard API document.execCommand(\u0026lsquo;copy\u0026rsquo;) 在 colsole 測試 不可 可 IE 支援性 不支援 支援 HTTP可用 不可(HTTPS only) 可 同步/非同步 非同步 同步 複製原理 值-\u0026gt;剪貼簿 值-\u0026gt;隱藏元素-\u0026gt;剪貼簿 Reference StackOverflow - How do I copy to the clipboard in JavaScript? MDN - Clipboard API ","date":"November 13, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/javascript/code-copy-html-content/","summary":"\u003cp\u003e要在前端用 JavaScript 將 DOM 的內容複製到剪貼簿有幾種姿勢：\u003c/p\u003e\n\u003ch2 id=\"clipboard-api\"\u003eClipboard API\u003c/h2\u003e\n\u003cp\u003e基本上目前(2020年底)，主流瀏覽器近期版本都支援了，如果不考慮 IE 的話倒是可以使用，語法精簡而且能非同步操作。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不支援 IE\u003c/li\u003e\n\u003cli\u003e是非同步方法，會傳回 Promise\u003c/li\u003e\n\u003cli\u003e支援從變數直接複製到剪貼簿\u003c/li\u003e\n\u003cli\u003e只有 HTTPS 網頁可以使用此 API\u003c/li\u003e\n\u003cli\u003eChrome 66 之後透過 Clipboard 複製已經不會彈出提示視窗\u003c/li\u003e\n\u003cli\u003e只能在 active tab 發生作用 (a.k.a. 開發者無法在 colsole 做測試，會得到 \u003ccode\u003eDOMException: Document is not focused.\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction copyText(text) {\r\n\r\n   // 判斷瀏覽器支援\r\n   if (!navigator.clipboard) {\r\n       alert(\u0026quot;瀏覽器不支援 Clipboard API\u0026quot;)\r\n       // 這裡可以改用 document.execCommand('copy') 的方法\r\n   }\r\n\r\n   // 非同步複製至剪貼簿\r\n   let resolve = () =\u0026gt; { \r\n       console.log('透過 Clipboard 複製至剪貼簿成功'); \r\n   }\r\n   let reject = (err) =\u0026gt; { \r\n       console.error('透過 Clipboard 複製至剪貼簿失敗:' + err.toString() ); \r\n   }\r\n   navigator.clipboard.writeText(text).then(resolve, reject);\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"複製隱藏元素\"\u003e複製隱藏元素\u003c/h2\u003e\n\u003cp\u003edocument.execCommand(\u0026lsquo;copy\u0026rsquo;)\u003c/p\u003e","tags":null,"title":"[Code] 複製元件內的文字"},{"categories":null,"contents":"起始一個使用 vallina-ts 的 vite 專案並安裝套件，並使用 bootstrap 做簡單的 css 套用：\nnpm init vite@latest route-test\r#依序選擇 vallina-\u0026gt;vallina-ts\rcd route-test npm i # 安裝套件\rnpm i bootstrap # 安裝 bootstrap\r在 index.html 新增元素 app \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/svg+xml\u0026#34; href=\u0026#34;favicon.svg\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Vite App\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34; class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;menu\u0026#34; class=\u0026#34;row g-0\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34; class=\u0026#34;row g-0\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;/src/main.ts\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\n建立三個頁面檔案，分別是 src/view/Home.ts、src/view/About.ts、src/view/PageNotFound.ts， 這三個檔案是 typescript module，實作如下：\n// Home.ts\rexport default {\rname: 'Home',\rrender(): HTMLElement{\rlet el = document.createElement('div');\rel.innerHTML = ` Home `;\rreturn el;\r}\r}\r// About.ts\rexport default {\rname: 'About',\rrender(): HTMLElement{\rlet el = document.createElement('div');\rel.innerHTML = ` About `;\rreturn el;\r}\r}\r// PageNotFound.ts\rexport default {\rname: 'PageNotFound',\rrender(): HTMLElement{\rlet el = document.createElement('div');\rel.innerHTML = ` PageNotFound `;\rreturn el;\r}\r}\r接著 src/main.ts 程式長這樣：\nimport './style.css'\rimport 'bootstrap/dist/css/bootstrap.min.css'\rimport About from './view/About'\rimport Home from './view/Home'\rimport NotFound from './view/NotFound'\r// 介面宣告\rexport interface IRoute {\rname: string,\rrender: () =\u0026gt; HTMLElement\r}\r// 物件宣告\rlet loaded: boolean = false // 頁面是否已首次載入\r// 路由對應\rconst routes: Map\u0026lt;string, IRoute\u0026gt; = new Map([\r['/Home', Home],\r['/About', About],\r])\rconst rootDiv = \u0026lt;HTMLElement\u0026gt;document.getElementById('root') // 路由頁面所在的節點\rconst menuDiv = \u0026lt;HTMLElement\u0026gt;document.getElementById('menu') // menu 清單所在的節點\r// 路由函式\rfunction route(path: string = '/') {\r// 如果是首頁就導到 Home\rif(path === '/') {\rroute('/Home')\rreturn }\r// 如果不是第一次載入，則同路由不處理\rif(loaded \u0026amp;\u0026amp; path.toLocaleLowerCase() === window.location.pathname.toLocaleLowerCase()) return\rlet key = Array.from(routes.keys()).find(k=\u0026gt;k.toLocaleLowerCase() === path.toLocaleLowerCase())\rlet page = key ? \u0026lt;IRoute\u0026gt;routes.get(key) : NotFound\rrootDiv.innerHTML = '' // 清空\rrootDiv.appendChild(page.render()); // 渲染\rwindow.history.pushState({}, route.name, window.location.origin + path)\r}\r// 載入時掛上 menu\rwindow.onload = () =\u0026gt; {\rroutes.forEach(r=\u0026gt;{\rlet item = document.createElement('div')\ritem.classList.add('col', 'border')\ritem.textContent = r.name\ritem.addEventListener('click',()=\u0026gt; route(`/${r.name}`))\rmenuDiv.appendChild(item)\r})\rroute(window.location.pathname) // 載入的時候先做一次路由\rloaded = true // 設定載入完畢\r}\r// 攔截上一頁動作\rwindow.onpopstate = ()=\u0026gt;{\rlet path = window.location.pathname\rlet page = routes.has(path) ? \u0026lt;IRoute\u0026gt;routes.get(path) : NotFound\rrootDiv.innerHTML = ''\rrootDiv.appendChild(page.render())\r}\r執行測試，至此完成\nnpm run dev\r","date":"November 13, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/javascript/diy-simple-router/","summary":"\u003cp\u003e起始一個使用 vallina-ts 的 vite 專案並安裝套件，並使用 bootstrap 做簡單的 css 套用：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enpm init vite@latest route-test\r\n#依序選擇 vallina-\u0026gt;vallina-ts\r\n\r\ncd route-test \r\nnpm i  # 安裝套件\r\nnpm i bootstrap # 安裝 bootstrap\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 index.html 新增元素 app\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u0026lt;!DOCTYPE html\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt;\u003cspan style=\"color:#f92672\"\u003ehtml\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003elang\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;en\u0026#34;\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;\u003cspan style=\"color:#f92672\"\u003ehead\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003emeta\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003echarset\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;UTF-8\u0026#34;\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003elink\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003erel\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;icon\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;image/svg+xml\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ehref\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;favicon.svg\u0026#34;\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003emeta\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;viewport\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003econtent\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u003c/span\u003e /\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003etitle\u003c/span\u003e\u0026gt;Vite App\u0026lt;/\u003cspan style=\"color:#f92672\"\u003etitle\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ehead\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;\u003cspan style=\"color:#f92672\"\u003ebody\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex; background-color:#3c3d38\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;app\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclass\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;container-fluid\u0026#34;\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex; background-color:#3c3d38\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;menu\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclass\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;row g-0\u0026#34;\u003c/span\u003e\u0026gt;\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex; background-color:#3c3d38\"\u003e\u003cspan\u003e      \u0026lt;\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;root\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eclass\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;row g-0\u0026#34;\u003c/span\u003e\u0026gt;\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex; background-color:#3c3d38\"\u003e\u003cspan\u003e    \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ediv\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u0026lt;\u003cspan style=\"color:#f92672\"\u003escript\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;module\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esrc\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;/src/main.ts\u0026#34;\u003c/span\u003e\u0026gt;\u0026lt;/\u003cspan style=\"color:#f92672\"\u003escript\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u0026lt;/\u003cspan style=\"color:#f92672\"\u003ebody\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt;/\u003cspan style=\"color:#f92672\"\u003ehtml\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/p\u003e","tags":null,"title":"[DIY] 用Typescript搭建簡易前端路由"},{"categories":null,"contents":"JS模組規範有很多：AMD、UMD、CMD、commonJS、ES6 module\nReference JS模組規範：AMD、UMD、CMD、commonJS、ES6 module ","date":"November 13, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/javascript/js-module/","summary":"\u003cp\u003eJS模組規範有很多：AMD、UMD、CMD、commonJS、ES6 module\u003c/p\u003e\n\u003ch1 id=\"reference\"\u003eReference\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/150248/\" target=\"_blank\" rel=\"noopener\"\u003eJS模組規範：AMD、UMD、CMD、commonJS、ES6 module\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[JS] 各種模組(module)"},{"categories":null,"contents":"安裝 axios SignalR 連線驗證的方式是將 token 夾帶於網址參數中發送到伺服器，因此進行 websocket 連線前我們透過 ajax 向伺服器發送帳號密碼索取登入的 Token，我們安裝方便使用 ajax 的 axios 函式庫：\naxios 一樣可以透過 LibMan 安裝~\nlibman install axios@latest \\\r-p unpkg \\\r-d wwwroot/js/axios \\\r--files dist/axios.min.js\r在 wwwRoot/index.html 添加對 axios 的引用：\n\u0026lt;script src=\u0026quot;./lib/axios/dist/axios.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r簡易登入UI 雖然是功能原型，為了讓做出來的頁面不要太粗暴，拿 bootstrap 的 css 來套用一下 UI：\nlibman install bootstrap@5.0.0-alpha2 \\\r-p unpkg \\\r-d wwwroot/lib/bootstrap \\\r--files dist/js/bootstrap.min.js \\\r--files dist/css/bootstrap.min.css 在 wwwRoot/index.html 添加對 bootstrap css 的引用：\n\u0026lt;script src=\u0026quot;./lib/bootstrap/dist/js/bootstrap.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r現在將 wwwRoot/index.html 修改如下：\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt;\r\u0026lt;title\u0026gt;\u0026lt;/title\u0026gt;\r\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;./lib/bootstrap/dist/css/bootstrap.min.css\u0026quot; /\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;row g-1 mt-4\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;col-2\u0026quot;\u0026gt;\r\u0026lt;!-- 使用者名稱輸入框 --\u0026gt;\r\u0026lt;input id=\u0026quot;userInput\u0026quot; type=\u0026quot;text\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;User\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;col-2\u0026quot;\u0026gt;\r\u0026lt;!-- 密碼輸入框 --\u0026gt;\r\u0026lt;input id=\u0026quot;passInput\u0026quot; type=\u0026quot;password\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;Password\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;!-- 登入按鈕 --\u0026gt;\r\u0026lt;div class=\u0026quot;col-auto\u0026quot;\u0026gt;\r\u0026lt;button id=\u0026quot;loginButton\u0026quot; type=\u0026quot;button\u0026quot; class=\u0026quot;btn btn-outline-secondary\u0026quot;\u0026gt;登入\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;row g-1 mt-2\u0026quot;\u0026gt;\r\u0026lt;!-- 訊息輸入框 --\u0026gt;\r\u0026lt;div class=\u0026quot;col-4\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;messageInput\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;Message\u0026quot;/\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;!-- 送出按鈕 --\u0026gt;\r\u0026lt;div class=\u0026quot;col-auto\u0026quot;\u0026gt;\r\u0026lt;button id=\u0026quot;sendButton\u0026quot; type=\u0026quot;button\u0026quot; class=\u0026quot;btn btn-outline-success\u0026quot;\u0026gt;Send\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;col-12\u0026quot;\u0026gt;\r\u0026lt;hr /\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;col-6\u0026quot;\u0026gt;\r\u0026lt;!-- 顯示訊息的ul --\u0026gt;\r\u0026lt;ul id=\u0026quot;messagesList\u0026quot;\u0026gt;\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script src=\u0026quot;./js/signalr/dist/browser/signalr.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026quot;./js/chat.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026quot;./lib/bootstrap/dist/js/bootstrap.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026quot;./lib/axios/dist/axios.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r修改 Chat.js 官方範例中，SignalR連線是由網址參數傳遞，方法是在 withUrl 的第二個物件參數給一個 accessTokenFactory 回傳 token：\n// Connect, using the token we got.\rthis.connection = new signalR.HubConnectionBuilder()\r.withUrl(\u0026quot;/hubs/chat\u0026quot;, { accessTokenFactory: () =\u0026gt; loginToken })\r.build();\r另外我們需要在取得 Token 之後方能啟動連線，因此將整個 Chat.js 改成這樣：\n\u0026quot;use strict\u0026quot;;\r// 從 Dom tree 當中取得送出按鈕、訊息輸入元件\rlet btnSend = document.getElementById(\u0026quot;sendButton\u0026quot;);\rlet messageInput = document.getElementById(\u0026quot;messageInput\u0026quot;);\r// 從 Dom tree 當中取得登入按鈕、使用者名稱輸入、密碼輸入\rlet userInput = document.getElementById(\u0026quot;userInput\u0026quot;);\rlet passInput = document.getElementById(\u0026quot;passInput\u0026quot;);\rlet btnLogin = document.getElementById(\u0026quot;loginButton\u0026quot;);\r// 使送出按鈕無法點選，直到登入後 SignalR 連線建立\rbtnSend.disabled = true;\rlet access_token=\u0026quot;\u0026quot;;\r// 以 token 起始一個 SignalR 連線，連線到 /chatHub 端點\rlet connection = new signalR.HubConnectionBuilder().withUrl(\u0026quot;/chathub\u0026quot;, {\raccessTokenFactory: () =\u0026gt; access_token\r}).build();\r// 點擊登入鈕事件\rbtnLogin.addEventListener(\u0026quot;click\u0026quot;, async function (event) {\rtry {\r// 取得 token\rlet data = {\ruserId: userInput.value,\rpassword: passInput.value\r};\rlet res = await axios.post(\u0026quot;./api/Token/signin\u0026quot;, data);\raccess_token = res.data.token\r// 起始連線，將送出按鈕啟用\rawait connection.start()\rbtnSend.disabled = false;\r} catch (err) {\ralert(\u0026quot;嘗試取得Token建立連線時發生錯誤，詳細資料：\u0026quot; + err.toString() + \u0026quot;;\u0026quot;);\r}\r});\r// 註冊連線接收到 ReceiveMessage 時的行為\r// 這個行為會呼叫帶有參數 user, message 的回呼函數\rconnection.on(\u0026quot;ReceiveMessage\u0026quot;, function (user, message) {\r// 將\u0026amp;、\u0026lt;、\u0026gt;取代為相對應的 html code\rvar msg = message.replace(/\u0026amp;/g, \u0026quot;\u0026amp;amp;\u0026quot;).replace(/\u0026lt;/g, \u0026quot;\u0026amp;lt;\u0026quot;).replace(/\u0026gt;/g, \u0026quot;\u0026amp;gt;\u0026quot;);\r// 設定顯示文字、新增一個顯示對話的 li dom 插入至 messagesList\rvar encodedMsg = \u0026quot;[\u0026quot; + user + \u0026quot;] \u0026quot; + msg;\rvar li = document.createElement(\u0026quot;li\u0026quot;);\rli.textContent = encodedMsg;\rdocument.getElementById(\u0026quot;messagesList\u0026quot;).appendChild(li);\r});\r// 設定按下送出訊息的行為\rbtnSend.addEventListener(\u0026quot;click\u0026quot;, function (event) {\r// 以參數 userInput、messageInput 的值作為參數呼叫 server 端的 SendMessage\rconnection\r.invoke(\u0026quot;SendMessage\u0026quot;, userInput.value, messageInput.value)\r.catch(function (err) {\rreturn console.error(err.toString());\r});\r// 取消 html 按鈕執行預設行為\revent.preventDefault();\r});\r測試 經過如上的設置，已可在登入後啟動 SignalR 連線，完成供參考的聊天室原型： ","date":"November 10, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/startup-signalr/guild_4_front_end_login/","summary":"\u003ch1 id=\"安裝-axios\"\u003e安裝 axios\u003c/h1\u003e\n\u003cp\u003eSignalR 連線驗證的方式是將 token 夾帶於網址參數中發送到伺服器，因此進行 websocket 連線前我們透過 ajax 向伺服器發送帳號密碼索取登入的 Token，我們安裝方便使用 ajax 的 axios 函式庫：\u003c/p\u003e\n\u003cp\u003eaxios 一樣可以透過 LibMan 安裝~\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003elibman install axios@latest \\\r\n  -p unpkg \\\r\n  -d wwwroot/js/axios \\\r\n  --files dist/axios.min.js\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 wwwRoot/index.html 添加對 axios 的引用：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e\u0026lt;script src=\u0026quot;./lib/axios/dist/axios.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"簡易登入ui\"\u003e簡易登入UI\u003c/h1\u003e\n\u003cp\u003e雖然是功能原型，為了讓做出來的頁面不要太粗暴，拿 bootstrap 的 css 來套用一下 UI：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003elibman install bootstrap@5.0.0-alpha2 \\\r\n  -p unpkg \\\r\n  -d wwwroot/lib/bootstrap \\\r\n  --files dist/js/bootstrap.min.js \\\r\n  --files dist/css/bootstrap.min.css \r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 wwwRoot/index.html 添加對 bootstrap css 的引用：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e\u0026lt;script src=\u0026quot;./lib/bootstrap/dist/js/bootstrap.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e現在將 wwwRoot/index.html 修改如下：\u003c/p\u003e","tags":null,"title":"[SignalR] Websocket 即時聊天程式(四) - 前端登入頁面"},{"categories":null,"contents":"SignalR驗證方式 SignalR 的授權可以選擇使用 Cookie 或 Bearer Token：\nCookie: 驗證方法與一般網頁別無二致，較容易實作但缺點是只能用於瀏覽器(browser-specific)。 Bearer Token 可通用於網頁和 App (或提供任何應用程式)，使用 Token 做登入能夠讓應用程式更容易實作其他使用者端，如果有其他的伺服器簽發 Token，更容易整合至單一登入(Single Sign-On)，也是官方建議使用的方式，以下假設簽發 Token 與 SignalR 伺服器為同一台進行實作。 將 Token 驗證實作至伺服器之前，讓我們先練習實作一支簽發 Token 的 API。\n以 Option pattern 取得 JWT 設定 這裡練習 Option pattern，以獲取 appsetting.json 當中 JWT 相關設定的強型別支援：\nappsetting.json 將 JWT 相關的設定寫到 appsetting.json 當中： { \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Warning\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Information\u0026#34; } }, \u0026#34;JWT\u0026#34;: { \u0026#34;Issuer\u0026#34;: \u0026#34;Naxo\u0026#34;, \u0026#34;Expires\u0026#34;: \u0026#34;1440\u0026#34;, // 憑證有效分鐘數 \u0026#34;SignKey\u0026#34;: \u0026#34;myNameIsTigernaxo,ThisIsMyPersonalBlog\u0026#34; // 設定簽發/解密憑證的對稱式加密金鑰 }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34; }\nJWT Option 類別 建立 Options.cs ，並在當中新增一個 Option 類別以對應 JWT 設定： namespace SignalR { public class JWTOption { public const string JWT = \u0026#34;JWT\u0026#34;; public string Issuer { get; set; } public string SignKey { get; set; } public int Expires { get; set; } } }\n註冊服務容器 在 Startup.cs 的 ConfigureServices 將 JWTOption 註冊到 service container 當中，之後可以直接注入 Controller 使用； public void ConfigureServices(IServiceCollection services) { services.AddControllers(); services.AddSignalR(); // 在 service container 當中註冊 JWT Option services.AddOptions\u0026lt;JWTOption\u0026gt;() .Bind(Configuration.GetSection(JWTOption.JWT)); }\n簽發 Token 安裝 Token 套件 筆者在 ASP .NET Core 3.1 的 Web API 專案後，無法直接使用 JWT 相關功能，所以必須先安裝套件：\ndotnet add package System.IdentityModel.Tokens.Jwt --version 6.8.0\rLogin Controller 建立 API 控制器 Controllers/TokenController.cs，並注入 IOptions\u0026lt;JWTOption\u0026gt;：\nusing System;\rusing System.Collections.Generic;\rusing System.IdentityModel.Tokens.Jwt;\rusing System.Linq;\rusing System.Security.Claims;\rusing System.Text;\rusing System.Threading.Tasks;\rusing Microsoft.AspNetCore.Authorization;\rusing Microsoft.AspNetCore.Http;\rusing Microsoft.AspNetCore.Mvc;\rusing Microsoft.Extensions.Configuration;\rusing Microsoft.Extensions.Configuration.UserSecrets;\rusing Microsoft.Extensions.Options;\rusing Microsoft.IdentityModel.Tokens;\rnamespace SignalR.Controllers\r{\r[Route(\u0026quot;api/[controller]\u0026quot;)]\r[ApiController]\rpublic class TokenController : ControllerBase\r{\rprivate JWTOption _jwtOpt;\r// 等待服務容器注入 IOptions\u0026lt;JWTOption\u0026gt;\rpublic TokenController(IOptions\u0026lt;JWTOption\u0026gt; jwtOpt)\r{\rthis._jwtOpt = jwtOpt.Value;\r}\r[AllowAnonymous]\r[HttpPost(\u0026quot;signin\u0026quot;)]\rpublic IActionResult SignIn(LoginModel loginModel)\r{\r// 模擬驗證使用者帳號密碼\rvar canLogin = loginModel.userId == \u0026quot;naxo\u0026quot; \u0026amp;\u0026amp; loginModel.password == \u0026quot;pass\u0026quot;;\rif (canLogin)\r{\rstring issuer = _jwtOpt.Issuer;\rstring signKey = _jwtOpt.SignKey;\r// 設定要加入到 JWT Token 中的聲明資訊(Claims)\rList\u0026lt;Claim\u0026gt; claims = new List\u0026lt;Claim\u0026gt;();\r// 加入Sub(用戶)\rclaims.Add(new Claim(JwtRegisteredClaimNames.Sub, loginModel.userId));\r// 加入jti(JWT ID) 用於一次性 token\r//claims.Add(new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()));\r// 聲明使用者 userId、roles 的 claim，這裡會用來判斷使用者識別碼、使用者群組\rclaims.Add(new Claim(\u0026quot;userId\u0026quot;, loginModel.userId));\rclaims.Add(new Claim(\u0026quot;roles\u0026quot;, \u0026quot;Admin\u0026quot;));\rclaims.Add(new Claim(\u0026quot;roles\u0026quot;, \u0026quot;Users\u0026quot;));\r// 建立一組對稱式加密金鑰，主要用於 JWT 簽章之用\rSymmetricSecurityKey securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(signKey));\r// 定義加密金鑰、演算法、數位簽章摘要\r// HmacSha256 必須大於 128 bits，亦即 key 長度至少要 16 字元\rSigningCredentials signingCredentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256Signature);\r// 產生一個 JwtSecurityToken\rvar token = new JwtSecurityToken(\rissuer, // Issuer issuer, // Audience claims, // claims\rexpires: DateTime.Now.AddMinutes(_jwtOpt.Expires), // token 生效至過期的分鐘數\rsigningCredentials: signingCredentials\r);\r// 序列化 JwtSecurityToken\rvar jwt_token = new JwtSecurityTokenHandler().WriteToken(token);\r// 回傳 token\rreturn Ok(new\r{\rtoken = jwt_token,\r});\r}\r// 驗證失敗\rreturn BadRequest(new\r{\rerr = \u0026quot;登入失敗\u0026quot;,\r});\r}\r}\rpublic class LoginModel\r{\rpublic string userId { get; set; }\rpublic string password { get; set; }\r}\r}\r測試 至此我們已完成了一個簡易的 Token SignIn API，以 Postman 進行測試： 備註 驗證使用者帳號/密碼的區段需自行代換成應用程式需要的程式碼。 Token 當中的 Claim 可視情況自行增減 ","date":"November 7, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/startup-signalr/guild_2_issue_token/","summary":"\u003ch1 id=\"signalr驗證方式\"\u003eSignalR驗證方式\u003c/h1\u003e\n\u003cp\u003eSignalR 的授權可以選擇使用 Cookie 或 Bearer Token：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCookie: 驗證方法與一般網頁別無二致，較容易實作但缺點是只能用於瀏覽器(browser-specific)。\u003c/li\u003e\n\u003cli\u003eBearer Token 可通用於網頁和 App (或提供任何應用程式)，使用 Token 做登入能夠讓應用程式更容易實作其他使用者端，如果有其他的伺服器簽發 Token，更容易整合至單一登入(Single Sign-On)，也是官方建議使用的方式，以下假設簽發 Token 與 SignalR 伺服器為同一台進行實作。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e將 Token 驗證實作至伺服器之前，讓我們先練習實作一支簽發 Token 的 API。\u003c/p\u003e\n\u003ch1 id=\"以-option-pattern-取得-jwt-設定\"\u003e以 Option pattern 取得 JWT 設定\u003c/h1\u003e\n\u003cp\u003e這裡練習 Option pattern，以獲取 appsetting.json 當中 JWT 相關設定的強型別支援：\u003c/p\u003e\n\u003ch2 id=\"appsettingjson\"\u003eappsetting.json\u003c/h2\u003e\n\u003cp\u003e將 JWT 相關的設定寫到 appsetting.json 當中：\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e\u0026#34;Logging\u0026#34;\u003c/span\u003e: {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e\u0026#34;LogLevel\u0026#34;\u003c/span\u003e: {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;Default\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Information\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;Microsoft\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Warning\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;Microsoft.Hosting.Lifetime\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Information\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex; background-color:#3c3d38\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e\u0026#34;JWT\u0026#34;\u003c/span\u003e: {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex; background-color:#3c3d38\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e\u0026#34;Issuer\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Naxo\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex; background-color:#3c3d38\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e\u0026#34;Expires\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;1440\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#75715e\"\u003e// 憑證有效分鐘數\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex; background-color:#3c3d38\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#f92672\"\u003e\u0026#34;SignKey\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;myNameIsTigernaxo,ThisIsMyPersonalBlog\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e// 設定簽發/解密憑證的對稱式加密金鑰\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex; background-color:#3c3d38\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e\u0026#34;AllowedHosts\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;*\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/p\u003e","tags":null,"title":"[SignalR] Websocket 即時聊天程式(二) - 後端 Token 授權"},{"categories":null,"contents":"這個系列會官方文件為主，保留必要的部分，並視情況修改部份程式、添加說明文字。\n建立 SignalR 專案 這個範例設定用靜態 html 做前端，這樣之後要做前後端分離也更容易一些，之後會用到 web api 請求登入 Token，所以起始一個 web api 專案：\n# 建立專案\rdotnet new webapi -o SignalR\r# 以 VS Code 打開專案\rcode -r signalr\r建立 SignalR 中樞 在.NET Core 3.1 當中使用 SignalR 伺服器端不再需要安裝額外的套件，直接將 SignalR 注入服務容器就能使用， SignalR 的 Hub 中文名稱就叫做中樞，在專案中新增資料夾 Hubs 用來專門存放 Hub 實作類別，並在 Hubs 中新增檔案 ChatHub.cs，內容如下：\nusing Microsoft.AspNetCore.SignalR;\rusing System.Threading.Tasks;\rnamespace SignalR.Hubs\r{\r// 這就是所謂的 SignalR 中樞\rpublic class ChatHub : Hub\r{\r// 這是提供 Client (js)端呼叫的方法，後面是這個方法接受的參數\rpublic async Task SendMessage(string user, string message)\r{\r// 針對每個以連線的客戶端呼叫 ReceiceMassage 方法，並傳送參數 user、message\rawait Clients.All.SendAsync(\u0026quot;ReceiveMessage\u0026quot;, user, message);\r}\r}\r}\r設定 Startup.cs 依照官網的設定，在 Startup.cs 當中新增第13, 30,42-43 ,52 行：\nusing SignalRChat.Hubs;:新增對 Hub 的引用。 service.AddSignalR():將 SignalR 相關對應註冊在 service container 中。 app.UseDefaultFiles():讓程式自動傳送路徑下的 index.html，必須要在 app.UseStaticFiles()之前設置。 app.UseStaticFiles():讓程式自動傳送 wwwRoot 下的檔案。 endpoints.MapHub\u0026lt;ChatHub\u0026gt;(\u0026quot;/chathub\u0026quot;);:將 ChatHub 中樞綁定到站台的 /chathub 端點。 using System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; using Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.AspNetCore.HttpsPolicy; using Microsoft.AspNetCore.Mvc; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; using SignalR.Hubs; namespace SignalR { public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } // This method gets called by the runtime. Use this method to add services to the container. public void ConfigureServices(IServiceCollection services) { services.AddControllers(); services.AddSignalR(); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseHttpsRedirection(); app.UseDefaultFiles(); // 使靜態檔案路徑預設指向 index.html app.UseStaticFiles(); // 啟用靜態檔案 app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllers(); endpoints.MapHub\u0026lt;ChatHub\u0026gt;(\u0026#34;/chathub\u0026#34;); }); } } } 安裝前端相依性 LibMan LibMan 程式庫管理員可從獲取前端所需要的相依性，來源包含檔案系統(File System)或CDNJS、jsDelivr、unpkg 等等內容傳遞網路(CDN)，如果前端以其他框架(ex: Angular、React、Vue)開發時就需要用其他方式，這裡先用微軟提供的方便工具安裝需要的套件。\ndotnet tool install -g Microsoft.Web.LibraryManager.Cli\r@microsoft/signalr 以下指令 LibMan 會從unpkg將套件 @microsoft/signalr@latest 安裝到專案下的路徑 wwwroot/js/signalr 當中\nlibman install @microsoft/signalr@latest \\\r-p unpkg \\\r-d wwwroot/js/signalr \\\r--files dist/browser/signalr.js \\\r--files dist/browser/signalr.min.js\r前端程式碼 HTML 新增檔案 wwwRoot\\index.html，內容如下：\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt;\r\u0026lt;title\u0026gt;\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt;\u0026amp;nbsp;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;col-2\u0026quot;\u0026gt;User\u0026lt;/div\u0026gt;\r\u0026lt;!-- 使用者名稱輸入框 --\u0026gt;\r\u0026lt;div class=\u0026quot;col-4\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;userInput\u0026quot; /\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;col-2\u0026quot;\u0026gt;Message\u0026lt;/div\u0026gt;\r\u0026lt;!-- 訊息輸入框 --\u0026gt;\r\u0026lt;div class=\u0026quot;col-4\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;messageInput\u0026quot; /\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt;\u0026amp;nbsp;\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;col-6\u0026quot;\u0026gt;\r\u0026lt;!-- 送出按鈕 --\u0026gt;\r\u0026lt;input type=\u0026quot;button\u0026quot; id=\u0026quot;sendButton\u0026quot; value=\u0026quot;Send Message\u0026quot; /\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;col-12\u0026quot;\u0026gt;\r\u0026lt;hr /\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;col-6\u0026quot;\u0026gt;\r\u0026lt;!-- 顯示訊息的ul --\u0026gt;\r\u0026lt;ul id=\u0026quot;messagesList\u0026quot;\u0026gt;\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script src=\u0026quot;./js/signalr/dist/browser/signalr.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026quot;./js/chat.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rJavaScript 新增一個檔案 wwwRoot/js/Chat.js\n\u0026quot;use strict\u0026quot;;\r// 起始一個 SignalR 連線，連線到 /chathub 端點\rlet connection = new signalR.HubConnectionBuilder().withUrl(\u0026quot;/chatHub\u0026quot;).build();\r// 從 Dom tree 當中取得送出按鈕、使用者名稱輸入、訊息輸入元件\rlet btnSend = document.getElementById(\u0026quot;sendButton\u0026quot;);\rlet userInput = document.getElementById(\u0026quot;userInput\u0026quot;);\rlet messageInput = document.getElementById(\u0026quot;messageInput\u0026quot;);\r// 使送出按鈕無法點選，直到 SignalR 連線建立\rbtnSend.disabled = true;\r// 註冊連線接收到 ReceiveMessage 時的行為\r// 這個行為會呼叫帶有參數 user, message 的回呼函數\rconnection.on(\u0026quot;ReceiveMessage\u0026quot;, function (user, message) {\r// 將\u0026amp;、\u0026lt;、\u0026gt;取代為相對應的 html code\rvar msg = message.replace(/\u0026amp;/g, \u0026quot;\u0026amp;amp;\u0026quot;).replace(/\u0026lt;/g, \u0026quot;\u0026amp;lt;\u0026quot;).replace(/\u0026gt;/g, \u0026quot;\u0026amp;gt;\u0026quot;);\r// 設定顯示文字、新增一個顯示對話的 li dom 插入至 messagesList\rvar encodedMsg = \u0026quot;[\u0026quot; + user + \u0026quot;] \u0026quot; + msg;\rvar li = document.createElement(\u0026quot;li\u0026quot;);\rli.textContent = encodedMsg;\rdocument.getElementById(\u0026quot;messagesList\u0026quot;).appendChild(li);\r});\r// 設定連線建立時的行為，將送出按鈕啟用\rconnection.start().then(function () {\rbtnSend.disabled = false;\r}).catch(function (err) {\rreturn console.error(err.toString());\r});\r// 設定按下送出訊息的行為\rbtnSend.addEventListener(\u0026quot;click\u0026quot;, function (event) {\r// 以參數 userInput、messageInput 的值作為參數呼叫 server 端的 SendMessage\rconnection\r.invoke(\u0026quot;SendMessage\u0026quot;, userInput.value, messageInput.value)\r.catch(function (err) {\rreturn console.error(err.toString());\r});\r// 取消 html 按鈕執行預設行為\revent.preventDefault();\r});\r測試 dotnet watch run -p signalr.csproj\r錯誤處理 附錄一下實際上沒有遇到，但官方有提到兩個錯誤的處理方法，按 F12 打開開發人員工具後檢查錯誤：\nChat.js 404 not found\u0026hellip; 單純就是 Chat.js 放錯路徑了\u0026hellip;\nERR_SPDY_INADEQUATE_TRANSPORT_SECURITY 用以下指令清除、重新生成開發期的 https 憑證(dotnet 版本 3.1.403 實際測試官方給的指令 dotnet dev-certs https --trust 沒有作用，是因為沒有 \u0026ndash;trust 選項可以用)\ndotnet dev-certs https --clean\rdotnet dev-certs https\rReference MSDN - Tutorial: Get started with ASP.NET Core SignalR MSDN - Client-side library acquisition in ASP.NET Core with LibMan ","date":"November 3, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/dotnet/startup-signalr/guild_1_start/","summary":"\u003cp\u003e這個系列會\u003ca href=\"https://docs.microsoft.com/en-us/aspnet/core/tutorials/signalr?view=aspnetcore-3.1\u0026amp;tabs=visual-studio\" target=\"_blank\" rel=\"noopener\"\u003e官方文件\u003c/a\u003e為主，保留必要的部分，並視情況修改部份程式、添加說明文字。\u003c/p\u003e\n\u003ch1 id=\"建立-signalr-專案\"\u003e建立 SignalR 專案\u003c/h1\u003e\n\u003cp\u003e這個範例設定用靜態 html 做前端，這樣之後要做前後端分離也更容易一些，之後會用到 web api 請求登入 Token，所以起始一個 web api 專案：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e# 建立專案\r\ndotnet new webapi -o SignalR\r\n# 以 VS Code 打開專案\r\ncode -r signalr\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"建立-signalr-中樞\"\u003e建立 SignalR 中樞\u003c/h1\u003e\n\u003cp\u003e在.NET Core 3.1 當中使用 SignalR 伺服器端不再需要安裝額外的套件，直接將 SignalR 注入服務容器就能使用， SignalR 的 Hub 中文名稱就叫做中樞，在專案中新增資料夾 Hubs 用來專門存放 Hub 實作類別，並在 Hubs 中新增檔案 ChatHub.cs，內容如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c#\"\u003eusing Microsoft.AspNetCore.SignalR;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace SignalR.Hubs\r\n{\r\n    // 這就是所謂的 SignalR 中樞\r\n    public class ChatHub : Hub\r\n    {\r\n        // 這是提供 Client (js)端呼叫的方法，後面是這個方法接受的參數\r\n        public async Task SendMessage(string user, string message)\r\n        {\r\n            // 針對每個以連線的客戶端呼叫 ReceiceMassage 方法，並傳送參數 user、message\r\n            await Clients.All.SendAsync(\u0026quot;ReceiveMessage\u0026quot;, user, message);\r\n        }\r\n    }\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"設定-startupcs\"\u003e設定 Startup.cs\u003c/h1\u003e\n\u003cp\u003e依照官網的設定，在 Startup.cs 當中新增第13, 30,42-43 ,52 行：\u003c/p\u003e","tags":null,"title":"[SignalR] Websocket 即時聊天程式(一) - 建立專案"},{"categories":null,"contents":"查詢IP $ ip a\r1: lo: mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\rlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\rinet 127.0.0.1/8 scope host lo\rvalid_lft forever preferred_lft forever\rinet6 ::1/128 scope host\rvalid_lft forever preferred_lft forever\r2: enp0s3: mtu 1500 qdisc fq_codel state UP group default qlen 1000\rlink/ether 08:00:27:85:fe:50 brd ff:ff:ff:ff:ff:ff\rinet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute enp0s3\rvalid_lft forever preferred_lft forever\rinet6 fe80::98e4:9fbc:ba91:db3f/64 scope link noprefixroute\rvalid_lft forever preferred_lft forever\r修改網路設定 修改網路介面設置如下，檔案名稱預設為ifcfg-網路介面(網路卡)名稱，舉例來說安裝好 CentOS 預設的網路卡 enp0s3 設定檔：/etc/sysconfig/network-scripts/ifcfg-enp0s3\nTYPE=\u0026quot;Ethernet\u0026quot;\rPROXY_METHOD=\u0026quot;none\u0026quot;\rBROWSER_ONLY=\u0026quot;no\u0026quot;\rBOOTPROTO=\u0026quot;static\u0026quot;\rDEFROUTE=\u0026quot;yes\u0026quot;\rIPV4_FAILURE_FATAL=\u0026quot;no\u0026quot;\rIPV6INIT=\u0026quot;yes\u0026quot;\rIPV6_AUTOCONF=\u0026quot;yes\u0026quot;\rIPV6_DEFROUTE=\u0026quot;yes\u0026quot;\rIPV6_FAILURE_FATAL=\u0026quot;no\u0026quot;\rIPV6_ADDR_GEN_MODE=\u0026quot;stable-privacy\u0026quot;\rNAME=\u0026quot;enp0s3\u0026quot;\rUUID=\u0026quot;15114252-a2e9-4fd7-9a2e-c5cc82d0417b\u0026quot;\rDEVICE=\u0026quot;enp0s3\u0026quot;\rONBOOT=\u0026quot;yes\u0026quot; # 設置開機啟動\rIPADDR=\u0026quot;10.0.2.101\u0026quot; # 設置靜態IP位址動\rPREFIX=\u0026quot;24\u0026quot; # 子網路遮照，等價於 NETMASK=\u0026quot;255.255.255.0\u0026quot;\rGATEWAY=\u0026quot;10.0.2.1\u0026quot; # 閘道器位址\rDNS1=\u0026quot;8.8.8.8\u0026quot; # DNS1\rDNS2=\u0026quot;9.9.9.9\u0026quot; # DNS2\rIPV6_PRIVACY=\u0026quot;no\u0026quot;\r重啟網路介面 # 停用\rifdown enp0s3\r# 啟動\rifup enp0s3\r檢查ip，已變更：\n$ ip a\r1: lo: mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\rlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\rinet 127.0.0.1/8 scope host lo\rvalid_lft forever preferred_lft forever\rinet6 ::1/128 scope host\rvalid_lft forever preferred_lft forever\r2: enp0s3: mtu 1500 qdisc fq_codel state UP group default qlen 1000\rlink/ether 08:00:27:85:fe:50 brd ff:ff:ff:ff:ff:ff\rinet 10.0.2.101/24 brd 10.0.2.255 scope global noprefixroute enp0s3\rvalid_lft forever preferred_lft forever\rinet6 fe80::98e4:9fbc:ba91:db3f/64 scope link noprefixroute\rvalid_lft forever preferred_lft forever\r","date":"June 16, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/linux/centos8-static-ip/","summary":"\u003ch1 id=\"查詢ip\"\u003e查詢IP\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003e$ ip a\r\n1: lo: mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\r\nlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\ninet 127.0.0.1/8 scope host lo\r\nvalid_lft forever preferred_lft forever\r\ninet6 ::1/128 scope host\r\nvalid_lft forever preferred_lft forever\r\n2: enp0s3: mtu 1500 qdisc fq_codel state UP group default qlen 1000\r\nlink/ether 08:00:27:85:fe:50 brd ff:ff:ff:ff:ff:ff\r\ninet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute enp0s3\r\nvalid_lft forever preferred_lft forever\r\ninet6 fe80::98e4:9fbc:ba91:db3f/64 scope link noprefixroute\r\nvalid_lft forever preferred_lft forever\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"修改網路設定\"\u003e修改網路設定\u003c/h1\u003e\n\u003cp\u003e修改網路介面設置如下，檔案名稱預設為ifcfg-網路介面(網路卡)名稱，舉例來說安裝好 CentOS 預設的網路卡 enp0s3 設定檔：/etc/sysconfig/network-scripts/ifcfg-enp0s3\u003c/p\u003e","tags":null,"title":"[Linux] CentOS 8 設定網路靜態IP"},{"categories":null,"contents":"Ubuntu 自 17.10 以後就可以用 netplan 設置網卡~\n檢查網路介面 以 ip a 可以看到我的 ubuntu 有2個網路介面分別是 lo、enp0s3，對應到 loopback、有線網卡\n$ ip a\r1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\rlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\rinet 127.0.0.1/8 scope host lo\rvalid_lft forever preferred_lft forever\rinet6 ::1/128 scope host valid_lft forever preferred_lft forever\r2: enp0s3: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\rlink/ether 08:00:27:6a:7b:e3 brd ff:ff:ff:ff:ff:ff\rinet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic enp0s3\rvalid_lft 86159sec preferred_lft 86159sec\rinet6 fe80::a00:27ff:fe6a:7be3/64 scope link valid_lft forever preferred_lft forever\r檢查設定檔 所有放置於 /etc/netplan 底下的 yaml 檔都會影響 netplan 的設置，檢查設定檔看到只有一個 00-installer-config.yaml，內容空空如也，一般來說在安裝系統時有設定過網路就會有，如果沒有的話就自己新增囉：\n# 查看設定檔\r$ ls /etc/netplan/\r00-installer-config.yaml\r$ cat 00-installer-config.yaml # This is the network config written by 'subiquity'\rnetwork:\rethernets:\renp0s3:\rdhcp4: true\rversion: 2\r手動配置設定檔 配置特定網卡的方法就是在 YAML 內將配置寫入，如下：\n# This is the network config written by 'subiquity'\rnetwork:\rethernets:\renp0s3: # 網卡名稱\raddresses: [10.0.2.15/24] # 靜態IP、遮罩\rgateway4: 10.0.2.1 # IPV4 Getway ip\rnameservers:\raddresses: [8.8.8.8,8.8.4.4] # DNS server ip，若有多個就以逗號分隔\rdhcp4: no # 關閉 dhcp 自動取得 IP\r# 如果有 Host only 的話通常都是 enp0s8\renp0s8:\raddresses: [192.168.56.101/24] # 靜態IP、遮罩\rroutes:\r- to: 192.168.56.1/24\rvia: 192.168.56.1\rmetric: 100\r#gateway4: 192.168.56.1 # IPV4 Getway ip\r#nameservers:\r#addresses: [8.8.8.8,8.8.4.4] # DNS server ip，若有多個就以逗號分隔\rdhcp4: no # 關閉 dhcp 自動取得 IP\rdhcp6: no # 關閉 dhcp 自動取得 IP\rversion: 2\r測試設定檔 遠端工作時如果套用了錯誤的網路設定檔就 GG 了，因此在套用之前可以先用 netplan try 測試測定檔是否設置正確，如果沒有在120秒之內進行確認（例如套用了錯誤的網路設定導致使用者斷線）就會回復至先前有效的設定，讓使用者可以再次連上機器修正配置：\n$ sudo netplan try\rWarning: Stopping systemd-networkd.service, but it can still be activated by:\rsystemd-networkd.socket\rDo you want to keep these settings?\rPress ENTER before the timeout to accept the new configuration\rChanges will revert in 120 seconds\rConfiguration accepted.\r$\r應用設定檔 測試無誤後就可以直接讓設定檔生效了：\n$ sudo netplan apply\r現在 ip 已經被固定為 14 囉\n$ ip a 1: lo: mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\rlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\rinet 127.0.0.1/8 scope host lo\rvalid_lft forever preferred_lft forever\rinet6 ::1/128 scope host\rvalid_lft forever preferred_lft forever\r2: enp0s3: mtu 1500 qdisc fq_codel state UP group default qlen 1000\rlink/ether 08:00:27:6a:7b:e3 brd ff:ff:ff:ff:ff:ff\rinet 10.0.2.14/24 brd 10.0.2.255 scope global enp0s3\rvalid_lft forever preferred_lft forever\rinet6 fe80::a00:27ff:fe6a:7be3/64 scope link\rvalid_lft forever preferred_lft forever\r","date":"June 13, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/linux/ubuntu204-static-ip/","summary":"\u003cp\u003eUbuntu 自 17.10 以後就可以用 netplan 設置網卡~\u003c/p\u003e\n\u003ch1 id=\"檢查網路介面\"\u003e檢查網路介面\u003c/h1\u003e\n\u003cp\u003e以 ip a 可以看到我的 ubuntu 有2個網路介面分別是 lo、enp0s3，對應到 loopback、有線網卡\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ip a\r\n1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\r\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n    inet 127.0.0.1/8 scope host lo\r\n       valid_lft forever preferred_lft forever\r\n    inet6 ::1/128 scope host \r\n       valid_lft forever preferred_lft forever\r\n2: enp0s3: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\r\n    link/ether 08:00:27:6a:7b:e3 brd ff:ff:ff:ff:ff:ff\r\n    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic enp0s3\r\n       valid_lft 86159sec preferred_lft 86159sec\r\n    inet6 fe80::a00:27ff:fe6a:7be3/64 scope link \r\n       valid_lft forever preferred_lft forever\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"檢查設定檔\"\u003e檢查設定檔\u003c/h1\u003e\n\u003cp\u003e所有放置於 /etc/netplan 底下的 yaml 檔都會影響 netplan 的設置，檢查設定檔看到只有一個 00-installer-config.yaml，內容空空如也，一般來說在安裝系統時有設定過網路就會有，如果沒有的話就自己新增囉：\u003c/p\u003e","tags":null,"title":"[Linux] Ubuntu 20.4 以 netplan 設定網路靜態IP"},{"categories":null,"contents":"紀錄常用的 Object 方法，細節可以到MDN看\nObject.create Object.create(proto, [propertiesObject])\n以傳入的參數作為prototype建立一個新物件，這個方法只能複製只帶有 primitive type 無法 deep copy，建立的物件所帶的函式、巢狀物件、Array等等…都和 prototype 共用。\n以特定Object 作為 Prototype 建立新物件 const objParent = {\rparentFeild: 'parent feild',\rparentFunc: function () {\rconsole.log('This is parent Func')\r},\rdeepObj: {\ra: 1,\rb: 2,\r},\r}\r// 以 objParent 作為 prototype 建立 obj 物件\rconst obj = Object.create(objParent)\r// objFeild 只存在 obj 上\robj.objFeild = 'obj feild'\r// 可從建立的 obj 呼叫 prototype 的屬性, 方法\robj.parentFeild // \u0026quot;parent feild\u0026quot;\robj.parentFunc() // This is parent Func\r// 從 prototype 繼承的屬性可覆寫\robj.parentFeild = 'overite str'\robj.parentFeild // \u0026quot;overite str\u0026quot;\r// 父子元件的深層物件仍然指向同一個\robj.deepObj.a // 1\robjParent.deepObj.a = 9\robj.deepObj.a // 9\rObject.fromEntries 從 Array 或 key-value map 產生 Object\nObject.fromEntries(iterable);\n從 Array 或 Map 產生 Object // 從 Map 產生 Object\rconst map = new Map([ ['foo', 'bar'], ['baz', 42] ]);\rconst obj = Object.fromEntries(map);\rconsole.log(obj); // { foo: \u0026quot;bar\u0026quot;, baz: 42 }\r// 從 Array 產生 Object\rconst arr = [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ];\rconst obj = Object.fromEntries(arr);\rconsole.log(obj); // { 0: \u0026quot;a\u0026quot;, 1: \u0026quot;b\u0026quot;, 2: \u0026quot;c\u0026quot; }\r搭配 Array.prototype.map 對 Object 元素迭代處理 const object1 = { a: 1, b: 2, c: 3 };\rconst object2 = Object.fromEntries(\rObject.entries(object1)\r.map(([ key, val ]) =\u0026gt; [ key, val * 2 ])\r);\rconsole.log(object2);\r// { a: 2, b: 4, c: 6 }\rObject.assign Object.assign(target, …sources)\n將(多個)來源物件(…sources)的屬性合併到目標物件(target)上，並回傳合併後的目標物件(target)。如果來源物件或目標物件有相同屬性，位於較後面的參數的物件屬性會覆蓋前面的，非深層複製，對於物件中的陣列、子物件只能複製參照。\n複製物件 const obj = { a: 1 };\rconst copy = Object.assign({}, obj);\rconsole.log(copy); // { a: 1 }\r// 原物件改變不會影響到複製的物件\robj.a=2\rcopy.a // 1\r合併物件 const o1 = { a: 1 };\rconst o2 = { b: 2 };\rconst o3 = { c: 3 };\rconst obj = Object.assign(o1, o2, o3);\rconsole.log(obj); // { a: 1, b: 2, c: 3 }\r// 由於 o2, o3 合併到 o1，所以 o1 改變\rconsole.log(o1); // { a: 1, b: 2, c: 3 }\r// 回傳的 obj ,被合併的 o1　實際上是同一個物件的參照\ro1===obj // true\rObject.entries Object.entries(obj)\n取得 [key, value]的 map array進行迭代。\n取得物件的 Key-Value Map const obj = { foo: 'bar', baz: 42 }; const map = new Map(Object.entries(obj));\rconsole.log(map); // Map { foo: \u0026quot;bar\u0026quot;, baz: 42 }\r配合 Array 的解構賦值迭代物件 取得Map之後就不指向原物件，因此無法用這個方法改變原物件\nconst obj = { foo: 'bar', baz: 42 };\r// [key, value] 運用了　Array Destructuring\rObject.entries(obj).forEach(([key, value]) =\u0026gt; console.log(`${key}: ${value}`)); // \u0026quot;foo: bar\u0026quot;, \u0026quot;baz: 42\u0026quot;\rObject.values Object.values(obj)\nObject.keys 取得可列舉屬性的 Array，順序和 for…in 語句一樣，差別在於 for….in 會列舉出原型鏈中的屬性但 Object.keys 不會。\n取得物件屬性陣列 const object1 = {\ra: 'somestring',\rb: 42,\rc: false\r};\rconsole.log(Object.values(object1));\rObject.keys Object.keys(obj)\nObject.keys 取得可列舉屬性的”名稱”的 Array\n取得物件的 Key Array const object1 = {\ra: 'somestring',\rb: 42,\rc: false\r};\rconsole.log(Object.keys(object1));\r// expected output: Array [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]\rReference https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object ","date":"May 20, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/javascript/js-obj-func/","summary":"\u003cp\u003e紀錄常用的 Object 方法，細節可以到MDN看\u003c/p\u003e\n\u003ch1 id=\"objectcreate\"\u003eObject.create\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eObject.create(proto, [propertiesObject])\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e以傳入的參數作為prototype建立一個新物件，這個方法只能複製只帶有 primitive type 無法 deep copy，建立的物件所帶的函式、巢狀物件、Array等等…都和 prototype 共用。\u003c/p\u003e\n\u003ch2 id=\"以特定object-作為-prototype-建立新物件\"\u003e以特定Object 作為 Prototype 建立新物件\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst objParent = {\r\n  parentFeild: 'parent feild',\r\n  parentFunc: function () {\r\n    console.log('This is parent Func')\r\n  },\r\n  deepObj: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n}\r\n\r\n// 以 objParent 作為 prototype 建立 obj 物件\r\nconst obj = Object.create(objParent)\r\n\r\n// objFeild 只存在 obj 上\r\nobj.objFeild = 'obj feild'\r\n\r\n// 可從建立的 obj 呼叫 prototype 的屬性, 方法\r\nobj.parentFeild // \u0026quot;parent feild\u0026quot;\r\nobj.parentFunc() // This is parent Func\r\n\r\n// 從 prototype 繼承的屬性可覆寫\r\nobj.parentFeild = 'overite str'\r\nobj.parentFeild // \u0026quot;overite str\u0026quot;\r\n\r\n// 父子元件的深層物件仍然指向同一個\r\nobj.deepObj.a // 1\r\nobjParent.deepObj.a = 9\r\nobj.deepObj.a // 9\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"objectfromentries\"\u003eObject.fromEntries\u003c/h1\u003e\n\u003cp\u003e從 Array 或 key-value map 產生 Object\u003c/p\u003e","tags":null,"title":"[JS] Object 常用方法"},{"categories":null,"contents":"基於原型 (Prototype-Based) 的 JavaScript 一般物件導向式(OOP; Object Oriented Programming) 程式語言 (如：java、c++、c#) 當中的物件是由類別模板 (class) 產生實體物件 (instance)，實體物件的屬性各自獨立。類別模板上可設置共用的靜態資源包含靜態方法 (static method)、靜態屬性 (static field)，而這些靜態資源可以在沒有建立實體的情況下透過類別名稱直接取用。\nJavaScript 中的物件通常隸屬於另一個物件，這種隸屬關係類似物件導向語言的繼承，而在這種關係中的上層物件稱為原型 (Prototype)。原型本身又有自己所屬的原型，這種物件層層繼承的關係稱為原型鏈 (Prototype Chain)，幾乎所有物件的最上層原型是一個構造函數叫做 Object 的物件。\n因此一般物件導向式語言稱為基於類別 (Class-Based) 的語言；而 Javascript 是基於原型 (Prototype-Based) 的語言。\n建立物件原型 JavaScript 本身沒有類別模板的概念，是以構造函數 (constructor) 建立物件，物件可以將 constructor 屬性指向構造函數，但並非所有物件都有構造函數，具有構造函數的物件可直接以構造函數產生原型鏈下一層物件；不具有構造函數的物件只能在其他物件建立完成後，以其他方式設置為其他物件的原型。\n建立原型的方法就是直接宣告一個函數，JavaScript 會自動把該函數作為構造函數，並自動建立一個隸屬於 Object.prototype 之下的匿名物件，並把宣告的函數指定給該匿名物件的 constructor 屬性。\n// 宣告一個函數 Foo\rfunction Foo (){}\r// Foo.prototype 在 Foo 被宣告時自動建立\rFoo.prototype // {constructor: ƒ}\r// Foo.prototype 的 constructor 屬性自動指向 Foo\rFoo.prototype.constructor === Foo // true\r建立物件 透過構造函數 // 建立一個物件\rlet bar = new Foo{} // {}\r直接對變數賦值 JavaScript 對變數賦值底層行為：以 Object 構造函數建立物件，然後對物件並賦值（故賦值發生在物件建立之後）\n// 建立一個物件\rlet obj = { a: 1} // {a: 1}\r// obj 的原型是 Object.prototype\robj.__proto__ === Object.prototype // true\r// a: 1 是 obj 擁有的屬性\robj.hasOwnProperty('a') // true\r從沒有構造函數的物件延伸 物件本身沒有構造函數時，可用 Object.create() 將物件作為原型建立其他物件。\n// 建立一個物件\rlet objProto = {}\r// 以 objProto 為原型建立一個物件\rlet obj = Object.create(objProto)\r// obj 的原型為 objProto\robj.__proto__ === objProto // true\r取得物件原型 透過直接聲明函數所產生的原型需要透過兩個方法指涉：\n透過構造函數 prototype 屬性 構造函數物件建立時會取得 prototype 屬性，prototype 屬性指向該構造函數所屬的原型，一般以 [構造函數名稱].prototype 取得該構造函數所屬原型，以便在原型上加入屬性。\n透過物件 proto 屬性 Object.prototype 原型鏈上的物件可透過兩個屬性存取原型：proto、[[Prototype]]。差別在於[[Prototype]]是私有屬性無法由外部存取；proto 屬性是存取[[Prototype]]的外部接口，ES6之後 proto 屬性就被列為 JavaScript 標準，因此可透過[物件].proto 可取得該物件的上層原型。\n透過 Object.getPrototypeOf() Object.getPrototypeOf(物件) 可取得物件的原型。\nObject.prototype 原型鏈 JavaScript 定義構造函數時自動產生的”物件(有構造函數)”預設原型是 Object，得到 [Object]-[物件(有構造函數)]-[物件(無構造函數)] 的階層關係。\n// Foo 的原型是 Function.prototype\rFoo.__proto__ === Function.prototype // true\r// Function.prototype 再上去的原型是 Object.prototype\rFunction.prototype.__proto__ === Object.prototype // true\r// Object.prototype 位於原型鏈最最頂層，因此 __prototype 屬性是 null\rObject.prototype.__proto__ // null\r以直接指派物件給變數的方式建立物件，JavaScirpt 會自動使用構造函數 Object 建立物件，得到 [Object]-[物件(無構造函數)] 的階層關係\n// 以賦值直接建立的 obj ，原型就是 Object.prototype\robj.__proto__ === Object.prototype // true\rObject.prototype 原型鏈關係整理 原型鏈關係判斷 Object.prototype.isPrototypeOf() 用於判斷物件是否為其他物件的原型；而 instanceof 用於判斷物件是否為構造函數產生的實體。\n判斷物件和物件的關係 function Foo(){}\rlet bar = new Foo()\r// Foo 建立的物件，會以 Foo.prototype 作為物件原型\rFoo.prototype.isPrototypeOf(bar) // true\r判斷物件和構造函數的關係 function Foo(){}\rlet bar = new Foo()\r// bar 是構造函數 Foo 建立的物件\rbar instanceof Foo // true\r物件屬性與物件資源共用策略 JavaScript 的繼承和物件導向語言規則不同，物件擁有自己的屬性， 但原型鏈上的資源(屬性、方法)都如同是物件自己的屬性一般可透過物件直接存取。\n屬性優先權 物件本身的屬性存取權優先於原型鏈上的屬性，因此如果嘗試存取物件、原型鏈上名稱相同的屬性會獲得物件屬性，除非明確指出要存取原型上的屬性。因此存取物件屬性時，該屬性可能來自三種方式，以存取權優先順序排列：\n物件建立後：直接指派給物件的屬性。 物件建立時：構造函數上以 this 賦值的物件屬性。 原型鍊上的屬性。 function foo(){\r// 物件建立時：構造函數上以 this 賦值的物件屬性\rthis.a=2\rthis.b=2\r}\r// 原型上的屬性\rfoo.prototype.a=1\rfoo.prototype.b=1\rfoo.prototype.c=1\rlet obj = new foo()\r// 物件建立後：再指派給物件的屬性\robj.a=3\r// 可以看出建立後指派的屬性 a=3 蓋過構造函數內以 this 賦值的屬性 a=2。\robj // foo {a: 3, b: 2}\r// 原型鍊上的屬性 c 不在物件上，但物件仍然可以和自己的屬性一般存取\robj.c // 1\r構造函數產生的物件，原型鍊頂層是 Object.prototype，因此 Object.prototype 定義的所有資源（屬性、方法）都可以直接呼叫：\n// 宣告一個函數 animal\rfunction animal(){}\r// animal 的物件原型上層是 Object\ranimal.prototype.__proto__ === Object.prototype // true\rlet deer = new animal()\r// animal 建立的 deer 可以直接呼叫 Object.prototype 上定義的 toString()\rdeer.toString() // \u0026quot;[object Object]\u0026quot;\r// deer 呼叫的 toString 實際上就是 Object.prototype.toString\rdeer.toString === animal.prototype.__proto__.toString // true\r物件資源共用策略 由於原形鏈上的屬性都可被衍生的物件取用， 因此 JavaScript 共用資源的做法是把資源連結到物件原型上，如此一來物件物件時不必擁有自己一份資源，可以往上從物件原型取得，對必須大量產生物件的操作可有效改善效能。\n需要注意的是應避免擴充 Object.prototype 或其他 JavaScript 內建的原型（MDN 上歸類為 monkey patching），除非擴充內建原型的目的是 polyfill（使舊版的 JavaScript 引擎支持新功能）。\n// 宣告一個構造函數\rfunction foo(){}\r// 在原型上加入資源(可以是屬性或方法)\rfoo.prototype.hello = function(){\rconsole.log('hello')\r}\r// 該資源可以從建立的物件直接取得\rlet obj1 = new foo()\rlet obj2 = new foo()\robj1.hello() // \u0026quot;hello\u0026quot;\robj2.hello() // \u0026quot;hello\u0026quot;\r// 並且呼叫的資源 hello 是同一份\robj1.hello === obj2.hello // true\r// 在已建立物件上分別註冊的資源，即使完全相同，也不會是同一份\robj1.hello1 = function(){ console.log('hello1') }\robj2.hello1 = function(){ console.log('hello1') }\robj1.hello1 === obj2.hello1 // false\r判斷物件資源所屬 判斷屬性存在於物件或原型鏈上 Object.prototype.hasOwnProperty()\nfunction Foo(){}\r// 把 hello 註冊在原型上\rFoo.prototype.hello = function(){\rconsole.log('hello')\r}\rlet bar = new Foo();\r// 物件 bar 可以存取原型的函式 hello\rbar.hello(); // hello\r// hello 不是 bar 自己的資源\rbar.hasOwnProperty('hello') // false\r// hello 是原型的資源\rFoo.prototype.hasOwnProperty('hello') // true\r原型鏈函數資源中的 this JavsScript 中 函數的 this 指向呼叫函數的物件，因此物件呼叫原型上的函數時，原型上的函數內如果有關鍵字 this ，則會指向物件本身，而非函數所在的原型：\nfunction foo(){}\rfoo.prototype.name = \u0026quot;prototype\u0026quot;\rfoo.prototype.echo = function(){\rconsole.log(this.name)\r}\r// 函數中的 this 關鍵字指向呼叫的物件，因此 this.name 就是 bar.name\rbar = new foo();\rbar.name = \u0026quot;bar\u0026quot;\rbar.echo() // bar\r串聯原型鏈 JavaScript 試圖尋找不存在或位於頂層原型鏈上的資源時，會循原型鏈往上尋找，因此串連的原型鏈過長會影響效能，應適時將原型鏈打斷。\n延伸原型鏈 Object.create() let objProto = {}\r// 以 objProto 作為原型建立物件 createdObj let createdObj = Object.create(objProto )\r// 確認 createdObj 的原型是 objProto\rcreatedObj .__proto__ === objProto // true\r設定物件原型 Object.setPrototypeOf() MDN 當中提到 Object.setPrototypeOf () 在各瀏覽器中的實作效能並不好，大量使用時應以 Object.create() 代替。\n// 宣告兩個物件\rlet obj1 = { name: \u0026quot;obj1\u0026quot; }\rlet obj2 = { name: \u0026quot;obj2\u0026quot; }\r// 原型鏈中兩個物件都直接建立於 Object.prototype 之下\robj1.__proto__ === Object.prototype //true\robj2.__proto__ === Object.prototype //true\r// 將 obj1 設定為 obj2 的原型\rObject.setPrototypeOf(obj2, obj1)\robj2.__proto__ === obj1 // true\r// 此時 Object.prototype 不再是 obj2 的上層原型\robj2.__proto__ === Object.prototype // false\r// 這時候要透過 obj2 取得 Object.prototype 就需要再上溯一層\robj2.__proto__.__proto__ === Object.prototype // true\rES6 物件語法糖 class ES5/6 後出現的 class 是構造函數的語法糖，與一般 java 中認知的 class 並不相同，需要以原型鏈的概念對照。\nclass, extends, constructor, super class Person {\rconstructor(firstName, lastName) {\rthis.firstName = firstName;\rthis.lastName = lastName;\r}\r}\r// Person 實際上是建構函數的名稱 typeof Person // \u0026quot;function\u0026quot;\r// Person 所指涉的原型，上層是 Object.prototype\rPerson.prototype.__proto__ === Object.prototype // true\rclass Peter extends Person {\rconstructor(lastName) {\r// 建構函數 Peter 裡面呼叫物件原型的建構函數 Person super('Peter', lastName);\r}\r// greetings 的 getter\rget name() {\rreturn this.firstName + \u0026quot;, \u0026quot; + this.lastName;\r}\r// lastName 的 setter\rset lastName (value) {\rthis.lastName = value;\r}\r}\r// Peter 是另一個建構函數，所屬的物件以 Person.prototype 作為原型\rPeter.prototype.__proto__ === Person.prototype // true\r// peter 接在 Peter.prototype 下\rvar peter = new Peter();\rsquare.__proto__ === Square.prototype // true\rstatic Static 語法把資源綁定到構造函數而非原型本身，因 static 資源此需透過構造函數名稱取得，語法糖把函數名稱視為類別名稱，就好比物件導向語言中的靜態資源需要透過類別名稱取得一般。\nclass Person {\rstatic isMonkey() {\rreturn false;\r}\r}\rlet p = new Person()\r// 靜態資源 isMonkey 在構造函數上，而非物件原型上\rp.__proto__.hasOwnProperty('isMonkey') // false\rp.__proto__.constructor.hasOwnProperty('isMonkey') // true\r// 無法透過物件直接取用靜態資源\rp.isMonkey() /* Uncaught TypeError: t.triple is not a function\rat \u0026lt;anonymous\u0026gt;:1:3 */\r// 靜態資源必須透過類別(構造函數)名稱取得\rPerson.isMonkey() // false\rReference https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Details_of_the_Object_Model https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Classes\n","date":"May 20, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/javascript/js-prototype/","summary":"\u003ch1 id=\"基於原型-prototype-based-的-javascript\"\u003e基於原型 (Prototype-Based) 的 JavaScript\u003c/h1\u003e\n\u003cp\u003e一般物件導向式(OOP; Object Oriented Programming) 程式語言 (如：java、c++、c#) 當中的物件是由類別模板 (class) 產生實體物件 (instance)，實體物件的屬性各自獨立。類別模板上可設置共用的靜態資源包含靜態方法 (static method)、靜態屬性 (static field)，而這些靜態資源可以在沒有建立實體的情況下透過類別名稱直接取用。\u003c/p\u003e\n\u003cp\u003eJavaScript 中的物件通常隸屬於另一個物件，這種隸屬關係類似物件導向語言的繼承，而在這種關係中的上層物件稱為原型 (Prototype)。原型本身又有自己所屬的原型，這種物件層層繼承的關係稱為原型鏈 (Prototype Chain)，幾乎所有物件的最上層原型是一個構造函數叫做 Object 的物件。\u003c/p\u003e\n\u003cp\u003e因此一般物件導向式語言稱為基於類別 (Class-Based) 的語言；而 Javascript 是基於原型 (Prototype-Based) 的語言。\u003c/p\u003e\n\u003ch1 id=\"建立物件原型\"\u003e建立物件原型\u003c/h1\u003e\n\u003cp\u003eJavaScript 本身沒有類別模板的概念，是以構造函數 (constructor) 建立物件，物件可以將 constructor 屬性指向構造函數，但並非所有物件都有構造函數，具有構造函數的物件可直接以構造函數產生原型鏈下一層物件；不具有構造函數的物件只能在其他物件建立完成後，以其他方式設置為其他物件的原型。\u003c/p\u003e\n\u003cp\u003e建立原型的方法就是直接宣告一個函數，JavaScript 會自動把該函數作為構造函數，並自動建立一個隸屬於 Object.prototype 之下的匿名物件，並把宣告的函數指定給該匿名物件的 constructor 屬性。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// 宣告一個函數 Foo\r\nfunction Foo (){}\r\n\r\n// Foo.prototype 在 Foo 被宣告時自動建立\r\nFoo.prototype // {constructor: ƒ}\r\n// Foo.prototype 的 constructor 屬性自動指向 Foo\r\nFoo.prototype.constructor === Foo // true\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"建立物件\"\u003e建立物件\u003c/h1\u003e\n\u003ch2 id=\"透過構造函數\"\u003e透過構造函數\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// 建立一個物件\r\nlet bar = new Foo{} // {}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"直接對變數賦值\"\u003e直接對變數賦值\u003c/h2\u003e\n\u003cp\u003eJavaScript 對變數賦值底層行為：以 Object 構造函數建立物件，然後對物件並賦值（故賦值發生在物件建立之後）\u003c/p\u003e","tags":null,"title":"[JS] JavaScript 當中的原型繼承鏈模型"},{"categories":null,"contents":"宣告 這個動作是 Extends Array Interface\ninterface Array\u0026lt;T\u0026gt; {\rnewfunc(o: T): Array\u0026lt;T\u0026gt;;\r}\rArray.prototype.newfunc = function (o) {\r// some code return this;\r}\r使用 使用者要先拿到被 extend 的 interface\ndeclare global {\rinterface Array\u0026lt;T\u0026gt; {\rnewfunc(o: T): Array\u0026lt;T\u0026gt;;\r}\r}\rReference stackoverflow - extending array in typescript bobbyhadz - typescript-array-extend ","date":"May 20, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/typescript/ts-extend-global-obj/","summary":"\u003ch3 id=\"宣告\"\u003e宣告\u003c/h3\u003e\n\u003cp\u003e這個動作是 Extends Array Interface\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ts\"\u003einterface Array\u0026lt;T\u0026gt; {\r\n  newfunc(o: T): Array\u0026lt;T\u0026gt;;\r\n}\r\n\r\nArray.prototype.newfunc = function (o) {\r\n  // some code \r\n  return this;\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"使用\"\u003e使用\u003c/h3\u003e\n\u003cp\u003e使用者要先拿到被 extend 的 interface\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ts\"\u003edeclare global {\r\n  interface Array\u0026lt;T\u0026gt; {\r\n    newfunc(o: T): Array\u0026lt;T\u0026gt;;\r\n  }\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"reference\"\u003eReference\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://stackoverflow.com/questions/12802383/extending-array-in-typescript\" target=\"_blank\" rel=\"noopener\"\u003estackoverflow - extending array in typescript\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://bobbyhadz.com/blog/typescript-array-extend\" target=\"_blank\" rel=\"noopener\"\u003ebobbyhadz - typescript-array-extend\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"[TS] Typescript 在標準內建物件加上屬性"},{"categories":null,"contents":"紀錄常用的 Array 方法，細節可以到MDN看\n陣列操作 尾端彈出 Array.prototype.pop()、推入 Array.prototype.push() arr.pop()\narr.push(element1[, \u0026hellip;[, elementN]])\nconst arr=[1, 2, 3, 4]\rarr.pop()\rconsole.log(arr) // [1, 2, 3]\rarr.push(5)\rconsole.log(arr) // [1, 2, 3, 5]\r首端彈出 Array.prototype.shift()、推入 Array.prototype.unshift() arr.shift()\narr.unshift(element1[, \u0026hellip;[, elementN]])\nconst arr=[1, 2, 3, 4]\rarr.shift()\rconsole.log(arr) // [2, 3, 4]\rarr.unshift(0)\rconsole.log(arr) // [0, 2, 3, 4]\r指定位置插入/移除/取代 Array.prototype.splice() let arrRemoved = arr.splice(start[, deleteCount[, item1[, item2[, \u0026hellip;]]]])\n可以說式集移除、插入、取代(移除+插入)於一身的重要函式，並且將被移除的區段做為新陣列回傳，可根據傳入的參數將使用場景分類如下表，可幫助理解：\n添加item 不添加item deleteCount=0 在現有位置添加元素 (無意義) deleteCount\u0026gt;0 取代現有元素 範圍移除元素 範圍移除元素 const arr=[0, 1, 2, 3, 4, 5, 6]\r// 移除索引位置3的元素，移除範圍為1\rlet removed = arr.splice(3, 1)\rconsole.log(removed) // [3]\rconsole.log(arr) // [0, 1, 2, 4, 5, 6]\r在現有位置添加元素 const arr=[0, 1, 2, 3, 4, 5, 6]\r// 移除索引位置3的元素，移除範圍為0，並且插入3.1, 3.2\rlet removed = arr.splice(3, 0, 3.1, 3.2)\r// 這時候獲得的 removed 為空陣列\rconsole.log(removed) // []\r// 插入的元素從索引位置3的地方開始\rconsole.log(arr) // [0, 1, 2, 3.1, 3.2, 3, 4, 5, 6]\r取代現有元素 const arr=[0, 1, 2, 3, 4, 5, 6]\r// 移除索引為3的元素，移除長度範圍為2\r// 並且插入元素 10, 11, 12\rlet removed = arr.splice(3, 2, 10, 11, 12)\rconsole.log(removed) // [3, 4]\rconsole.log(arr) // [0, 1, 2, 10, 11, 12, 5, 6]\r複製陣列內特定區塊至特定位置 Array.prototype.copyWithin() arr.copyWithin(target[, start[, end]])\nconst arr = [1, 2, 3, 4, 5];\r// 將索引3-4之間的區塊(\u0026quot;4\u0026quot;)貼到索引0(取代0)\rconsole.log(arr.copyWithin(0, 3, 4)); // [4, 2, 3, 4, 5]\r// 將索引3到結束之間的區塊(4, 5)貼到索引1(取代1,2)\rconsole.log(arr.copyWithin(1, 3)); // [4, 4, 5, 4, 5]\r全部或指定位置填滿 Array.prototype.fill() arr.fill(value[, start[, end]])\n把陣列內全部的元素，或指定的索引範圍以特定值填滿\n如果傳入的值是物件，會以物件的參照填滿 如果給定的索引 index 或 end 是負值，則以 arr.length+index 計算 // 全部填滿\r[1, 2, 3].fill(4); // [4, 4, 4]\r// 指定位置以後填滿給定的值\r[1, 2, 3].fill(4, 1); // [1, 4, 4]\r// 指定範圍填滿\r[1, 2, 3].fill(4, 1, 2); // [1, 4, 3]\r// 若為負值則自動加上長度(只會加一次)，因此(4, -3, -2)等於(4, 0, 1)\r[1, 2, 3].fill(4, -3, -2); // [4, 2, 3]\r// 指定範圍超出長度則無作用\r[1, 2, 3].fill(4, 3, 5); // [1, 2, 3]\r// NaN 無效\r[1, 2, 3].fill(4, NaN, NaN); // [1, 2, 3]\r[].fill.call({ length: 3 }, 4); // {0: 4, 1: 4, 2: 4, length: 3}\r// 物件複製的是參照，指向同一物件\rlet arr = Array(3).fill({}) // [{}, {}, {}];\rarr[0].hi = \u0026quot;hi\u0026quot;; // [{ hi: \u0026quot;hi\u0026quot; }, { hi: \u0026quot;hi\u0026quot; }, { hi: \u0026quot;hi\u0026quot; }]\r元素反轉 Array.prototype.reverse() arr.reverse()\nlet a = [1, 2, 3];\rlet b = a.reverse(); console.log(a); // [3, 2, 1]\rconsole.log(b); // [3, 2, 1]\r// 回傳的陣列指向被反轉的原本陣列\ra===b // true\r元素排序 Array.prototype.sort() arr.sort([compareFunction])\n對陣列進行 in place 排序，且回傳原陣列，如果不給定 compareFunction 則預設依據字串 Unicode 編碼進行比對後進行升冪排序，但根據環境實作不同時間/空間複雜度也不同，且各環境下同一陣列的排序結果也不一定相同。\ncompareFunction(a, b) \u0026gt; 0: 把 b 排在 a 之前。 compareFunction(a, b) = 0: 不改變排序。 compareFunction(a, b) \u0026lt; 0: 把 a 排在 b 之前。 // 預設是升冪排序\r[2, 1, 3].sort() // [1, 2, 3]\r// 針對物件排序\rlet objs = [\r{ key: 'Peter', value: 36 },\r{ key: 'Vicky', value: 35 },\r{ key: 'Red', value: 37 },\r...\r];\r// 根據 value 屬性排序\robjs.sort(function (a, b) {\rreturn a.value - b.value;\r});\r// 根據 name 排序\ritems.sort(function(a, b) {\r// 一般來說忽視大小寫\rlet keyA = a.key.toUpperCase(); let keyB = b.key.toUpperCase();\rif (keyA \u0026lt; keyB) {\rreturn -1;\r}\rif (keyA \u0026gt; keyB) {\rreturn 1;\r}\r// names must be equal\rreturn 0;\r});\rP.S. 如果進行大量排序操作可轉為Map排序後再轉回陣列，效能較好 (詳見MDN)\n處理每個元素 Array.prototype.forEach() arr.forEach(function callback(currentValue[, index[, array]]) {}[, thisArg]);\n對每個陣列元素傳入並執行給定的 callback 函式，forEach 是 blocking 操作，但每個 callback 是並行執行無法區分先後順序！如果要循序執行必須要加以改造，或是改用 for…of，只有在每個 callback 彼此間沒有依賴關係時才使用 forEach。\n取值/求值 取得陣列長度 Array.length 從開頭或特定位置取得元素首次出現的索引 Array.prototype.indexOf() arr.indexOf(searchElement[, fromIndex])\n取得元素 最後出現的索引 Array.prototype.lastIndexOf() arr.lastIndexOf(searchElement[, fromIndex])\n取得滿足回呼函式的索引 Array.prototype.findIndex() arr.findIndex(callback[, thisArg])\n取得符合判斷式的第一個元素值 Array.prototype.find() arr.find(callback[, thisArg])\n執行 reducer function 取值 Array.prototype.reduce() arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue)\nreducer 接收一個 callback 並且對每個第一個之外的每個元素執行 callback (如果有提供 initialValue 則也會將第一個元素納入計算)，callback 函式參數如下：\naccumulator：callback 函式上次回傳的結果 currentValue：目前正在處裡的陣列元素。 currentIndex：目前陣列元素的索引，如果沒有提供 initialValue 的時候從1開始，否則從 0 開始。 array：正在處裡的陣列。 initialValue：提供起始值讓第一個元素可以納入計算。 如果沒有提供 initialValue，累加時的型別判定不好掌握，時常產生預期之外的結果，因此最好習慣總是提供 initialValue，並且需注意 accumulator、currentValue 作為函示取值時是否為正確的型別。\nmaxCallback = ( acc, cur ) =\u0026gt;{\rlet max = Math.max(acc.x, cur.x)\rconsole.log(\u0026quot;acc: \u0026quot; + acc +\u0026quot;, cur: \u0026quot; + cur + \u0026quot;, max: \u0026quot; + max)\rreturn max }\r[ { x: 2 }, { x: 22 }, { x: 42 } ].reduce( maxCallback ); // 第一輪輸出正缺判定 acc.x, cur.x\r// acc: [object Object], cur: [object Object], max: 22\r// 第二輪 acc 實際上為 22，所以22.x=NaN，Math.max(NaN, 42)=NaN\r// acc: 22, cur: [object Object], max: NaN\r// 第三輪之後 acc 基本上就是 NaN\r良好的習慣：\n提供初始值。 以轉型函示(如 map )將要累計的值導出至新的 array 避免 callback 從物件中取值，新陣列再進行 reduce。 maxCallback = ( acc, cur ) =\u0026gt;{\rreturn Math.max(acc, cur) }\r[ { x: 2 }, { x: 22 }, { x: 42 } ]\r.map( el =\u0026gt; el.x )\r.reduce( maxCallback, -Infinity );\r// 42\r反向執行 reducer function 取值 Array.prototype.reduceRight() arr.reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue])\n取得以分隔符號連接元素的字串 Array.prototype.join() arr.join([separator])\n以分隔符號合併陣列中所有的元素成一個字串並回傳，分隔符號預設為’,’。\n// 使用預設的分隔符號 ','\r[1,2,3,4,5].join() // \u0026quot;1,2,3,4,5\u0026quot;\r// 不使用分隔符號\r[1,2,3,4,5].join('') // \u0026quot;12345\u0026quot;\r// 指定其他分隔符號\r[1,2,3,4,5].join('_') // \u0026quot;1_2_3_4_5\u0026quot;\r取得表示該陣列的字串 Array.prototype.toString() arr.toString()\n取得該陣列的文字描述，效果跟 arr.join() 一樣。\n[1,2,3,4,5].toString() // \u0026quot;1,2,3,4,5\u0026quot;\r取得新陣列 陣列建構方法 Array()、Array.of() let arr1 = new Array([capacity]);\nlet arr2 = Array.of(element0[, element1[, \u0026hellip;[, elementN]]])\nnew Array(5); // [empty × 5]\rArray.of(1,2,3,4,5) // [1, 2, 3, 4, 5]\r取得從字串、陣列產生的新陣列，可加入元素轉換函式 Array.from() Array.from(arrayLike [, mapFn [, thisArg]])\n從 array-like/iterable object 如 string、set、map、arguments獲得 shallow-copied 的陣列。\n// 拆解字串產生 Array\rArray.from('foo') // [ \u0026quot;f\u0026quot;, \u0026quot;o\u0026quot;, \u0026quot;o\u0026quot; ];\r// 將 set 轉為陣列，這裡會自動去掉一個重複的 foo const set = new Set(['foo', 'bar', 'baz', 'foo']);\rArray.from(set); // [\u0026quot;foo\u0026quot;, \u0026quot;bar\u0026quot;, \u0026quot;baz\u0026quot;]\r// 將 map、map.values、map.keys 轉為陣列\rconst map = new Map([['1', 'a'], ['2', 'b']]);\rArray.from(map); // [[1, a], [2, b]]\rArray.from(map .keys()); // ['1', '2']\rArray.from(map .values()); // ['a', 'b']\r// 從函式的引數獲得陣列\rlet args=[];\rfunction f(){\rargs = Array.from(arguments)\r}\rf(1,2,3)\rargs.toString() // \u0026quot;1,2,3\u0026quot;\r從特定區段產生新陣列 Array.prototype.slice() arr.slice([begin[, end]])\n[0, 1, 2, 3, 4, 5].slice(2, 4) // [2, 3]\r取得元素滿足回呼函式的新陣列 Array.prototype.filter() let newArray = arr.filter(callback(element[, index[, array]])[, thisArg])\nconst arr = [0, 1, 2, 3, 4, 5, 6]\rconst newArr = arr.filter(e =\u0026gt; e % 2 === 0)\rnewArr // [0, 2, 4, 6]\r取得串接多個陣列後的新陣列 Array.prototype.concat() let new_array = old_array.concat(value1[, value2[, \u0026hellip;[, valueN]]])\nconst arr = [0, 1, 2, 3]\rconst arr1 = [4, 5, 6]\rconst arr2 = [7, 8, 9]\rconst arrConcat = arr.concat(arr1, arr2)\r// arr 並沒有改變，串聯的陣列是新陣列\rarr // [0, 1, 2, 3]\rarrConcat // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r取得每個元素轉換後的新陣列 Array.prototype.map() let new_array = arr.map(function callback( currentValue[, index[, array]]) { // 回傳作為新陣列的元素 }[, thisArg])\nconst arr = [0, 1, 2, 3, 4, 5, 6]\rconst newArr = arr.map(e =\u0026gt; e * 2)\rnewArr // [0, 2, 4, 6, 8, 10, 12]\r取得多維陣列攤平後的新陣列 Array.prototype.flat() let newArray = arr.flat([depth]);\nArray.prototype.flat() 會自動清除空元素，並展開指定深度的巢狀陣列，深度預設值為 1。\n// arr1 深度為1，所以不指定深度就能攤開\rlet arr1 = [1, 2, [3, 4]];\rarr1.flat(); // [1, 2, 3, 4]\r// arr2 深度為2，因此需指定深度才能完整攤開\rlet arr2 = [1, 2, [3, 4, [5, 6]]];\rarr2.flat(); // [1, 2, 3, 4, [5, 6]]\rarr2.flat(2); // [1, 2, 3, 4, 5, 6]\r取得多維陣列以回呼函式攤平後的新陣列 Array.prototype.flatMap() var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) {\n// 回傳作為新陣列的元素\n}[, thisArg])\narr.flatMap(func) 的效果等於 arr.map(func).flat() 但效能較佳，不過攤開深度只能是1，當 map() 回傳的元素是陣列且需要透過 flate() 攤開呈現最終結果時，可改用 flateMap()，例如從”句子”陣列獲得”單字”陣列：\n// 假設要從句子陣列獲得單字的一維陣列\rlet arr1 = [\u0026quot;animal cell\u0026quot;, \u0026quot;have\u0026quot;, \u0026quot;mitochondria\u0026quot;];\r// 使用 map 處裡會獲得二維陣列，必須再串聯一次 flat()\rarr1.map(x =\u0026gt; x.split(\u0026quot; \u0026quot;)); // [[\u0026quot;animal\u0026quot;,\u0026quot;cell\u0026quot;],[\u0026quot;have\u0026quot;],[\u0026quot;mitochondria\u0026quot;]]\rarr1.map(x =\u0026gt; x.split(\u0026quot; \u0026quot;)).flat(); // [\u0026quot;animal \u0026quot;,\u0026quot;cell\u0026quot;,\u0026quot;have\u0026quot;, \u0026quot;mitochondria\u0026quot;]\r// flatMap 效果等價於 map().flat()，但效能更佳\rarr1.flatMap(x =\u0026gt; x.split(\u0026quot; \u0026quot;)); // [\u0026quot;animal \u0026quot;,\u0026quot;cell\u0026quot;,\u0026quot;have\u0026quot;, \u0026quot;mitochondria\u0026quot;]\r判斷 判斷該物件是否為陣列 Array.isArray() Array.isArray(obj)\n判斷陣列的每個元素是否皆滿足判斷函式 Array.prototype.every() arr.every(callback[, thisArg])\n判斷陣列是否有至少一個元素滿足判斷函式 Array.prototype.some() arr.some(callback[, thisArg])\n判斷陣列是否包含某元素值 Array.prototype.includes() arr.includes(searchElement[, fromIndex])\nReference https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array ","date":"April 29, 2020","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/javascript/js-arr-func/","summary":"\u003cp\u003e紀錄常用的 Array 方法，細節可以到MDN看\u003c/p\u003e\n\u003ch1 id=\"陣列操作\"\u003e陣列操作\u003c/h1\u003e\n\u003ch2 id=\"尾端彈出-arrayprototypepop推入-arrayprototypepush\"\u003e尾端彈出 Array.prototype.pop()、推入 Array.prototype.push()\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003earr.pop()\u003cbr\u003e\narr.push(element1[, \u0026hellip;[, elementN]])\u003c/p\u003e\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst arr=[1, 2, 3, 4]\r\narr.pop()\r\nconsole.log(arr)  // [1, 2, 3]\r\narr.push(5)\r\nconsole.log(arr)  // [1, 2, 3, 5]\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"首端彈出-arrayprototypeshift推入-arrayprototypeunshift\"\u003e首端彈出 Array.prototype.shift()、推入 Array.prototype.unshift()\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003earr.shift()\u003cbr\u003e\narr.unshift(element1[, \u0026hellip;[, elementN]])\u003c/p\u003e\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst arr=[1, 2, 3, 4]\r\narr.shift()\r\nconsole.log(arr) // [2, 3, 4]\r\narr.unshift(0)\r\nconsole.log(arr) // [0, 2, 3, 4]\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"指定位置插入移除取代-arrayprototypesplice\"\u003e指定位置插入/移除/取代 Array.prototype.splice()\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003elet arrRemoved = arr.splice(start[, deleteCount[, item1[, item2[, \u0026hellip;]]]])\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e可以說式集移除、插入、取代(移除+插入)於一身的重要函式，並且將被移除的區段做為新陣列回傳，可根據傳入的參數將使用場景分類如下表，可幫助理解：\u003c/p\u003e","tags":null,"title":"[JS] Array 常用方法"},{"categories":null,"contents":"台灣杉(Taiwania)是國網中心2018年啟用的超級電腦，登入時密碼必須附加OTP (One-time Password)，國網中心建議取得OTP的方式是從驗證器取得OTP密碼，但這樣的方式每次都需要打開驗證器(手機、chrome插件… etc)，並且需要手動輸入OTP，下面分享我從Windows以及Linux環境下登入台灣杉所使用的一鍵登入方式。\nOTP的演算法可粗分為HOTP (HMAC-based OTP)；以及基於HOTP的TOTP (Time-based OTP)，我們不必瞭解演算法細節，只需知道台灣杉採用Base32編碼作為TOTP金鑰(Secret)，時間間格為30秒，每30秒可以根據”Secret”與”當前時間區間”以sha1演算法生成一次性密碼(OTP，或稱為Key)，由於這是單向加密的過程所以無法用時間區間與Key逆推Secret，並且OTP在成功使用一次之後就會被伺服器廢棄，以確保安全性。\n注意事項 校時\n由於TOTP演算法依據當前時間區間產生OTP，如果作業系統的時間不正確則會產生錯誤的OTP，在Windows環境之下可以到國家時間與頻率標準實驗室的網頁下載NTP校時軟體，以管理員身分執行進行校時；Linux環境可以用下述指令更新時間並寫入BIOS： # 從NTP時間伺服器進行網路校時\rsudo ntpdate time.stdtime.gov.tw\r# 將更新的時間寫入BIOS\rsudo hwclock -w\r所有登入行為之間必須間隔30秒(包含使用winSCP、putty或從Linux直接登入)。 每個30秒區間會產生一個OTP，而該OTP一旦經過使用就會被伺服器廢棄而無法再用。我曾經連續登入以為程式壞了，但核對iService上面產生的密碼又是一樣的，後來才發現這件事…中間還因為連登失敗太頻繁還被鎖，因此記得間隔30秒以上再登入。 Linux要登入台灣衫需要將台灣衫加入know host，以生醫節點為例: ssh-keyscan 140.110.148.14 1\u0026gt;\u0026gt;~/.ssh/known_hosts 2\u0026gt;/dev/null\r從Windows登入台灣杉 前置工作 安裝Go，並設置GOPATH。 安裝putty。 安裝WinSCP。 知道怎麼打開windows的命令提示字元 (WIN+R、鍵入cmd、enter)。 編譯TOTP產生器 取得TOTP套件\ngo get github.com/pquerna/otp/totp\r撰寫程式碼main.go\npackage main\rimport (\r\u0026quot;fmt\u0026quot;\r\u0026quot;github.com/pquerna/otp/totp\u0026quot;\r\u0026quot;os\u0026quot;\r\u0026quot;time\u0026quot;\r)\rfunc main() {\rsecret := os.Args[1]\rcode, _ := totp.GenerateCode(secret, time.Now().UTC())\rfmt.Print(code)\r}\r編譯\ngo build -o taiwaniaOTP.exe main.go\r設置putty 按照圖片步驟設置putty session，如果不想修改預設字型可跳過步驟4~6，全部設置完成後要回Session標籤按Save(步驟7、8) 撰寫批次檔 (串聯TOTP產生器與putty session) 建立資料夾(例如: D:\\BioPkg\\taiwania)，把剛剛的taiwaniaOTP.exe丟進去，在資料夾內複製下面指令建立taiwania-putty.bat批次檔，按照步驟1~3進行設置：\n@echo off\r:: 1.設置putty執行檔位置\rSET putty=D:\\Programs\\putty.exe\r:: 2.設置固定密碼(取代password)\rSET regular_pw=password\r:: 3.設置TOTP金鑰(從iservice服務網複製的金鑰取代TOTPsecret)\rSET secret=TOTPsecret\r:: 取得totp\rfor /f %%i in ('%cd%/taiwaniaOTP.exe %secret%') do set totp=%%i\r:: 5.把taiwania-14取代成你剛剛設置的session name\rstart D:\\Programs\\putty.exe -load \u0026quot;taiwania-14\u0026quot; -pw %regular_pw%%totp%\rexit\r撰寫批次檔 (串聯TOTP產生器與WinSCP) 在資料夾內複製下面指令建立taiwania-sftp.bat，按照步驟1~4設置：\n@echo off\r:: 1.設置WinSCP執行檔位置\rSET winSCP=\u0026quot;C:\\Program Files (x86)\\WinSCP\\WinSCP.exe\u0026quot;\r:: 2.設置使用者名稱(取代userName)\rSET user=userName\r:: 3.設置固定密碼(取代password)\rSET regular_pw=password\r:: 4.設置TOTP金鑰(從iservice服務網複製的金鑰取代TOTPsecret)\rSET secret=TOTPsecret\r:: 取得totp\rfor /f %%i in ('%cd%/taiwaniaOTP.exe %secret%') do set totp=%%i\r:: 呼叫winSCP登入台灣杉資料傳輸專用節點\rstart %winSCP% sftp://%user%:%regular_pw%%totp%@140.110.148.21:22\rexit\r測試 目前為止我們完成了兩件事，接下來我們一分鐘的安全間隔進行測試，你可以在桌面上建立批次檔的捷徑方便登入，甚至是改icon讓它們更像一回事：\n雙擊taiwania-putty.bat呼叫putty session登入台灣杉生醫節點(140.110.148.14)。 雙擊taiwania-sftp.bat呼叫winSCP登入台灣杉的資料傳輸節點(140.110.148.21)。 從Linux(具有管理員權限)登入台灣杉 使用Linux的設定自動登入需要熟悉基本Linux操作(套件安裝、環境變數、shell script)，或是嘗試按照下列步驟設定，當然您也可以自行編譯上述的OTP產生器(從Windows登入小節所提到)取代oathtool：\n安裝oathtool、sshpass # 如果系統為Red Hat/CentOs/Fedora則改用yum\rsudo apt-get update\rsudo apt-get install oathtool sshpass\r設置腳本loginTaiwania.sh ##### loginTaiwania.sh #####\r#!/bin/bash\rsecret=\u0026quot;Enter-Your-Otp-Secret-Got-From-Nchc\u0026quot;\rtaiwaniaIP=\u0026quot;140.110.148.14\u0026quot;\ruserName=\u0026quot;Enter-Your-Id-On-Taiwania\u0026quot;\rfixedPW=\u0026quot;Enter-Your-Fixed-Password\u0026quot;\rotp=$(oathtool -b -d6 -s30 --totp=\u0026quot;sha1\u0026quot; ${secret})\rsshpass -p ${fixedPW}${otp} ssh ${userName}@${taiwaniaIP}\r予登入腳本執行權限 chmod a+x loginTaiwania.sh\r測試登入 ./loginTaiwania.sh\r從Linux(沒有管理員權限)登入台灣杉 有時候會用使用其他機器登入台灣杉，但是卻沒有管理員權限可以安裝sshpass、oathtool，以下是變通方法。\n確認sshpass、oathtool 查詢系統是否提供sshpass、oathtool，如果已有可以省略編譯的步驟，下面在台灣杉上查詢的結果顯示PATH中有sshpass但找不到oathtool，所以在台灣杉上可以跳過編譯sshpass的步驟。\n$ which sshpass\r/usr/bin/sshpass\r$ which oathtool\r/usr/bin/which: no oathtool in (/home/ux/xxx/bin:/home/xxx/bin:/cm/local/apps/gcc/6.3.0/bin:/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/usr/sbin:/cm/local/apps/environment-modules/3.2.10/bin:/opt/pbs/bin:/usr/bin:/usr/bin:/home/xxx/.local/bin:/home/xxx/bin)\r編譯sshpass 最後sshpass的可執行檔預期是/path/to/sshpass-1.06/sshpass。\n$ wget http://sourceforge.net/projects/sshpass/files/latest/download -O sshpass.tgz\r$ tar zxf sshpass.tgz\r$ cd sshpass-1.06\r$ ./configure \u0026amp;\u0026amp; make\r$ /path/to/sshpass-1.06/sshpass\rUsage: sshpass [-f|-d|-p|-e] [-hV] command parameters\r-f filename Take password to use from file\r-d number Use number as file descriptor for getting password\r-p password Provide password as argument (security unwise)\r-e Password is passed as env-var \u0026quot;SSHPASS\u0026quot;\rWith no parameters - password will be taken from stdin\r-P prompt Which string should sshpass search for to detect a password prompt\r-v Be verbose about what you're doing\r-h Show help (this screen)\r-V Print version information\rAt most one of -f, -d, -p or -e should be used\r編譯OTP產生器(oathtool替代方案) 要在像台灣杉類似的主機上編譯oathtool有點複雜，如果一定要用oathtool比較可行的方法是下載binary及so(參考附錄)，但最簡單的方法還是直接編譯自己的OTP產生器，這一步需要先安裝Go，並及設置GOPATH：\ngo get github.com/pquerna/otp/totp\r撰寫TOTP產生器 main.go\npackage main\rimport (\r\u0026quot;fmt\u0026quot;\r\u0026quot;github.com/pquerna/otp/totp\u0026quot;\r\u0026quot;os\u0026quot;\r\u0026quot;time\u0026quot;\r)\rfunc main() {\rsecret := os.Args[1]\rcode, _ := totp.GenerateCode(secret, time.Now().UTC())\rfmt.Print(code)\r}\r編譯TOTP產生器\ngo build -o taiwaniaOTP main.go\r設置腳本loginTaiwania.sh。 #!/bin/bash\rsecret=\u0026quot;Enter-Your-Otp-Secret-Got-From-Nchc\u0026quot;\rtaiwaniaIP=\u0026quot;140.110.148.14\u0026quot;\ruserName=\u0026quot;Enter-Your-Id-On-Taiwania\u0026quot;\rfixedPW=\u0026quot;Enter-Your-Fixed-Password\u0026quot;\r# 如果系統本身有提供oathtool，就把taiwaniaOTP改成oathtool\rotp=$(taiwaniaOTP ${secret})\rsshpass -p ${fixedPW}${otp} ssh ${userName}@${taiwaniaIP}\r測試登入 ./loginTaiwania.sh\r附錄：在沒有權限的主機上使用oathtool (練習抽取package、滿足相依性) 如果要在沒有權限的主機上使用oathtool，就得要自己下載rpm/deb，從裡面抽取binaries及Requires，下面分成rpm(RedHat/CentOS/Fedora)跟apt(Debian/Ubuntu)系統說明：\nrpm(RedHat/CentOS/Fedora)系統 查詢OS版本資訊，得知台灣衫的OS是Red Hat 7.3。\n$ lsb_release -d\rDescription: Red Hat Enterprise Linux Server release 7.3 (Maipo)\r到pkgs.org找相應的Binary Package rpm版本，我們點選CentOS 7的EPEL x86_64版本oathtool-2.4.1-9.el7.x86_64.rpm ( CentOS與Red Hat是相容的，EPEL代表Extra Packages for Enterprise Linux，rpm套件管理員當中描述的x86_64是指cpu的x86-64架構，雖然有伺服器已經開始採用較省電的ARM架構，但目前幾乎所有的伺服器架構都是x86-64 )，接著在Download底下取得Binary Package的下載連結，以下面的指令下載、展開、確認相依性：\n# 下載Binary Package\r$ wget http://download-ib01.fedoraproject.org/pub/epel/7/x86_64/Packages/o/oathtool-2.4.1-9.el7.x86_64.rpm\r# 抽取Binary Package\r$ rpm2cpio oathtool-2.4.1-9.el7.x86_64.rpm | cpio -ivd\r./usr/bin/oathtool\r./usr/share/doc/oathtool-2.4.1\r./usr/share/doc/oathtool-2.4.1/COPYING\r./usr/share/man/man1/oathtool.1.gz\r165 blocks\r# 查看oathtool相依性，not found標註代表相依性未滿足\r$ ldd ./usr/bin/oathtool\rlinux-vdso.so.1 =\u0026gt; (0x00002aaaaaaab000)\rliboath.so.0 =\u0026gt; not found\rlibc.so.6 =\u0026gt; /lib64/libc.so.6 (0x00002aaaaaad4000)\r/lib64/ld-linux-x86-64.so.2 (0x0000555555554000)\r下載oathtool未滿足的相依性，可以直接到剛剛取得下載連結的下載頁面，從Requires欄位下直接點選項目liboath.so.0()(64bit)的連結，一樣選擇CentOS 7的EPEL x86_64版本下載\n# 下載Binary Package\r$ wget http://download-ib01.fedoraproject.org/pub/epel/7/x86_64/Packages/l/liboath-2.4.1-9.el7.x86_64.rpm\r# 抽取Binary Package\r$ rpm2cpio liboath-2.4.1-9.el7.x86_64.rpm | cpio -ivd\r./etc/liboath\r./usr/lib64/liboath.so.0\r./usr/lib64/liboath.so.0.1.3\r./usr/share/doc/liboath-2.4.1\r./usr/share/doc/liboath-2.4.1/COPYING\r# 查看liboath.so.0相依性，可看到皆滿足\r$ ldd ./usr/lib64/liboath.so.0\rlinux-vdso.so.1 =\u0026gt; (0x00002aaaaaaab000)\rlibc.so.6 =\u0026gt; /lib64/libc.so.6 (0x00002aaaaacdf000)\r/lib64/ld-linux-x86-64.so.2 (0x0000555555554000)\r到這一步oathtool仍然找不到liboath.so.0，我們也無法把liboath.so.0所在的資料夾加入/etc/ld.so.conf的定義，所以我們要定義一個oathtool.sh腳本，腳本會自動新增LD_LIBRARY_PATH，告訴oathtool要去哪裡找我們剛剛下載的liboath.so.0：\n##### oathtool.sh #####\r#!/bin/bash\roathtool=\u0026quot;/path/to/oathtool\u0026quot;\rldPath=$(dirname $(readlink -f ${oathtool}))\u0026quot;/../lib64\u0026quot;\rexport LD_LIBRARY_PATH_OLD=${LD_LIBRARY_PATH}\rexport LD_LIBRARY_PATH=\u0026quot;${ldPath}:${LD_LIBRARY_PATH}\u0026quot;\r${oathtool} $@\rexport LD_LIBRARY_PATH=${LD_LIBRARY_PATH_OLD}\r現在oathtool.sh表現得就跟oathtool一樣了，以下測試：\n$ ./oathtool.sh\roathtool 2.4.1\rGenerate and validate OATH one-time passwords.\rUsage: oathtool [OPTIONS]... [KEY [OTP]]...\r-h, --help Print help and exit\r-V, --version Print version and exit\r--hotp use event-based HOTP mode (default=on)\r--totp use time-variant TOTP mode (default=off)\r-b, --base32 use base32 encoding of KEY instead of hex\r(default=off)\r-c, --counter=COUNTER HOTP counter value\r-s, --time-step-size=DURATION TOTP time-step duration (default=`30s')\r-S, --start-time=TIME when to start counting time steps for TOTP\r(default=`1970-01-01 00:00:00 UTC')\r-N, --now=TIME use this time as current time for TOTP\r(default=`now')\r-d, --digits=DIGITS number of digits in one-time password\r-w, --window=WIDTH window of counter values to test when\rvalidating OTPs\r-v, --verbose explain what is being done (default=off)\rReport bugs to: oath-toolkit-help@nongnu.org\roathtool home page: General help using GNU software: apt(Debian/Ubuntu)系統 查詢作業系統版本\n$ lsb_release -d\rDescription: Ubuntu 18.04.1 LTS\r到pkgs.org找相應的Binary Package apt版本，我們點選Ubuntu 18.04 LTS (Bionic Beaver)的Ubuntu Universe amd64版本oathtool_2.6.1-1_amd64.deb ( BSD Linux家族把x86-64架構稱為AMD64，目前幾乎所有的伺服器架構都是x86_64 )，接著在Download底下取得Binary Package的下載連結，以下面的指令下載、展開、確認相依性：\n# 先下載oathtool\r$ wget http://archive.ubuntu.com/ubuntu/pool/universe/o/oath-toolkit/oathtool_2.6.1-1_amd64.deb\r# 抽取oathtool到特定資料夾oathtool內\r$ dpkg -X oathtool_2.6.1-1_amd64.deb ./oathtool\r./\r./usr/\r./usr/share/\r./usr/share/doc/\r./usr/share/doc/oathtool/\r./usr/share/doc/oathtool/copyright\r./usr/share/man/\r./usr/share/man/man1/\r./usr/share/man/man1/oathtool.1.gz\r./usr/bin/\r./usr/bin/oathtool\r./usr/share/doc/oathtool/AUTHORS\r./usr/share/doc/oathtool/README\r./usr/share/doc/oathtool/NEWS.gz\r./usr/share/doc/oathtool/changelog.Debian.gz\r# 查看oathtool相依性\r$ ldd ./oath/usr/bin/oathtool\rlinux-vdso.so.1 (0x00007fff10bfe000)\rliboath.so.0 =\u0026gt; not found\rlibc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fda6c3ea000)\r/lib64/ld-linux-x86-64.so.2 (0x00007fda6c7db000)\r# 取得、抽取未滿足的相依性libc.so.6\r$ wget http://archive.ubuntu.com/ubuntu/pool/universe/o/oath-toolkit/liboath0_2.6.1-1_amd64.deb\r$ dpkg -X liboath0_2.6.1-1_amd64.deb ./oathtool\r./\r./usr/\r./usr/share/\r./usr/share/doc/\r./usr/share/doc/liboath0/\r./usr/share/doc/liboath0/AUTHORS\r./usr/share/doc/liboath0/README\r./usr/share/doc/liboath0/copyright\r./usr/share/doc/liboath0/NEWS.gz\r./usr/share/doc/liboath0/changelog.Debian.gz\r./usr/lib/\r./usr/lib/liboath.so.0.1.3\r./usr/lib/liboath.so.0\r# 檢查libc.so.6是否滿足\r$ ldd ./oath/usr/lib/liboath.so.0\rlinux-vdso.so.1 (0x00007ffc0f0f5000)\rlibc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8f6da78000)\r/lib64/ld-linux-x86-64.so.2 (0x00007f8f6e07d000)\r到這一步oathtool仍然找不到libc.so.6，我們也無法把libc.so.6所在的資料夾加入/etc/ld.so.conf的定義，所以我們要定義一個oathtool.sh腳本，腳本會自動新增LD_LIBRARY_PATH，告訴oathtool要去哪裡找我們剛剛下載的libc.so.6：\n##### oathtool.sh #####\r#!/bin/bash\roathtool=\u0026quot;/path/to/oathtool\u0026quot;\rldPath=$(dirname $(readlink -f ${oathtool}))\u0026quot;/../lib\u0026quot;\rexport LD_LIBRARY_PATH_OLD=${LD_LIBRARY_PATH}\rexport LD_LIBRARY_PATH=\u0026quot;${ldPath}:${LD_LIBRARY_PATH}\u0026quot;\r${oathtool} $@\rexport LD_LIBRARY_PATH=${LD_LIBRARY_PATH_OLD}\r現在oathtool.sh表現得就跟oathtool一樣了，以下測試：\n$ ./oathtool/usr/bin/oathtool.sh\roathtool 2.6.1\rGenerate and validate OATH one-time passwords.\rUsage: oathtool [OPTIONS]... [KEY [OTP]]...\r-h, --help Print help and exit\r-V, --version Print version and exit\r--hotp use event-based HOTP mode (default=on)\r--totp[=STRING] use time-variant TOTP mode (possible\rvalues=\u0026quot;sha1\u0026quot;, \u0026quot;sha256\u0026quot;, \u0026quot;sha512\u0026quot;\rdefault=`sha1')\r-b, --base32 use base32 encoding of KEY instead of hex\r(default=off)\r-c, --counter=COUNTER HOTP counter value\r-s, --time-step-size=DURATION TOTP time-step duration (default=`30s')\r-S, --start-time=TIME when to start counting time steps for TOTP\r(default=`1970-01-01 00:00:00 UTC')\r-N, --now=TIME use this time as current time for TOTP\r(default=`now')\r-d, --digits=DIGITS number of digits in one-time password\r-w, --window=WIDTH window of counter values to test when\rvalidating OTPs\r-v, --verbose explain what is being done (default=off)\rReport bugs to: oath-toolkit-help@nongnu.org\roathtool home page: General help using GNU software: ","date":"January 23, 2019","hero":"/images/default-hero.jpg","permalink":"https://blog.tigernaxo.com/posts/other/taiwania_login_oneclick/","summary":"\u003cp\u003e台灣杉(Taiwania)是國網中心2018年啟用的超級電腦，登入時密碼必須附加OTP (One-time Password)，國網中心建議取得OTP的方式是從驗證器取得OTP密碼，但這樣的方式每次都需要打開驗證器(手機、chrome插件… etc)，並且需要手動輸入OTP，下面分享我從Windows以及Linux環境下登入台灣杉所使用的一鍵登入方式。\u003c/p\u003e\n\u003cp\u003eOTP的演算法可粗分為HOTP (HMAC-based OTP)；以及基於HOTP的TOTP (Time-based OTP)，我們不必瞭解演算法細節，只需知道台灣杉採用Base32編碼作為TOTP金鑰(Secret)，時間間格為30秒，每30秒可以根據”Secret”與”當前時間區間”以sha1演算法生成一次性密碼(OTP，或稱為Key)，由於這是單向加密的過程所以無法用時間區間與Key逆推Secret，並且OTP在成功使用一次之後就會被伺服器廢棄，以確保安全性。\u003c/p\u003e\n\u003ch1 id=\"注意事項\"\u003e注意事項\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e校時\u003c/strong\u003e\u003cbr\u003e\n由於TOTP演算法依據當前時間區間產生OTP，如果作業系統的時間不正確則會產生錯誤的OTP，在Windows環境之下可以到國家時間與頻率標準實驗室的網頁下載NTP校時軟體，以管理員身分執行進行校時；Linux環境可以用下述指令更新時間並寫入BIOS：\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 從NTP時間伺服器進行網路校時\r\nsudo ntpdate time.stdtime.gov.tw\r\n# 將更新的時間寫入BIOS\r\nsudo hwclock -w\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e所有登入行為之間必須間隔30秒(包含使用winSCP、putty或從Linux直接登入)。\u003c/strong\u003e\n每個30秒區間會產生一個OTP，而該OTP一旦經過使用就會被伺服器廢棄而無法再用。我曾經連續登入以為程式壞了，但核對iService上面產生的密碼又是一樣的，後來才發現這件事…中間還因為連登失敗太頻繁還被鎖，因此記得間隔30秒以上再登入。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLinux要登入台灣衫需要將台灣衫加入know host\u003c/strong\u003e，以生醫節點為例:\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003essh-keyscan 140.110.148.14 1\u0026gt;\u0026gt;~/.ssh/known_hosts 2\u0026gt;/dev/null\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"從windows登入台灣杉\"\u003e從Windows登入台灣杉\u003c/h1\u003e\n\u003ch2 id=\"前置工作\"\u003e前置工作\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e安裝\u003ca href=\"https://golang.org/dl/\" target=\"_blank\" rel=\"noopener\"\u003eGo\u003c/a\u003e，並\u003ca href=\"https://github.com/golang/go/wiki/SettingGOPATH\" target=\"_blank\" rel=\"noopener\"\u003e設置GOPATH\u003c/a\u003e。\u003c/li\u003e\n\u003cli\u003e安裝\u003ca href=\"https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html\" target=\"_blank\" rel=\"noopener\"\u003eputty\u003c/a\u003e。\u003c/li\u003e\n\u003cli\u003e安裝\u003ca href=\"https://winscp.net/eng/download.php\" target=\"_blank\" rel=\"noopener\"\u003eWinSCP\u003c/a\u003e。\u003c/li\u003e\n\u003cli\u003e知道怎麼打開windows的命令提示字元 (WIN+R、鍵入cmd、enter)。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"編譯totp產生器\"\u003e編譯TOTP產生器\u003c/h2\u003e\n\u003cp\u003e取得TOTP套件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bat\"\u003ego get github.com/pquerna/otp/totp\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e撰寫程式碼main.go\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\r\n\r\nimport (\r\n        \u0026quot;fmt\u0026quot;\r\n        \u0026quot;github.com/pquerna/otp/totp\u0026quot;\r\n        \u0026quot;os\u0026quot;\r\n        \u0026quot;time\u0026quot;\r\n)\r\n\r\nfunc main() {\r\n        secret := os.Args[1]\r\n        code, _ := totp.GenerateCode(secret, time.Now().UTC())\r\n        fmt.Print(code)\r\n}\r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e編譯\u003c/p\u003e","tags":null,"title":"[台灣杉] 一鍵登入國網中心台灣杉(Taiwania)"}]