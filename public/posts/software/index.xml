<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>[架構] Architecture on YuCheng&#39;s Site</title>
    <link>https://0.0.0.0:1313/posts/software/</link>
    <description>Recent content in [架構] Architecture on YuCheng&#39;s Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 22 Apr 2023 20:58:00 +0800</lastBuildDate><atom:link href="https://0.0.0.0:1313/posts/software/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>[Program] 比較 Method chaining、fluent interface、c# 擴充方法</title>
      <link>https://0.0.0.0:1313/posts/software/pg-method-chaining/</link>
      <pubDate>Sat, 22 Apr 2023 20:58:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/software/pg-method-chaining/</guid>
      <description>&lt;p&gt;Method chaining、Fluent interface 和 擴充方法(Extension method) 三種雖然相似，但實則為不同的程式設計概念。&lt;/p&gt;
&lt;h2 id=&#34;method-chaining&#34;&gt;Method chaining&lt;/h2&gt;
&lt;p&gt;Method chaining 是一種技術，允許在一行程式碼中調用對象的一系列方法。鏈中的每個方法都返回被調用的對象，從而允許在同一個對象上調用下一個方法。這種技術用於創建更可讀和簡潔的代碼。&lt;/p&gt;
&lt;h2 id=&#34;fluent-interface&#34;&gt;Fluent interface&lt;/h2&gt;
&lt;p&gt;Fluent interface 是一種設計模式，使用方法串鏈創建更具表現力和可讀性的API。
Fluent interface 的目標是使代碼看起來更像自然語言，使其更容易理解和使用。
在 Fluent interface 中，每個方法調用返回一個對象，允許在同一個對象上調用下一個方法。這種技術通常用於庫和框架中，以為開發人員提供更直觀和自然的API。&lt;/p&gt;
&lt;h2 id=&#34;擴充方法&#34;&gt;擴充方法&lt;/h2&gt;
&lt;p&gt;擴充方法是一種在不修改類本身的情況下為現有類添加功能的方法。擴充方法在單獨的靜態類中定義，並像擴展類的方法一樣調用。這允許開發人員在不修改源代碼的情況下為現有類添加功能。擴充方法通常用於為現有類添加實用函數或為無法修改的類（例如第三方庫）添加功能。&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.thinkinmd.com/post/2020/03/02/coding-style-of-fluent-interface/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fluent Interface｜一種程式碼”寫作”風格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/extension-methods&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;擴充方法 (C# 程式設計手冊)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Method_chaining&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wiki-Method chaining&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[架構] 多層式架構(Multi-layer Architecture)</title>
      <link>https://0.0.0.0:1313/posts/software/arch-multi-layer/</link>
      <pubDate>Tue, 28 Mar 2023 23:34:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/software/arch-multi-layer/</guid>
      <description>&lt;p&gt;中文多層架構的層可翻作 layer 或 tier，兩者主要的差別在於 layer 指程式邏輯在應用程式的位置；而 tier 指 layer 在系統上實際部屬執行的位址，屬於物理層級的指涉。這一篇的層說的是 layer，談如何在軟體層面利用分層 (layer) 妥善安排程式碼，以 multi-layer 撰寫程式碼能將複雜的邏輯隔離開達成關注點分離(SoC, Separation of concerns)，好處有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低耦合：程式拆成各司其職的單元，降低彼此耦合，增加程式單元彈性(擴展性)、複用性。&lt;/li&gt;
&lt;li&gt;易於維護：多層式架構中程式碼各司其職，容易定位問題發生點、而非從整個應用程式邏輯找。&lt;/li&gt;
&lt;li&gt;敏捷開發：程式可快速回應需求修改(理由與易於維護類似，但是在開發時獲得的好處)。&lt;/li&gt;
&lt;li&gt;平行開發：解耦的程式有助於降低協作併版衝突。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;分層&#34;&gt;分層&lt;/h1&gt;
&lt;h2 id=&#34;三層式架構&#34;&gt;三層式架構&lt;/h2&gt;
&lt;p&gt;一般來說最常用的三層式架構組成為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表現層 (PL; Presentation Layer)：ASP 內就是 Controller 結尾。&lt;/li&gt;
&lt;li&gt;商業邏輯繩 (BLL; Business Logic Layer)：又稱為 Service Layer，命名習慣是 Service、Helper 結尾。&lt;/li&gt;
&lt;li&gt;資料存取層(DAL; Data Access Layer)：命名習慣是 Repo 結尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外有人將 Domain、Common 稱為一層，但這個部分其實不太像層，因為會被每一層引用，在架構上呈現比較不像層那樣扁平，裡面包含：
Model、Entity、DTO(Data transfer object) 或 Value Object，這裡只有屬性沒有方法。&lt;/p&gt;
&lt;h2 id=&#34;四層式架構&#34;&gt;四層式架構&lt;/h2&gt;
&lt;p&gt;為了降低 PL 與 BL 之間的耦合，有時會在 Business Logic Layer(BLL) 上再疊一層 Service Layer(SL)，作為 Presentation Layer 與 Business Layer 的中介層，這時 Business Logic Layer 的命名就不以 Serviece 結尾，通常較大型專案才需要如此分法。&lt;br&gt;
而 SL 和 BLL 的差別在於商業邏輯精細度，一個SL操作 (coarse-grained operation) 通常包含複數BL操作 (fine-grained operation)。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Program] 函數式程式設計</title>
      <link>https://0.0.0.0:1313/posts/software/pg-functional/</link>
      <pubDate>Thu, 15 Dec 2022 23:40:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/software/pg-functional/</guid>
      <description>&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/functional-programming-paradigm/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;geeksforgeeks-functional programming paradigm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[架構] 無暇的程式碼-讀書心得</title>
      <link>https://0.0.0.0:1313/posts/software/arch-clean-arch-review/</link>
      <pubDate>Mon, 12 Dec 2022 10:57:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/software/arch-clean-arch-review/</guid>
      <description>&lt;h2 id=&#34;軟體系統價值&#34;&gt;軟體系統價值&lt;/h2&gt;
&lt;p&gt;行為價值、架構價值&lt;/p&gt;
&lt;h3 id=&#34;行為價值&#34;&gt;行為價值&lt;/h3&gt;
&lt;p&gt;工程師的首要責任
需求實現、可用性保障(功能性 Bug、性能、穩定性)
業務明確、穩定的前提下，可忽略架構價值&lt;/p&gt;
&lt;h3 id=&#34;架構價值&#34;&gt;架構價值&lt;/h3&gt;
&lt;p&gt;更容易適應:需求變更。
變更實作難度和變更的範圍成正比、跟變更的具體形狀無關。 ??
業務需求通常不明確、時常變動，因此架構非常重要。
不關注架構價值會隨著版本迭代、變更每一行程式成本升高，因此投入的人力成本增加。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/65658089&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;知乎-架构整洁之道, 看这一篇就够了！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://alitech-public.oss-cn-beijing.aliyuncs.com/1557040476898/jiagouzhengjie-siweidaotu.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;架构整洁之道超詳細關係圖&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[Program] 巢狀結構</title>
      <link>https://0.0.0.0:1313/posts/software/quality-nest/</link>
      <pubDate>Sun, 11 Dec 2022 02:19:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/software/quality-nest/</guid>
      <description>&lt;p&gt;巢狀程式結構會使程式可讀性差、且難以維護，可讀性高的程式碼深度最多不超過三層，嚴格管控程式碼深度的程式設計師又稱為 Never Nester。&lt;/p&gt;
&lt;h2 id=&#34;消除巢狀程式手法&#34;&gt;消除巢狀程式手法：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Extraction&lt;/li&gt;
&lt;li&gt;Inversion&lt;/li&gt;
&lt;li&gt;依據契約式程式設計，移除不必要判斷&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;extraction&#34;&gt;Extraction&lt;/h3&gt;
&lt;p&gt;從複查的結構抽出程式碼&lt;/p&gt;
&lt;h3 id=&#34;inversion&#34;&gt;Inversion&lt;/h3&gt;
&lt;p&gt;把跳出函式的判斷移動到最上面&lt;/p&gt;
&lt;h3 id=&#34;依據契約式程式設計移除不必要判斷&#34;&gt;依據契約式程式設計，移除不必要判斷&lt;/h3&gt;
&lt;p&gt;依據契約式程式設計，以程式碼使用者會傳入的參數合法性為前提，移除不必要判斷&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[原則] 元件內聚性 Cohesion</title>
      <link>https://0.0.0.0:1313/posts/software/component-cohesion/</link>
      <pubDate>Mon, 04 Jul 2022 14:04:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/software/component-cohesion/</guid>
      <description>&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.avenuecode.com/principles-of-package-and-component-design&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Principles of Package and Component Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10254888&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ithome -【元件如何正確歸類 ?】元件內聚性三大原則 : REP、CCP、CRP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://forum.gamer.com.tw/C.php?bsn=60292&amp;amp;snA=6873&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;巴哈姆特 - 【攻略】【元件如何正確歸類 ? 】元件內聚性三大原則 : REP、CCP、CRP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[原則] 元件耦合性 Coupling</title>
      <link>https://0.0.0.0:1313/posts/software/component-coupling/</link>
      <pubDate>Mon, 04 Jul 2022 14:04:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/software/component-coupling/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[System] 單體式架構 vs 微服務架構</title>
      <link>https://0.0.0.0:1313/posts/software/arch-microservice/</link>
      <pubDate>Mon, 18 Oct 2021 11:11:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/software/arch-microservice/</guid>
      <description>&lt;h1 id=&#34;單體式與微服務架構&#34;&gt;單體式與微服務架構&lt;/h1&gt;
&lt;h2 id=&#34;單體式架構&#34;&gt;單體式架構&lt;/h2&gt;
&lt;p&gt;以前後端分離的網頁應用程式為例，傳統上大多採用軟體工程&lt;strong&gt;多層式架構(Multitier Architecture)&lt;strong&gt;中的&lt;/strong&gt;三層式架構(Three-Tire-Architecture)&lt;/strong&gt;，組成如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Data tier&lt;/strong&gt;: &lt;strong&gt;資料庫(DB)&lt;/strong&gt;，有資料表(Table)儲存應用程式資訊。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Logic tier&lt;/strong&gt;: 就是&lt;strong&gt;後端(Backend)&lt;/strong&gt;、應用程式伺服器 (AP Server)，負責和前端交換資料、存取資料庫。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Presentation tier&lt;/strong&gt;: 就是&lt;strong&gt;前端(Frontend)&lt;/strong&gt;，提供靜態資源，負責和使用者互動、和後端交換資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;微服務架構&#34;&gt;微服務架構&lt;/h2&gt;
&lt;p&gt;隨著系統愈來愈複雜，為了可維護性、擴充性、開發敏捷性，
透過軟體工程的手段將一個應用程式下&lt;strong&gt;緊密連結(耦合性強)&lt;strong&gt;的服務拆成許多&lt;/strong&gt;連結鬆散&lt;/strong&gt;且可&lt;strong&gt;獨立部署&lt;/strong&gt;的&lt;strong&gt;小型服務&lt;/strong&gt;，
小型服務之間透過 HTTP、gRPC&amp;hellip; 等通訊協定串聯訊息，構成複雜的應用程式。
這就是微服務架構。&lt;/p&gt;
&lt;h1 id=&#34;服務環境&#34;&gt;服務環境&lt;/h1&gt;
&lt;h2 id=&#34;單體式vm&#34;&gt;單體式(VM)&lt;/h2&gt;
&lt;p&gt;一般來說單體式架構較常以 &lt;strong&gt;虛擬機(Virtual Machine)&lt;/strong&gt; 的方式來建立單體式架構的各層環境，
VM 將服務從作業系統層面進行隔離(也就是&lt;strong&gt;不同服務有各自獨立的作業系統&lt;/strong&gt;)，
VM 相較於實體機器較能夠彈性控管分配資源，
但在啟動速度、硬體資源耗用等等&amp;hellip;都需要考慮到各自的作業系統。&lt;/p&gt;
&lt;h2 id=&#34;微服務容器&#34;&gt;微服務(容器)&lt;/h2&gt;
&lt;p&gt;實現微服務架構的核心技術是&lt;strong&gt;容器(Container)&lt;/strong&gt;，
容器將執行環境在應用程式層面上隔離，&lt;strong&gt;不同服務共用同一個作業系統&lt;/strong&gt;，
相較於傳統單體式架構使用的 VM 技術，容器的優點是耗用的資源少，啟動速度快(因為不用為每個服務建立一個OS)。&lt;/p&gt;
&lt;h1 id=&#34;開發模式&#34;&gt;開發模式&lt;/h1&gt;
&lt;h2 id=&#34;單體式&#34;&gt;單體式&lt;/h2&gt;
&lt;p&gt;由於所有邏輯都存在同一個服務，
因此開發者通常會被要求了解整個應用程式的運作邏輯，但那是一件很困難(或說不可能)的事，
且會占開發者工作很大一部分，嚴重影響開發效率。
而因為服務都綁定在同一個AP上，使用不同的技術棧進行開發會非常麻煩，所以開發能選擇的工具受到限制&lt;/p&gt;
&lt;h2 id=&#34;微服務&#34;&gt;微服務&lt;/h2&gt;
&lt;p&gt;開發者不需要了解整個應用澄式的運作邏輯，可專注於自己開發的部分
由於服務隔離的特性，不同服務容易使用不同的技術棧進行開發，
可以把任務分派到不同團隊
敏捷式(agile)開發
單體式  瀑布(waterfall)開發模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;敏捷性&lt;/strong&gt;：拆成為服務的專案更適合敏捷開發，也因為拆成可獨立部屬的小型服務，負責不同小型服務的團隊可以使用不同的技術棧。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;部屬與擴展&#34;&gt;部屬與擴展&lt;/h1&gt;
&lt;h2 id=&#34;單體式-1&#34;&gt;單體式&lt;/h2&gt;
&lt;p&gt;囿於單體式架構的侷限，每當更新版本或修復Bug的時候，
無論是否涉及的商業邏輯範圍大小，
都需要將整個前/後端應用程式重新編譯、部屬，
這對擴展 scaling、負載平衡 Loading balance 都會是一項挑戰。&lt;/p&gt;
&lt;p&gt;傳統應用程式負載增加時，應用程式整體架構可以進行如下調整，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;橫向擴展&lt;/strong&gt;：增加&lt;strong&gt;同一環境&lt;/strong&gt;(ex: AP Server)上&lt;strong&gt;可用硬體資源&lt;/strong&gt;(CPU、MEMORY、Disk&amp;hellip;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;縱向擴展&lt;/strong&gt;：增加&lt;strong&gt;提供服務的環境&lt;/strong&gt; (ex: 第二台 AP Server 等等&amp;hellip;)，好處是有了&lt;strong&gt;備援機制&lt;/strong&gt;，可以達成&lt;strong&gt;負載平衡&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不論環境是由實體機器/VM/容器所建立，一旦所有的服務都在同一個環境內執行()，就會有下面的缺點：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[架構] 多層式架構(Multitier Architecture)</title>
      <link>https://0.0.0.0:1313/posts/software/arch-n-tier/</link>
      <pubDate>Mon, 17 May 2021 23:20:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/software/arch-n-tier/</guid>
      <description>&lt;p&gt;多層式架構 Multitier Architecture 或稱 N-Tier Architecture，
是 Client–server architecture 的一種，
多層架構的層可以是 layer 或 tier，這兩者之間主要的差別在於 layer 指程式邏輯在應用程式的位置；
而 tier 指 layer 在系統上實際部屬執行的位址，屬於物理層級的指涉。
這一篇的層指的是 tier。&lt;/p&gt;
&lt;h1 id=&#34;n-tier-model&#34;&gt;N-tier model&lt;/h1&gt;
&lt;p&gt;N-tier model，層與層之間的邊界有 N-1 個，而程式跨邊界會造成巨大的效能損失，
一說為光是跨越同一台機器上不同進程(process)邊界存取資源損失就大約1000倍，
如果透過網路進行遠端呼叫勢必損失更多，
因此每跨越一個邊界進行資源存取效能就會以幾何級數損失。
且增加邊界在軟體設計上會增加複雜度，簡單的應用程式使用多層式架構很容易造成過度設計(over design)，
因此如何適當添加層級(tier)也是一門學問，添加層級時必需考量如何在應用程式所部屬的環境獲取最大的成本效益。
軟體是否採用多層式架構必須以多層式架構的優缺點進行取捨(尤其是可擴展性與效能之間)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提高可擴展性(scalability)。&lt;/li&gt;
&lt;li&gt;提高效能(performance)。&lt;/li&gt;
&lt;li&gt;提高容錯率(fault tolerance)。&lt;/li&gt;
&lt;li&gt;提高安全性(security)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-tier-model&#34;&gt;1-tier model&lt;/h2&gt;
&lt;p&gt;所有的 layer 都在同一機器、同一記憶體空間內運行，因此不需考慮網路造成的性能損失。&lt;/p&gt;
&lt;h2 id=&#34;2-tier-model&#34;&gt;2-tier model&lt;/h2&gt;
&lt;p&gt;layer 分配至兩個不同的記憶體空間運行，記憶體空間可能位於相同或兩台不同的機器上(通常是不同機器)，典型的例子是分配到 client、server 上運行。&lt;/p&gt;
&lt;h2 id=&#34;3-tier-model&#34;&gt;3-tier model&lt;/h2&gt;
&lt;p&gt;多層式架構當中最常使用的就是三層架構(three-tier architecture)。
三層架構與Web應用程式來說明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表現層(Presentation)：又稱為 UI 層，以Web來說就是呈現出來的前端網頁。&lt;/li&gt;
&lt;li&gt;應用程式層(Application)：以 Web 來說相當於伺服器上執行的應用程式。&lt;/li&gt;
&lt;li&gt;資料層(Data)：這一層包含資料儲存、呈現機制，以 Web 來說通常指 Database。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Multitier_architecture&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wikipedia - Multitier architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lhotka.net/weblog/ShouldAllAppsBeNtier.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rockford Lhotka - Should all apps be n-tier?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.guru99.com/n-tier-architecture-system-concepts-tips.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;N Tier(Multi-Tier), 3-Tier, 2-Tier Architecture with EXAMPLE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[.NET Core] TAP (task-based asynchronous pattern) 以工作為基礎的非同步模式</title>
      <link>https://0.0.0.0:1313/posts/software/draft-basic-async-tap/</link>
      <pubDate>Sat, 13 Mar 2021 00:07:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/software/draft-basic-async-tap/</guid>
      <description>&lt;p&gt;無論是在 I/O-bound (IO密集)或 CPU-bound (CPU密集)類型的程式，非同步設計皆有發揮的空間。
而 C# 達成非同步程式設計的方法可以是
TAP (Task-based Asynchronous Pattern)、
APM (Asynchronous Programming Model) 或
(EAP) pattern and the Event-based Asynchronous Pattern。
而 ASP .NET Core 當中的控制器屬於IO密集的應用程式，當中大量使用的 TAP 是一種簡易使用、語言層級的非同步設計模式&lt;/p&gt;
&lt;h1 id=&#34;tap-task-based-asynchronous-pattern&#34;&gt;TAP (Task-based Asynchronous Pattern)&lt;/h1&gt;
&lt;p&gt;any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.&lt;/p&gt;
&lt;p&gt;controller 前有沒有加上 async 的不同
The async keyword creates a state machine, which is responsible for managing the returned Task. If the code in an async method throws an exception, then the async state machine captures that exception and places it on the returned Task. This is the expected semantics for a method that returns Task.
that exception would be raised directly to the caller rather than being placed on the returned Task. These semantics are not expected.
As a general rule, I recommend keeping the async and await keywords unless the method is trivial and will not throw an exception.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[System] 系統設計(System Design)</title>
      <link>https://0.0.0.0:1313/posts/software/design/</link>
      <pubDate>Sun, 10 Jan 2021 23:21:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/software/design/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;命令查詢職責分離模式(Command and Query Responsibility Segregation，CQRS)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/donnemartin/system-design-primer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;donnemartin/system-design-primer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/65658089&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;clean architecture review&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[System] 領域驅動設計(DDD; Domain Drived Design)</title>
      <link>https://0.0.0.0:1313/posts/software/design-ddd/</link>
      <pubDate>Sun, 10 Jan 2021 23:21:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/software/design-ddd/</guid>
      <description>&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    
  </channel>
</rss>
