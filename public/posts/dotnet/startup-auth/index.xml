<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>[練習] 認證與授權 on YuCheng&#39;s Site</title>
    <link>https://0.0.0.0:1313/posts/dotnet/startup-auth/</link>
    <description>Recent content in [練習] 認證與授權 on YuCheng&#39;s Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 12 Mar 2021 23:08:00 +0800</lastBuildDate><atom:link href="https://0.0.0.0:1313/posts/dotnet/startup-auth/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>[.NET Core] ASP .NET Core 3.1 驗證與授權(二)-驗證設定</title>
      <link>https://0.0.0.0:1313/posts/dotnet/startup-auth/auth_guild_2/</link>
      <pubDate>Fri, 12 Mar 2021 23:08:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/dotnet/startup-auth/auth_guild_2/</guid>
      <description>&lt;h1 id=&#34;驗證方案authentication-scheme&#34;&gt;驗證方案(Authentication Scheme)&lt;/h1&gt;
&lt;p&gt;驗證方案包含兩個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;驗證處理函式(Authentication handler)，可能是
&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.iauthenticationhandler?view=aspnetcore-3.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IAuthenticationHandler&lt;/a&gt; 或
&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.authenticationhandler-1?view=aspnetcore-3.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AuthenticationHandler&lt;TOptions&gt;&lt;/a&gt;
的實作，相當於驗證方案的&lt;strong&gt;行為&lt;/strong&gt;，責任範圍涵蓋:
&lt;ul&gt;
&lt;li&gt;驗證使用者，&lt;/li&gt;
&lt;li&gt;驗證成功時，建構呈現使用者識別(user identity)的 &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.authenticationticket?view=aspnetcore-3.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AuthenticationTicket&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;驗證失敗時，回傳 &amp;rsquo;no result&amp;rsquo; 或 &amp;lsquo;failure&amp;rsquo;&lt;/li&gt;
&lt;li&gt;負責從請求上下文(request context)中建構使用者識別 (user identity)。&lt;/li&gt;
&lt;li&gt;定義了 challenge/forbid action。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;驗證處理函式的設定選項(Opitons of Authentication handler)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;驗證方案當中的 authencate action 負責從請求上下文(request context)中建構使用者識別 (user identity)，
常見的例子為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cookie authentication scheme&lt;/strong&gt; 從 cookie 資訊建構 user identity.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JWT bearer scheme&lt;/strong&gt; 反序列化(deserialize)、驗證(validate) token，並從 token 所攜帶資訊建構 user identity&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用驗證方案&#34;&gt;使用驗證方案&lt;/h2&gt;
&lt;p&gt;在 Startup.ConfigureServices 以 AddAuthentication 註冊驗證服務時會回傳一個 AuthenticationBuilder，
AuthenticationBuilder 設定驗證方案的方式有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;呼叫 &lt;strong&gt;scheme-specific 擴充方法&lt;/strong&gt;，例如 AddJwtBearer、AddCookie，這些擴充方法會自動呼叫 AuthenticationBuilder.AddScheme 設定需要的驗證方式。&lt;/li&gt;
&lt;li&gt;以 AuthenticationBuilder &lt;strong&gt;內建方法 AddScheme&lt;/strong&gt; 手動設定，一般來說較少使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;P.S.另外可使用 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/aspnet/core/security/authentication/policyschemes?view=aspnetcore-3.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;polycy schemes&lt;/a&gt; 把多個 scheme 整合到一個使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[.NET Core] ASP .NET Core 3.1 驗證與授權(四)-授權設定</title>
      <link>https://0.0.0.0:1313/posts/dotnet/startup-auth/auth_guild_4/</link>
      <pubDate>Thu, 31 Dec 2020 14:08:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/dotnet/startup-auth/auth_guild_4/</guid>
      <description>&lt;h1 id=&#34;授權authorization&#34;&gt;授權(Authorization)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;授權(Authorization): 界定用戶可存取資源範圍的程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;policy-based-authorization&#34;&gt;Policy-based authorization&lt;/h2&gt;
&lt;p&gt;ASP .NET Core 的授權以政策 Policy 進行設定&lt;/p&gt;
&lt;h2 id=&#34;自訂授權&#34;&gt;自訂授權&lt;/h2&gt;
&lt;h2 id=&#34;rbac&#34;&gt;RBAC&lt;/h2&gt;
&lt;p&gt;Name 記載使用者識別名稱(User Identity)
userData 記載以 &lt;code&gt;|&lt;/code&gt; 分隔的使用者角色 Role&lt;/p&gt;
&lt;h1 id=&#34;驗證與授權&#34;&gt;驗證與授權&lt;/h1&gt;
&lt;h2 id=&#34;challengeforbid&#34;&gt;Challenge、Forbid&lt;/h2&gt;
&lt;h2 id=&#34;中間件順序&#34;&gt;中間件順序&lt;/h2&gt;
&lt;p&gt;先驗證、再授權
The Order of UseAuthentication、UseAuthorization&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/standard/security/principal-and-identity-objects&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MSDN - Principal and Identity Objects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/microsoft.aspnetcore.authentication.iauthenticationservice?view=aspnetcore-3.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MSDN - IAuthenticationService Interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/microsoft.aspnetcore.authentication.authenticationservice?view=aspnetcore-3.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MSDN - AuthenticationService Class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/zh-tw/aspnet/core/security/?view=aspnetcore-3.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MSDN - Overview of ASP.NET Core Security&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/security/authentication/?view=aspnetcore-3.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MSDN - Overview of ASP.NET Core authentication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-3.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MSDN - Policy-based authorization in ASP.NET Core&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.cookies?view=aspnetcore-5.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MSDN - Microsoft.AspNetCore.Authentication.Cookies Namespace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.jwtbearer?view=aspnetcore-5.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MSDN - Microsoft.AspNetCore.Authentication.JwtBearer Namespace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/Null/2020/04/09/162252&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;[ASP.NET Core] 加上簡單的Cookie登入驗證&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.johnwu.cc/article/ironman-day11-asp-net-core-cookies-session.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.johnwu.cc/article/ironman-day11-asp-net-core-cookies-session.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[.NET Core] ASP .NET Core 3.1 驗證與授權(三)-Cookie 驗證實例</title>
      <link>https://0.0.0.0:1313/posts/dotnet/startup-auth/auth_guild_3/</link>
      <pubDate>Wed, 30 Dec 2020 23:24:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/dotnet/startup-auth/auth_guild_3/</guid>
      <description>&lt;p&gt;前兩篇介紹了驗證、授權在 .NET Core 當中的基本的概念，本節實作 Cookie 驗證的設定、簽發、登出&amp;hellip;&lt;/p&gt;
&lt;h1 id=&#34;configuration&#34;&gt;Configuration&lt;/h1&gt;
&lt;p&gt;在 Startup.ConfigureServices 方法中設置驗證方案，
並且可以在 AddCookie 當中設置 CookieAuthenticationOptions(見前一節)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 設置 cookie 驗證作為應用程式預設的驗證方案&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 將 cookie 服務添加到服務容器當中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .AddCookie();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 Startup.Configure 方法中，呼叫 UseAuthentication、UseAuthorization，
啟用驗證中間件並設置 HttpContext.User 屬性，
UseAuthentication 必須在 UseAuthorization 之前，且兩者都必須在 UseEndpoints 之前被呼叫：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app.UseAuthentication(); &lt;span style=&#34;color:#75715e&#34;&gt;// 驗證&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app.UseAuthorization(); &lt;span style=&#34;color:#75715e&#34;&gt;// 授權&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 端點對應&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app.UseEndpoints(endpoints =&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    endpoints.MapControllers();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    endpoints.MapRazorPages();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;cookie-policy-middleware&#34;&gt;Cookie Policy Middleware&lt;/h1&gt;
&lt;p&gt;在中間件當中設置的驗證政策會作用於全域(每個請求)，
舉例來說，最常用的就是限制應用程式所有 Cookie 的 SameSite 屬性，
所有 Controller 簽發的 Cookie.SamSite 屬性會被限縮為較嚴格(不比 MinimumSameSitePolicy 寬鬆)的設置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c#&#34; data-lang=&#34;c#&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app.UseCookiePolicy(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; CookiePolicyOptions {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 所有 Cookie.SamSite 設置都會被提升為 Strict&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    MinimumSameSitePolicy = SameSiteMode.Strict, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Cookie.SamSite 設置為 None 的話會被提升為 Lax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//MinimumSameSitePolicy = SameSiteMode.Lax,  &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// MinimumSameSitePolicy 設置為最寬鬆，因此不會影響 Cookie.SamSite&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//MinimumSameSitePolicy = SameSiteMode.None, &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;create-an-authentication-cookie&#34;&gt;Create an authentication cookie&lt;/h1&gt;
&lt;p&gt;.NET Core 利用 ClaimsPrincipal 將序列化的使用者資訊儲存在 Cookie 當中
而 ClaimsPrincipal 可包含很多 ClaimsIdentity(但通常只有一個)；
ClaimsIdentity 可以且通常包含很多 Claims(聲明)，
而每個 Claims 是包含型別(ClaimType)、值(ClaimValue)。
因此為登入使用者建立 Cookie 驗證的步驟如下：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[.NET Core] ASP .NET Core 3.1 驗證與授權(X)-備註頁面</title>
      <link>https://0.0.0.0:1313/posts/dotnet/startup-auth/auth_guild_memo/</link>
      <pubDate>Mon, 23 Nov 2020 15:48:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/dotnet/startup-auth/auth_guild_memo/</guid>
      <description>&lt;h2 id=&#34;identity-objects&#34;&gt;Identity Objects&lt;/h2&gt;
&lt;h2 id=&#34;principal-objects&#34;&gt;Principal Objects&lt;/h2&gt;
&lt;p&gt;IPrincipal 物件帶有 IIdentity 物件的參考
可指定 Authentication Scheme 獲得 Identity&lt;/p&gt;
&lt;h2 id=&#34;iauthenticationservice&#34;&gt;IAuthenticationService&lt;/h2&gt;
&lt;p&gt;SignOutAsync 清除 Cookie 的 Claims
在 Cookie 寫入 Claims&lt;/p&gt;
&lt;h2 id=&#34;token-登入&#34;&gt;Token 登入&lt;/h2&gt;
&lt;h1 id=&#34;登入-api-實作&#34;&gt;登入 API 實作&lt;/h1&gt;
&lt;p&gt;宣告 ClaimsPrincipal 後，可利用服務容器已注入的認證服務(實作 IAuthencationService 的類別)，進行登入、登出。
使用 SignInAsync 方法登入(寫入認證資訊)需要這些東西：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ClaimsPrincipal(必要)，我們需要 ClaimsPrincipal 攜帶 ClaimsIdentity 及 Claims。&lt;/li&gt;
&lt;li&gt;AuthenticationScheme string (Optional)可指定 Scheme，若沒有給就是使用預設的 Scheme。&lt;/li&gt;
&lt;li&gt;authProperties (Optional)，可指定自訂認證選項&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;authenticationhttpcontextextensions&#34;&gt;AuthenticationHttpContextExtensions&lt;/h1&gt;
&lt;p&gt;AuthenticationHttpContextExtensions 類別對 HttpContext 類別擴展出認證方法，
從服務容器中獲取 IAuthenticationService 實體類別，並調用同名方法。&lt;/p&gt;
&lt;h1 id=&#34;iauthenticationservice-1&#34;&gt;IAuthenticationService&lt;/h1&gt;
&lt;p&gt;SignOutAsync 清除 Cookie 的 Claims
可儲存 ClaimsPrincipal進行簽發(登入)認證，作為身分識別。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[.NET Core] ASP .NET Core 3.1 驗證與授權(一)-驗證與授權</title>
      <link>https://0.0.0.0:1313/posts/dotnet/startup-auth/auth_guild_1/</link>
      <pubDate>Mon, 23 Nov 2020 08:39:00 +0800</pubDate>
      
      <guid>https://0.0.0.0:1313/posts/dotnet/startup-auth/auth_guild_1/</guid>
      <description>&lt;p&gt;在進入 ASP .NET Core 3.1 中驗證(Authentication)與授權(Authorization)的作用流程前，應當對兩者有抽象概念上的認識，以及了解兩者的差異。&lt;/p&gt;
&lt;h1 id=&#34;驗證authentication&#34;&gt;驗證(Authentication)&lt;/h1&gt;
&lt;p&gt;驗證是確認用戶識別碼(User Identity)的程序，通過驗證的用戶可具有一或多個用戶識別碼，
因此驗證服務本身就是使用者識別碼提供者 (User Identity Provider)，
ASP.NET Core 3.1 當中以依賴注入(DI; Dependency Injection)將驗證服務注入服務容器 (Service Container)，
使應用程式驗證簽發時能夠取用。&lt;/p&gt;
&lt;h1 id=&#34;授權authorization&#34;&gt;授權(Authorization)&lt;/h1&gt;
&lt;p&gt;授權的作用是界定用戶可存取資源範圍，作用描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;限制所存取的資源是否需要驗證。&lt;/li&gt;
&lt;li&gt;已獲得驗證的特定用戶、特定腳色方能存取特定資源。&lt;/li&gt;
&lt;li&gt;所存取的資源需要以何種授權政策(Authorizaton Policy)、即驗證方案(Authencation Scheme)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;挑戰和禁止&#34;&gt;挑戰和禁止&lt;/h1&gt;
&lt;p&gt;有些名詞需要先解釋：
驗證方案(Authentication Scheme)當中設置了挑戰(Chellange)與禁止(Forbid)應該進行的動作，這些註冊於驗證方案的動作動作由授權叫用。&lt;/p&gt;
&lt;h2 id=&#34;挑戰challenge&#34;&gt;挑戰(Challenge)&lt;/h2&gt;
&lt;p&gt;未驗證使用者要存取需驗證才能存取的資源時，
授權服務會叫用 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/microsoft.aspnetcore.authentication.iauthenticationservice.challengeasync?view=aspnetcore-3.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IAuthenticationService.ChallengeAsync&lt;/a&gt; 發起 challenge，
challenge 被發起後所伴隨採取的行動稱為 challenge action，
且 challenge action 應讓使用者知道應該以哪一種驗證機制取得授權，常見的具體範例有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cookie 驗證方案將使用者轉址到登入頁面。&lt;/li&gt;
&lt;li&gt;JWT 回傳 401 Unauthorized 狀態碼，並在 Header 帶入 &lt;code&gt;www-authenticate: bearer&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;禁止forbid&#34;&gt;禁止(Forbid)&lt;/h2&gt;
&lt;p&gt;已驗證的使用者要存取授權之外的資源時，
授權會叫用 &lt;a href=&#34;https://docs.microsoft.com/zh-tw/dotnet/api/microsoft.aspnetcore.authentication.iauthenticationservice.forbidasync?view=aspnetcore-3.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IAuthenticationService.ForbidAsync&lt;/a&gt; 發起 Forbid，
Forbid 發起後所伴隨採取的行動稱為 Forbid action，
Forbid action 的目的是要讓使用者知道自己已通過認證、且不具權限訪問所請求的資源，
常見的具體範例有：&lt;/p&gt;</description>
    </item>
    
    
  </channel>
</rss>
