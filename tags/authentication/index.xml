<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Authentication on YuCheng&#39;s Site</title>
    <link>https://tigernaxojr.github.io/blog/tags/authentication/</link>
    <description>Recent content in Authentication on YuCheng&#39;s Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 30 Dec 2020 23:24:00 +0800</lastBuildDate><atom:link href="https://tigernaxojr.github.io/blog/tags/authentication/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>[.NET Core] ASP .NET Core 3.1 驗證與授權(三)-Cookie 驗證實例</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/auth/auth_guild_3/</link>
      <pubDate>Wed, 30 Dec 2020 23:24:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/auth/auth_guild_3/</guid>
      <description>前兩篇介紹了驗證、授權在 .NET Core 當中的基本的概念，本節實作 Cookie 驗證的設定、簽發、登出&amp;hellip;
Configuration 在 Startup.ConfigureServices 方法中設置驗證方案， 並且可以在 AddCookie 當中設置 CookieAuthenticationOptions(見前一節)
// 設置 cookie 驗證作為應用程式預設的驗證方案 services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme) // 將 cookie 服務添加到服務容器當中  .AddCookie(); 在 Startup.Configure 方法中，呼叫 UseAuthentication、UseAuthorization， 啟用驗證中間件並設置 HttpContext.User 屬性， UseAuthentication 必須在 UseAuthorization 之前，且兩者都必須在 UseEndpoints 之前被呼叫：
app.UseAuthentication(); // 驗證 app.UseAuthorization(); // 授權  // 端點對應 app.UseEndpoints(endpoints =&amp;gt; {  endpoints.MapControllers();  endpoints.MapRazorPages(); }); Cookie Policy Middleware 在中間件當中設置的驗證政策會作用於全域(每個請求)， 舉例來說，最常用的就是限制應用程式所有 Cookie 的 SameSite 屬性， 所有 Controller 簽發的 Cookie.SamSite 屬性會被限縮為較嚴格(不比 MinimumSameSitePolicy 寬鬆)的設置：</description>
    </item>
    
    <item>
      <title>[.NET Core] ASP .NET Core 3.1 驗證與授權(二)-驗證設定</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/auth/auth_guild_2/</link>
      <pubDate>Mon, 23 Nov 2020 15:46:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/auth/auth_guild_2/</guid>
      <description>驗證方案(Authentication Scheme) 驗證方案包含兩個部分：
 驗證處理函式(Authentication handler)，可能是 IAuthenticationHandler 或 AuthenticationHandler 的實作，相當於驗證方案的行為，責任範圍涵蓋:  驗證使用者， 驗證成功時，建構呈現使用者識別(user identity)的 AuthenticationTicket。 驗證失敗時，回傳 &amp;rsquo;no result&amp;rsquo; 或 &amp;lsquo;failure&amp;rsquo; 負責從請求上下文(request context)中建構使用者識別 (user identity)。 定義了 challenge/forbid action。   驗證處理函式的設定選項(Opitons of Authentication handler)。  驗證方案當中的 authencate action 負責從請求上下文(request context)中建構使用者識別 (user identity)， 常見的例子為：
 cookie authentication scheme 從 cookie 資訊建構 user identity. JWT bearer scheme 反序列化(deserialize)、驗證(validate) token，並從 token 所攜帶資訊建構 user identity  使用驗證方案 在 Startup.ConfigureServices 以 AddAuthentication 註冊驗證服務時會回傳一個 AuthenticationBuilder， AuthenticationBuilder 設定驗證方案的方式有：</description>
    </item>
    
    <item>
      <title>[.NET Core] ASP .NET Core 3.1 驗證與授權(一)-驗證與授權</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/auth/auth_guild_1/</link>
      <pubDate>Mon, 23 Nov 2020 08:39:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/auth/auth_guild_1/</guid>
      <description>在進入 ASP .NET Core 3.1 中驗證(Authentication)與授權(Authorization)的作用流程前，應當對兩者有抽象概念上的認識，以及了解兩者的差異。
驗證(Authentication) 驗證是確認用戶識別碼(User Identity)的程序，通過驗證的用戶可具有一或多個用戶識別碼， 因此驗證服務本身就是使用者識別碼提供者 (User Identity Provider)， ASP.NET Core 3.1 當中以依賴注入(DI; Dependency Injection)將驗證服務注入服務容器 (Service Container)， 使應用程式驗證簽發時能夠取用。
授權(Authorization) 授權的作用是界定用戶可存取資源範圍，作用描述如下：
 限制所存取的資源是否需要驗證。 已獲得驗證的特定用戶、特定腳色方能存取特定資源。 所存取的資源需要以何種授權政策(Authorizaton Policy)、即驗證方案(Authencation Scheme)。  挑戰和禁止 有些名詞需要先解釋： 驗證方案(Authentication Scheme)當中設置了挑戰(Chellange)與禁止(Forbid)應該進行的動作，這些註冊於驗證方案的動作動作由授權叫用。
挑戰(Challenge) 未驗證使用者要存取需驗證才能存取的資源時， 授權服務會叫用 IAuthenticationService.ChallengeAsync 發起 challenge， challenge 被發起後所伴隨採取的行動稱為 challenge action， 且 challenge action 應讓使用者知道應該以哪一種驗證機制取得授權，常見的具體範例有：
 cookie 驗證方案將使用者轉址到登入頁面。 JWT 回傳 401 Unauthorized 狀態碼，並在 Header 帶入 www-authenticate: bearer。  禁止(Forbid) 已驗證的使用者要存取授權之外的資源時， 授權會叫用 IAuthenticationService.ForbidAsync 發起 Forbid， Forbid 發起後所伴隨採取的行動稱為 Forbid action， Forbid action 的目的是要讓使用者知道自己已通過認證、且不具權限訪問所請求的資源， 常見的具體範例有：</description>
    </item>
    
    <item>
      <title>[SignalR] Websocket 即時聊天程式(四) - 前端登入頁面</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/signalr/guild_4_front_end_login/</link>
      <pubDate>Tue, 10 Nov 2020 02:45:45 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/signalr/guild_4_front_end_login/</guid>
      <description>安裝 axios SignalR 連線驗證的方式是將 token 夾帶於網址參數中發送到伺服器，因此進行 websocket 連線前我們透過 ajax 向伺服器發送帳號密碼索取登入的 Token，我們安裝方便使用 ajax 的 axios 函式庫：
axios 一樣可以透過 LibMan 安裝~
libman install axios@latest \  -p unpkg \  -d wwwroot/js/axios \  --files dist/axios.min.js 在 wwwRoot/index.html 添加對 axios 的引用：
&amp;lt;script src=&amp;#34;./lib/axios/dist/axios.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 簡易登入UI 雖然是功能原型，為了讓做出來的頁面不要太粗暴，拿 bootstrap 的 css 來套用一下 UI：
libman install bootstrap@5.0.0-alpha2 \  -p unpkg \  -d wwwroot/lib/bootstrap \  --files dist/js/bootstrap.min.js \  --files dist/css/bootstrap.min.css 在 wwwRoot/index.html 添加對 bootstrap css 的引用：</description>
    </item>
    
    <item>
      <title>[SignalR] Websocket 即時聊天程式(三) - 後端 Token 認證</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/signalr/guild_3_validate_token/</link>
      <pubDate>Sat, 07 Nov 2020 15:09:45 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/signalr/guild_3_validate_token/</guid>
      <description>安裝套件 要進行 Token 的認證，需要先安裝 Microsoft.AspNetCore.Authentication.JwtBearer 套件：
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer 註冊認證服務 新增一個檔案 DependencyInjection.cs，在當中製作 IServiceCollection 的擴充方法來自定義 JWT token 認證服務， 在裡面設置 Token 的認證規則、使用者識別碼對應、使用者群組對應， 而 SignalR 抓取使用者識別碼 (UserIdentifier) 的介面方法是 IUserIdProvider.GetUserId， 因此我們需要另外新增一個實作 IUserProvider 的類別注入服務容器給 SignalR 使用 ，該檔案程式碼如下：
using Microsoft.AspNetCore.Authentication.JwtBearer; using Microsoft.AspNetCore.SignalR; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Microsoft.IdentityModel.Tokens; using System.Diagnostics.CodeAnalysis; using System.IdentityModel.Tokens.Jwt; using System.Linq; using System.Threading.Tasks;  namespace SignalR.Extensions.DependencyInjection {  public static class MyAddConfig  {  public static IServiceCollection AddMyJWTAuth( [NotNull] this IServiceCollection services,  IConfiguration config  )  {   services.</description>
    </item>
    
    <item>
      <title>[SignalR] Websocket 即時聊天程式(二) - 後端 Token 授權</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/signalr/guild_2_issue_token/</link>
      <pubDate>Fri, 06 Nov 2020 21:09:45 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/signalr/guild_2_issue_token/</guid>
      <description>SignalR驗證方式 SignalR 的授權可以選擇使用 Cookie 或 Bearer Token：
 Cookie: 驗證方法與一般網頁別無二致，較容易實作但缺點是只能用於瀏覽器(browser-specific)。 Bearer Token 可通用於網頁和 App (或提供任何應用程式)，使用 Token 做登入能夠讓應用程式更容易實作其他使用者端，如果有其他的伺服器簽發 Token，更容易整合至單一登入(Single Sign-On)，也是官方建議使用的方式，以下假設簽發 Token 與 SignalR 伺服器為同一台進行實作。  將 Token 驗證實作至伺服器之前，讓我們先練習實作一支簽發 Token 的 API。
以 Option pattern 取得 JWT 設定 這裡練習 Option pattern，以獲取 appsetting.json 當中 JWT 相關設定的強型別支援：
appsetting.json 將 JWT 相關的設定寫到 appsetting.json 當中： {  &amp;#34;Logging&amp;#34;: {  &amp;#34;LogLevel&amp;#34;: {  &amp;#34;Default&amp;#34;: &amp;#34;Information&amp;#34;,  &amp;#34;Microsoft&amp;#34;: &amp;#34;Warning&amp;#34;,  &amp;#34;Microsoft.Hosting.Lifetime&amp;#34;: &amp;#34;Information&amp;#34;  }  },  &amp;#34;JWT&amp;#34;: {  &amp;#34;Issuer&amp;#34;: &amp;#34;Naxo&amp;#34;,  &amp;#34;Expires&amp;#34;: &amp;#34;1440&amp;#34;, // 憑證有效分鐘數  &amp;#34;SignKey&amp;#34;: &amp;#34;myNameIsTigernaxo,ThisIsMyPersonalBlog&amp;#34; // 設定簽發/解密憑證的對稱式加密金鑰  },  &amp;#34;AllowedHosts&amp;#34;: &amp;#34;*&amp;#34; }</description>
    </item>
    
    
  </channel>
</rss>
