<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Websocket on YuCheng&#39;s Site</title>
    <link>https://tigernaxojr.github.io/blog/tags/websocket/</link>
    <description>Recent content in Websocket on YuCheng&#39;s Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 31 Oct 2020 02:09:45 +0800</lastBuildDate><atom:link href="https://tigernaxojr.github.io/blog/tags/websocket/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>[SignalR] Websocket 即時聊天程式(一) - 建立專案</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/signalr/guild_1_start/</link>
      <pubDate>Sat, 31 Oct 2020 02:09:45 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/signalr/guild_1_start/</guid>
      <description>這個系列會官方文件為主，保留必要的部分，並視情況修改部份程式、添加說明文字。
建立 SignalR 專案 這個範例設定用靜態 html 做前端，這樣之後要做前後端分離也更容易一些，之後會用到 web api 請求登入 Token，所以起始一個 web api 專案：
# 建立專案 dotnet new webapi -o SignalR # 以 VS Code 打開專案 code -r signalr 建立 SignalR 中樞 在.NET Core 3.1 當中使用 SignalR 伺服器端不再需要安裝額外的套件，直接將 SignalR 注入服務容器就能使用， SignalR 的 Hub 中文名稱就叫做中樞，在專案中新增資料夾 Hubs 用來專門存放 Hub 實作類別，並在 Hubs 中新增檔案 ChatHub.cs，內容如下：
using Microsoft.AspNetCore.SignalR; using System.Threading.Tasks;  namespace SignalR.Hubs {  // 這就是所謂的 SignalR 中樞  public class ChatHub : Hub  {  // 這是提供 Client (js)端呼叫的方法，後面是這個方法接受的參數  public async Task SendMessage(string user, string message)  {  // 針對每個以連線的客戶端呼叫 ReceiceMassage 方法，並傳送參數 user、message  await Clients.</description>
    </item>
    
    
  </channel>
</rss>
