<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Vue on YuCheng's Site</title><link>https://blog.tigernaxo.com/posts/frontend-vue/</link><description>Recent content in Vue on YuCheng's Site</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 06 Apr 2023 14:21:00 +0800</lastBuildDate><atom:link href="https://blog.tigernaxo.com/posts/frontend-vue/index.xml" rel="self" type="application/rss+xml"/><item><title>[元件] 把 attr、event、slot，直接 Passthrough 給子元件，製作包裝元件</title><link>https://blog.tigernaxo.com/posts/frontend-vue/vue-comp-wrapper/</link><pubDate>Thu, 06 Apr 2023 14:21:00 +0800</pubDate><guid>https://blog.tigernaxo.com/posts/frontend-vue/vue-comp-wrapper/</guid><description>用來複寫給專案用的元件，用於在既有 UI framework 上打造專案元件
Vue3 Vue2.6 &amp;lt;template&amp;gt; &amp;lt;q-btn v-bind=&amp;#34;{ ...$attrs, ...$props }&amp;#34; v-on=&amp;#34;$listeners&amp;#34;&amp;gt; &amp;lt;template v-for=&amp;#34;(_, slot) of $scopedSlots&amp;#34; v-slot:[slot]=&amp;#34;scope&amp;#34;&amp;gt; &amp;lt;slot :name=&amp;#34;slot&amp;#34; v-bind=&amp;#34;scope&amp;#34;/&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt; &amp;lt;/q-btn&amp;gt; &amp;lt;/template&amp;gt; Vue3 Vue3 裡面只要綁定 $attrs 即可，attrs, props, event 全部自動綁定進去。
&amp;lt;template&amp;gt; &amp;lt;q-btn v-bind=&amp;#34;$attrs&amp;#34;&amp;gt; &amp;lt;template v-for=&amp;#34;(slot, index) of Object.keys($slots)&amp;#34; :key=&amp;#34;index&amp;#34; v-slot:[slot]&amp;gt; &amp;lt;slot :name=&amp;#34;slot&amp;#34;&amp;gt;&amp;lt;/slot&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt; &amp;lt;/q-btn&amp;gt; &amp;lt;/template&amp;gt; Quasar2-TS Quasar 裡面 Props, Slot 有獨立的 interface 定義，因此可直接拿到。
&amp;lt;template&amp;gt; &amp;lt;q-btn v-bind=&amp;#34;$attrs&amp;#34;&amp;gt; &amp;lt;template v-for=&amp;#34;(slot, index) of Object.keys($slots)&amp;#34; :key=&amp;#34;index&amp;#34; v-slot:[slot]&amp;gt; &amp;lt;slot :name=&amp;#34;slot&amp;#34;&amp;gt;&amp;lt;/slot&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/q-btn&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script setup lang=&amp;#34;ts&amp;#34;&amp;gt; import type { QBtnSlots, QBtnProps } from &amp;#39;quasar&amp;#39;; import { QBtn } from &amp;#39;quasar&amp;#39;; const props = withDefaults(defineProps&amp;lt;QBtnProps&amp;gt;(),{ // here comes default settings }); &amp;lt;/script&amp;gt; &amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt; Vuetify3 Vuetify3 裡面 Props, Slot 沒有獨立的 interface 定義，因此需額外定義。 MyBtn.</description></item><item><title>[But] TypeScript 注意事項</title><link>https://blog.tigernaxo.com/posts/frontend-vue/vue-ts-bug/</link><pubDate>Fri, 10 Mar 2023 08:14:00 +0800</pubDate><guid>https://blog.tigernaxo.com/posts/frontend-vue/vue-ts-bug/</guid><description>用這樣的寫法，會造成 IDE 異常
:columns=&amp;#34;columns as QTableProps[&amp;#39;columns&amp;#39;]&amp;#34;</description></item><item><title>[元件] 全域元件</title><link>https://blog.tigernaxo.com/posts/frontend-vue/vue-comp-global/</link><pubDate>Tue, 13 Dec 2022 15:10:57 +0800</pubDate><guid>https://blog.tigernaxo.com/posts/frontend-vue/vue-comp-global/</guid><description>Vue 的作法 app.component(&amp;#39;component-name&amp;#39;, component) Quasar2 的做法 Vite/Typescript
建立 src/boot/register-my-component.ts
import { boot } from &amp;#39;quasar/wrappers&amp;#39;; import BasicBtnVue from &amp;#39;src/components/BasicBtn.vue&amp;#39;; // &amp;#34;async&amp;#34; is optional; // more info on params: https://v2.quasar.dev/quasar-cli/boot-files export default boot(async ({ app }) =&amp;gt; { app.component(&amp;#39;x-btn&amp;#39;, BasicBtnVue); }); 在 quasar.conf.js 內新增設定
module.exports = configure(function (/* ctx */) { return { // ...上略 // https://v2.quasar.dev/quasar-cli-vite/boot-files boot: [&amp;#39;i18n&amp;#39;, &amp;#39;register-my-component&amp;#39;], // ... 下略 }; }); 建立型別定義檔，我放在 src/components 下 components.d.ts
import BasicBtn from &amp;#39;.</description></item><item><title>[Typescript] Typescript 用 InjectionKey 達成強型別 provide</title><link>https://blog.tigernaxo.com/posts/frontend-vue/vue-ts-provide/</link><pubDate>Thu, 17 Nov 2022 11:49:00 +0800</pubDate><guid>https://blog.tigernaxo.com/posts/frontend-vue/vue-ts-provide/</guid><description>Working with Reactivity 上游元件
&amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; import { InjectionKey, provide, Ref, reactive } from &amp;#39;vue&amp;#39;; // State export interface IState { drawer: boolean; } export const stateKey: InjectionKey&amp;lt;Ref&amp;lt;IState&amp;gt;&amp;gt; = Symbol(); const state = reactive&amp;lt;IState&amp;gt;({ drawer: false, }); provide&amp;lt;IState&amp;gt;(stateKey, computed(()=&amp;gt;state)); &amp;lt;/script&amp;gt; 下游元件
&amp;lt;script setup lang=&amp;#34;ts&amp;#34;&amp;gt; import { inject, ref } from &amp;#39;vue&amp;#39;; import { stateKey } from &amp;#39;./Parent.vue&amp;#39;; const state = inject(stateKey, ref({ drawer: false })); &amp;lt;/script&amp;gt; Reference Vue.js/guild - Provide / Inject Vue.</description></item><item><title>[DIY] 設計一個可回傳 Promise 的 Dialog 元件方法</title><link>https://blog.tigernaxo.com/posts/frontend-vue/vue-comp-promise/</link><pubDate>Fri, 26 Aug 2022 15:03:00 +0800</pubDate><guid>https://blog.tigernaxo.com/posts/frontend-vue/vue-comp-promise/</guid><description>有用過 sweetalert2 的話，應該會喜歡可以同步等待對話框回傳值的方式， 這裡做一個 Vue2 元件，呼叫該元件的方法會彈出對話框等待使用者輸入，並且回傳 Promise， 如此一來就能夠在同一個函式當中處理使用者輸入值。
Dialog 元件設計原理:
元件方法 GetConfirm() 顯示 Dialog 元件並回傳一個 Promise，。 設置watcher讓元件取得使用者輸入後 resolve promise 得利於上述元件的設計，實際上的效益是將複雜度封裝到子元件裡面(watcher移動到元件內)， 如此不需在上層元件撰寫使用者輸入取值的監視邏輯， 讓我們得以在上層元件直接 await GetConfirm 同步取得值進行操作。
這個概念的用途非常廣，例如 Vue router 的 component route guard，在離開表單頁面前跳出使用者確認的 Dialog。
Vuejs 實作 &amp;lt;button id=&amp;#34;xBtn&amp;#34;&amp;gt;執行測試&amp;lt;/button&amp;gt; &amp;lt;div id=&amp;#34;xApp&amp;#34; class=&amp;#34;modal&amp;#34; :style=&amp;#34;{display: dialog?&amp;#39;block&amp;#39;:&amp;#39;none&amp;#39;}&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;modal-content&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;close&amp;#34;&amp;gt;Test Modal&amp;lt;/span&amp;gt; &amp;lt;p&amp;gt;The value selected will resolve by promise.&amp;lt;/p&amp;gt; &amp;lt;button @click=&amp;#34;choose(1)&amp;#34;&amp;gt;1&amp;lt;/button&amp;gt; &amp;lt;button @click=&amp;#34;choose(2)&amp;#34;&amp;gt;2&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; let data = { result: null, dialog: false } let dialog = new Vue({ el: &amp;#39;#xApp&amp;#39;, data:() =&amp;gt; data, methods: { getConfirm() { // 先清空 result (避免兩次選中一樣的值無法觸發 watcher) this.</description></item><item><title>[DIY] Vue Router 使用 Navigation Guard 加入查詢參數</title><link>https://blog.tigernaxo.com/posts/frontend-vue/vue-router_add_query/</link><pubDate>Thu, 19 Aug 2021 17:20:00 +0800</pubDate><guid>https://blog.tigernaxo.com/posts/frontend-vue/vue-router_add_query/</guid><description>工作上需要把每一個路由都加上同一個 query string 第一直覺就是直接寫成這樣：
router.beforeEach(async (to, from, next) =&amp;gt; { next({ path: path, query: {...to.queryl ,token: tokenStr} }) }) 結果卻跳出 Maximum call stack size exceeded 的錯誤，判斷程式出現無窮迴圈：
runtime.js?96cf:285 Uncaught (in promise) RangeError: Maximum call stack size exceeded 第一個反應是傻眼貓咪，為什麼 next() 不傳入參數的時候不會出現無窮迴圈，但塞進參數就會， 難道說 next() 在傳入參數與不傳入參數的行為並不相同！！ 因此去翻閱官網對 next() 的說明：
next: Function: this function must be called to resolve the hook. The action depends on the arguments provided to next:
next(): move on to the next hook in the pipeline.</description></item><item><title>[DIY] 用 Render Function 打造靈活的 CheckBox 元件範例</title><link>https://blog.tigernaxo.com/posts/frontend-vue/vue-comp-yncheckbox/</link><pubDate>Thu, 29 Jul 2021 13:50:00 +0800</pubDate><guid>https://blog.tigernaxo.com/posts/frontend-vue/vue-comp-yncheckbox/</guid><description>情境1：要選取多個 ckeckbox 對應到資料庫的欄位，欄位值是一串YN代表某個選項是否有被選去，例如： YNNYYNNYYN 情境2：要選取多個 ckeckbox 對應到資料庫的欄位，欄位值只有一個，可能是任何字元，例如： 1 可以打造兩個元件，分別對應至單選、多選 單選元件 程式碼 (Code) Vue.component(&amp;#39;x-ck-single&amp;#39;, { props: { disabled: { type: Boolean, default: () =&amp;gt; false }, // checkbox 的標記 [string] || [{text:string, value:any}] labels: { type: Array, default: () =&amp;gt; [&amp;#39;Yes&amp;#39;, &amp;#39;No&amp;#39;] }, value: { default: () =&amp;gt; null }, trueValue: { default: () =&amp;gt; &amp;#39;Y&amp;#39; }, falseValue: { default: () =&amp;gt; &amp;#39;N&amp;#39; }, inline: { type: Boolean, default: () =&amp;gt; false }, }, data() { return { innervalue_: this.</description></item></channel></rss>