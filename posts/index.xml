<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on YuCheng&#39;s Site</title>
    <link>https://tigernaxojr.github.io/blog/posts/</link>
    <description>Recent content in Posts on YuCheng&#39;s Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 14 Jun 2022 00:20:00 +0800</lastBuildDate><atom:link href="https://tigernaxojr.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>Resultados de Búsqueda</title>
      <link>https://tigernaxojr.github.io/blog/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/search/</guid>
      <description>Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.
No se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html
Establecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.
Esta implementación utiliza Fusejs, jquery y mark.js
Configuración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://tigernaxojr.github.io/blog/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://tigernaxojr.github.io/blog/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://tigernaxojr.github.io/blog/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://tigernaxojr.github.io/blog/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://tigernaxojr.github.io/blog/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://tigernaxojr.github.io/blog/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://tigernaxojr.github.io/blog/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://tigernaxojr.github.io/blog/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://tigernaxojr.github.io/blog/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://tigernaxojr.github.io/blog/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://tigernaxojr.github.io/blog/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>অনুসন্ধানের ফলাফল</title>
      <link>https://tigernaxojr.github.io/blog/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>[SQL] MERGE</title>
      <link>https://tigernaxojr.github.io/blog/posts/database/sql-oracle-merge/</link>
      <pubDate>Tue, 14 Jun 2022 00:20:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/database/sql-oracle-merge/</guid>
      <description>一段神奇的語法，可以指定對舊資料、新的資料分別進行不同的動作(通常是更新、新增)， 不指定的話預設是 BY TARGET， 動作目標都是 TARGET。
在更新清單的時候特別好用。
MERGE INTO  DETAIL AS TARGET -- 目標表格  USING ( VALUES (@k1, @k2, @k3, @f1)) AS SOURCE (k1, k2, k3, f1) -- 資料來源  ON SOURCE.k1 = TARGET.k1 AND SOURCE.k2 = TARGET.k2 AND SOURCE.k3 = TARGET.k3 -- 兩造欄位核對條件 -- TARGET 有，SOURCE 也有，SOURCE 更新到 TARGET WHEN MATCHED THEN -- 以 TARGET 為目標，更新 SOURCE 裡面被 TARGET 對應(BY TARGET)的資料?(這邊 BY 哪裡都一樣)  UPDATE SET f1 = SOURCE.</description>
    </item>
    
    <item>
      <title>[Container] 學習資源</title>
      <link>https://tigernaxojr.github.io/blog/posts/container/base-resource/</link>
      <pubDate>Mon, 25 Apr 2022 06:26:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/container/base-resource/</guid>
      <description> DockerHub Docker文件 K8S  </description>
    </item>
    
    <item>
      <title>[Docker] 安裝PostgreSQL</title>
      <link>https://tigernaxojr.github.io/blog/posts/container/docker-postgresql/</link>
      <pubDate>Mon, 25 Apr 2022 06:26:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/container/docker-postgresql/</guid>
      <description>安裝 postgreSQL 拉取 postgres image $ docker pull postgres Using default tag: latest latest: Pulling from library/postgres 1fe172e4850f: Pull complete c2bb685f623f: Pull complete 3027ff705410: Pull complete 062371e3461d: Pull complete 39d54e944de7: Pull complete 6530357dda9a: Pull complete b1d302dc78c6: Pull complete f6d91cb1d3c1: Pull complete 9bbd62b0af28: Pull complete 3cfdfc8fbef3: Pull complete 635f8fae1d06: Pull complete 96b6711661dd: Pull complete c08147da7b54: Pull complete Digest: sha256:ab0be6280ada8549f45e6662ab4f00b7f601886fcd55c5976565d4636d87c8b2 Status: Downloaded newer image for postgres:latest docker.io/library/postgres:latest 檢查 docker images
$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 74b0c105737a 4 days ago 376MB 建立 volume docker volume create --name pg-data 執行 Image 環境變數</description>
    </item>
    
    <item>
      <title>[SQL] 用 CTE (Common Table Expression) 達成遞迴查詢，建立 MenuTree</title>
      <link>https://tigernaxojr.github.io/blog/posts/database/sql-recursive/</link>
      <pubDate>Mon, 25 Apr 2022 06:26:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/database/sql-recursive/</guid>
      <description>建立一個暫存表 testCTE，並暫存查詢語句(所有資料)的結果 MSSQL CTE 名稱前不需加上 RECURSEIVE 關鍵字，必須使用 UNION ALL PostgreSQL：CTE 名稱前需加上 RECURSIVE 關鍵字，可用 UNION 或 UNION ALL
WITH testCTE (id, name, parentId, lvl) AS (  -- 取得第一層的資料(Anchor member)(假設沒有 parentId 的是第一層)  SELECT id, name parentId, 0 AS lvl FROM menus WHERE parentId IS NULL  UNION ALL  -- 遞迴取得 Recursive member  (  SELECT A.id, A.name, A.parentId, A.lvl + 1 AS level FROM menus A  INNER JOIN testCTE B on A.</description>
    </item>
    
    <item>
      <title>[DevOps] CI/CD-01 安裝 Jenkins</title>
      <link>https://tigernaxojr.github.io/blog/posts/devops/pipeline/01_install_jenkins/</link>
      <pubDate>Mon, 18 Oct 2021 14:04:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/devops/pipeline/01_install_jenkins/</guid>
      <description>環境 硬體部分官方提到: RAM &amp;gt; 256NB，最好 2GB，空間留至少 10GB 放置 Docker 映像檔。 環境部分需要安裝 Java (8 或 11) 和 Docker
安裝 Docker # 卸載舊的 docker sudo apt-get remove -y docker docker-engine docker.io containerd runc  # 安裝必要的套件 # apt-transport-https 讓套件管理程式可以透過 https 協定使用 repo sudo apt-get update sudo apt-get install -y \  apt-transport-https \  ca-certificates \  curl \  gnupg \  lsb-release  # 添加 Docker 官方 GPG key curl -fsSL https://download.</description>
    </item>
    
    <item>
      <title>[Security] 利用免費開源資安檢測軟體 SonarQube 檢測 .NET Core 程式碼</title>
      <link>https://tigernaxojr.github.io/blog/posts/devops/sonarqube_netcore31/</link>
      <pubDate>Wed, 22 Sep 2021 11:11:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/devops/sonarqube_netcore31/</guid>
      <description>弱點掃描時常使用 owasp top 10 作為報告， 然而 owasp 軟體一年要價不菲，委外掃一次也是非常貴， 使用免費的 SonarQube 將弱點掃描整合到 CI/CD 階段， 要交付前再花錢委外掃一次似乎是個折衷的作法，避免一次檢測出來的弱點過多改動過大。
SonarQube 分為兩個部分 SonarQube Server、Scanner (Client 端程式)。 Scanner 負責進行掃描並將結果上傳 Server， 而 Server 作為負責處理和儲存分析報告的 compute engine 會分析上傳的結果， 並提供 Web 使用者介面、搜尋功能，因此分析完成後就可以直接在 Web 上查看報告， Scanner 除了能夠在 locale 端使用，還能直接整合到 CI/CD Server 上進行程式碼品質掃描。 雖說可以拿 localhost 直接作為 Server 使用， 這裡還是紀錄如何在虛擬機器上實際安裝 SonarQube， 以後在實際機器上安裝就可以作為參考，
準備 Linux Server 硬體 個人使用或小規模的團隊在一台機器上安裝就足夠使用了， 如果需要架設提供大量服務的伺服器，官網也提供 Cluster 的安裝方式方便做 Loading Balance。
這裡紀錄在一台 Ubuntu 20.04 上架設。 關於 Linux 安裝過程在這裡不加贅述， 官方提到硬體有幾個注意事項，對現代的硬體來說其實都還好，比較要注意的是硬碟空間：
 RAM 至少要 2G；free RAM 至少要 1G (所以用 Windows server 就要準備大很多喔)。 上傳報告需要一定的空間，因次對硬碟的空間與效能有一定的要求，不夠的話容易太慢。 server side 不支援 32-bit 作業系統；但 Scanner 可以支援 32-bit systems。  安裝 OpenJDK 11 sudo apt update sudo apt upgrade sudo apt install openjdk-11-jdk # 確認 java 版本 java --version 然後在 .</description>
    </item>
    
    <item>
      <title>[Web] 把電腦的難字造字檔用 FontForge 轉為字型放到網頁上使用</title>
      <link>https://tigernaxojr.github.io/blog/posts/web-tool/web-tool-eudc-frontforge/eudc/</link>
      <pubDate>Tue, 24 Aug 2021 10:07:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/web-tool/web-tool-eudc-frontforge/eudc/</guid>
      <description>Web 在顯示姓名的時候常會遇到中文難字無法顯示， 此時開發者在本機端如果有安裝造字檔 EUDC.TTE 就可以轉為 woff、woff2、ttf 讓網頁正確顯示難字。 過程需要字型工具軟體 FontForge， 步驟如下：
 拿到造字檔 EUDC.TTE   用 cmd 打開 regedit (win10 搜尋圖示點下後，輸入 cmd，出現小黑窗後再輸入 regedit) 找到機碼 HKEY_CURRENT_USER -&amp;gt; EUDC -&amp;gt; 950 資料夾下的 SystemDefaultEUDCFont 設定檔。 從設定檔的值就是 EUDC 的存放位址取出 EUDC.tte，我這裡是 C:\CIBEN\EUDC.tte  安裝 FontForge，找到 fontforge.exe 的位址 (注意，跟桌面捷徑呼叫的執行檔不一樣！)，我的是在 C:/Program Files (x86)/FontForgeBuilds/bin/fontforge.exe 建立一個轉檔腳本 tte-extract.pe，內容如下 # Open EUDC TTEOpen(&amp;#34;EUDC.tte&amp;#34;, 4)# CHANGE TTFNAME 2 EUDC SetTTFName(0x409,1,&amp;#34;EUDC&amp;#34;)SetTTFName(0x409,2,&amp;#34;EUDC&amp;#34;)SetTTFName(0x409,3,&amp;#34;EUDC&amp;#34;)SetTTFName(0x409,4,&amp;#34;EUDC&amp;#34;)SetTTFName(0x404,1,&amp;#34;EUDC&amp;#34;)SetTTFName(0x404,2,&amp;#34;EUDC&amp;#34;)SetTTFName(0x409,3,&amp;#34;&amp;#34;)SetTTFName(0x404,4,&amp;#34;EUDC&amp;#34;)SetFontNames(&amp;#34;EUDC&amp;#34;, &amp;#34;EUDC&amp;#34;, &amp;#34;EUDC&amp;#34;, &amp;#34;Regular&amp;#34;, &amp;#34;655&amp;#34;, &amp;#34;1.</description>
    </item>
    
    <item>
      <title>[DIY] Vue Router 使用 Navigation Guard 加入查詢參數</title>
      <link>https://tigernaxojr.github.io/blog/posts/vuejs/router_add_query/</link>
      <pubDate>Thu, 19 Aug 2021 17:20:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/vuejs/router_add_query/</guid>
      <description>工作上需要把每一個路由都加上同一個 query string 第一直覺就是直接寫成這樣：
router.beforeEach(async (to, from, next) =&amp;gt; {  next({  path: path,  query: {...to.queryl ,token: tokenStr}  }) }) 結果卻跳出 Maximum call stack size exceeded 的錯誤，判斷程式出現無窮迴圈：
runtime.js?96cf:285 Uncaught (in promise) RangeError: Maximum call stack size exceeded 第一個反應是傻眼貓咪，為什麼 next() 不傳入參數的時候不會出現無窮迴圈，但塞進參數就會， 難道說 next() 在傳入參數與不傳入參數的行為並不相同！！ 因此去翻閱官網對 next() 的說明：
 next: Function: this function must be called to resolve the hook. The action depends on the arguments provided to next:</description>
    </item>
    
    <item>
      <title>[.NET Core] 在 Ubuntu 20.04 上部署 .NET Core 3.1 (使用 Nginx 反向代理)</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/deploy-ubuntu2004-nginx/ubuntu2004_nginx/</link>
      <pubDate>Wed, 11 Aug 2021 16:48:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/deploy-ubuntu2004-nginx/ubuntu2004_nginx/</guid>
      <description>設置 Ubuntu 安裝 .NET Core Runtime wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb sudo apt update sudo apt install apt-transport-https sudo apt install dotnet-runtime-3.1 安裝 Nginx 新增套件來源，新增檔案 /etc/apt/sources.list.d/nginx.list
#/etc/apt/sources.list.d/nginx.list. deb https://nginx.org/packages/ubuntu/ focal nginx deb-src https://nginx.org/packages/ubuntu/ focal nginx 安裝
sudo apt update sudo apt install nginx -y 啟動、設定開機啟動
# 啟動 nginx sudo systemctl start nginx # 設置 nginx 開機啟動 sudo systemctl enable nginx # 確認 nginx 運行狀態 sudo systemctl status nginx 設置 Nginx 反向代理本機的 5000 連接埠(之後 Kestrel 的 http 服務端口)</description>
    </item>
    
    <item>
      <title>[.NET Core 3.1] JsonDocument 與 DataTable 的互相轉換</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/snippet-json-dt/</link>
      <pubDate>Fri, 06 Aug 2021 14:56:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/snippet-json-dt/</guid>
      <description>在 LINQ 當道的時代雖然 DataTable 比較少用了，但還是難免會碰到， 下面紀錄如何在.NET Core 裡面把 DataTable 的資料轉成 JsonElement，
public JsonElement jsonFromDataTable(DataTable dt) {  using (var stream = new MemoryStream()) {  using (var writer = new Utf8JsonWriter(stream)) {  // 起始一個裝 JElement 的陣列  writer.WriteStartArray();  foreach (DataRow row in dt.Rows) {  // 開始寫入每個 Row 各自對應的 JElement 寫入程序  writer.WriteStartObject();  foreach (DataColumn column in row.Table.Columns) {  // 先寫入屬性名稱  writer.WritePropertyName(column.ColumnName);  // 判斷欄位值是否為 DBNull 來寫入值或 Null  if (row[column.</description>
    </item>
    
    <item>
      <title>[.NET Core] .NET Core 中對 JsonElement 的操作</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/snippet-json-operate/</link>
      <pubDate>Fri, 06 Aug 2021 14:37:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/snippet-json-operate/</guid>
      <description>.NET Core 中對 JsonElement 的操作不像以往 Newtonsoft.Json 一樣直覺， 需要自己建立一個方便的讀寫方法，原理是寫到另一個 JsonDocument， 如果要移除某個屬性也是一樣的道理，變成從從屬性名稱判斷是不是要寫到新的 JsonDocument， 下面是添加一個屬性的範例。
public static class JsonExt { 	public static void Add(ref this JsonElement source, string name, string value) 	{ 	using (MemoryStream ms = new MemoryStream()) 	{ 	using (Utf8JsonWriter writer = new Utf8JsonWriter(ms)) 	{ 	using (JsonDocument json = JsonDocument.Parse(&amp;#34;{}&amp;#34;)) 	{ 	writer.WriteStartObject(); // 開始 	foreach (var el in source.EnumerateObject()) 	el.WriteTo(writer); 	// 寫入新屬性 	writer.</description>
    </item>
    
    <item>
      <title>[DIY] 用 Render Function 打造靈活的 CheckBox 元件範例</title>
      <link>https://tigernaxojr.github.io/blog/posts/vuejs/vuejs-comp-yncheckbox/</link>
      <pubDate>Thu, 29 Jul 2021 13:50:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/vuejs/vuejs-comp-yncheckbox/</guid>
      <description>情境1：要選取多個 ckeckbox 對應到資料庫的欄位，欄位值是一串YN代表某個選項是否有被選去，例如： YNNYYNNYYN 情境2：要選取多個 ckeckbox 對應到資料庫的欄位，欄位值只有一個，可能是任何字元，例如： 1 可以打造兩個元件，分別對應至單選、多選  單選元件 程式碼 (Code) Vue.component(&amp;#39;x-ck-single&amp;#39;, {  props: {  disabled: { type: Boolean, default: () =&amp;gt; false },  // checkbox 的標記 [string] || [{text:string, value:any}]  labels: { type: Array, default: () =&amp;gt; [&amp;#39;Yes&amp;#39;, &amp;#39;No&amp;#39;] },  value: { default: () =&amp;gt; null },  trueValue: { default: () =&amp;gt; &amp;#39;Y&amp;#39; },  falseValue: { default: () =&amp;gt; &amp;#39;N&amp;#39; },  inline: { type: Boolean, default: () =&amp;gt; false },  },  data() {  return {  innervalue_: this.</description>
    </item>
    
    <item>
      <title>[DIY] 設計一個可回傳 Promise 的 Dialog 元件方法</title>
      <link>https://tigernaxojr.github.io/blog/posts/vuejs/vuejs-comp-promise/</link>
      <pubDate>Sat, 24 Jul 2021 07:32:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/vuejs/vuejs-comp-promise/</guid>
      <description>有用過 sweetalert2 的話，應該會喜歡可以同步等待對話框回傳值的方式， 這裡做一個 Vue2 元件，呼叫該元件的方法會彈出對話框等待使用者輸入，並且回傳 Promise， 如此一來就能夠在同一個函式當中處理使用者輸入值。
Dialog 元件設計原理:
 元件方法 GetConfirm() 顯示 Dialog 元件並回傳一個 Promise，。 設置watcher讓元件取得使用者輸入後 resolve promise  得利於上述元件的設計，實際上的效益是將複雜度封裝到子元件裡面(watcher移動到元件內)， 如此不需在上層元件撰寫使用者輸入取值的監視邏輯， 讓我們得以在上層元件直接 await GetConfirm 同步取得值進行操作。
這個概念的用途非常廣，例如 Vue router 的 component route guard，在離開表單頁面前跳出使用者確認的 Dialog。
程式碼 (Code) &amp;lt;button id=&amp;#34;xBtn&amp;#34;&amp;gt;執行測試&amp;lt;/button&amp;gt; &amp;lt;div id=&amp;#34;xApp&amp;#34; class=&amp;#34;modal&amp;#34; :style=&amp;#34;{display: dialog?&amp;#39;block&amp;#39;:&amp;#39;none&amp;#39;}&amp;#34;&amp;gt;  &amp;lt;div class=&amp;#34;modal-content&amp;#34;&amp;gt;  &amp;lt;span class=&amp;#34;close&amp;#34;&amp;gt;Test Modal&amp;lt;/span&amp;gt;  &amp;lt;p&amp;gt;The value selected will resolve by promise.&amp;lt;/p&amp;gt;  &amp;lt;button @click=&amp;#34;choose(1)&amp;#34;&amp;gt;1&amp;lt;/button&amp;gt;  &amp;lt;button @click=&amp;#34;choose(2)&amp;#34;&amp;gt;2&amp;lt;/button&amp;gt;  &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;script&amp;gt; let data = { result: null, dialog: false } let dialog = new Vue({  el: &amp;#39;#xApp&amp;#39;,  data:() =&amp;gt; data,  methods: {  getConfirm() {  // 先清空 result (避免兩次選中一樣的值無法觸發 watcher)  this.</description>
    </item>
    
    <item>
      <title>[架構] 多層式架構(Multitier Architecture)</title>
      <link>https://tigernaxojr.github.io/blog/posts/system/arch_n_tier/</link>
      <pubDate>Mon, 17 May 2021 23:20:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/system/arch_n_tier/</guid>
      <description>多層式架構 Multitier Architecture 或稱 N-Tier Architecture， 是 Client–server architecture 的一種， 多層架構的層可以是 layer 或 tier，這兩者之間主要的差別在於 layer 指程式邏輯在應用程式的位置； 而 tier 指 layer 在系統上實際部屬執行的位址，屬於物理層級的指涉。 這一篇的層指的是 tier。
N-tier model N-tier model，層與層之間的邊界有 N-1 個，而程式跨邊界會造成巨大的效能損失， 一說為光是跨越同一台機器上不同進程(process)邊界存取資源損失就大約1000倍， 如果透過網路進行遠端呼叫勢必損失更多， 因此每跨越一個邊界進行資源存取效能就會以幾何級數損失。 且增加邊界在軟體設計上會增加複雜度，簡單的應用程式使用多層式架構很容易造成過度設計(over design)， 因此如何適當添加層級(tier)也是一門學問，添加層級時必需考量如何在應用程式所部屬的環境獲取最大的成本效益。 軟體是否採用多層式架構必須以多層式架構的優缺點進行取捨(尤其是可擴展性與效能之間)。
 提高可擴展性(scalability)。 提高效能(performance)。 提高容錯率(fault tolerance)。 提高安全性(security)。  1-tier model 所有的 layer 都在同一機器、同一記憶體空間內運行，因此不需考慮網路造成的性能損失。
2-tier model layer 分配至兩個不同的記憶體空間運行，記憶體空間可能位於相同或兩台不同的機器上(通常是不同機器)，典型的例子是分配到 client、server 上運行。
3-tier model 多層式架構當中最常使用的就是三層架構(three-tier architecture)。 三層架構與Web應用程式來說明如下：
 表現層(Presentation)：又稱為 UI 層，以Web來說就是呈現出來的前端網頁。 應用程式層(Application)：以 Web 來說相當於伺服器上執行的應用程式。 資料層(Data)：這一層包含資料儲存、呈現機制，以 Web 來說通常指 Database。  Reference  wikipedia - Multitier architecture Rockford Lhotka - Should all apps be n-tier?</description>
    </item>
    
    <item>
      <title>[Tools] 10分鐘建造 proxy 克服跨網域資源存取(CORS)問題</title>
      <link>https://tigernaxojr.github.io/blog/posts/javascript/diy-http-proxy-middleware/</link>
      <pubDate>Sat, 20 Mar 2021 08:45:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/javascript/diy-http-proxy-middleware/</guid>
      <description>前後端分離的開發環境以 Ajax 呼叫資源時時會遇到跨網域存取的問題， 一些比較全面的開發環境像是 webpack、vue-cli 等等通常提供內建開發代理伺服器可供設置， 如果要對於不熟悉的開發環境進行快速除錯 (例如 vue 開發者臨時檢查其他框架的程式碼遇到跨網域問題)， 重新研究如何設置開發環境跨網域代理伺服器往往就花費多餘的時間 (不過最終還是要搭建起來阿，喂~~)， 因此紀錄一下怎麼用 node.js 建立一個通用的代理伺服器處理跨網域問題，整個過程不超過5分鐘。
步驟 首先安裝 node.js 建立專案資料夾 建立一個資料夾叫做 proxy 存放這個專案吧，手動建立也可以。
mkdir proxy 起始專案 用指令移動到該專案資料夾下，起始專案：
cd proxy npm init 安裝相依性 npm i express http-proxy-middleware cors 建立 app.js const express = require(&amp;#39;express&amp;#39;); const cors = require(&amp;#39;cors&amp;#39;); const { createProxyMiddleware } = require(&amp;#39;http-proxy-middleware&amp;#39;);  // 建立一個 Express 伺服器 const app = express(); app.use(cors())  // 設定 Express 伺服器的 Host、Port const PORT = 3000; const HOST = &amp;#34;localhost&amp;#34;;  // 設定代理到 google 的 Proxy 端點 app.</description>
    </item>
    
    <item>
      <title>[.NET Core] 不阻塞的非同步控制器(Non-Blocking Asynchronous Controllers)</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/basic-async-controller/</link>
      <pubDate>Wed, 17 Mar 2021 03:32:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/basic-async-controller/</guid>
      <description>ASP .NET Core 當中的 Web 控制器屬於IO密集的應用程式，當中主要使用的 TAP 是一種簡易使用、語言層級的非同步設計模式。 透過 TAP 可設計出非同步(Asynchronous)/非阻塞(Non-Blocking)的 Web API，大幅提高 Web 應用程式的併發性(Concurrency)。
非同步方法 C# 當中基於 TAP 設計的的非同步方法 (TAP method) 有幾個特性：
 產生可等待 awaitable 型別 (Task, Task&amp;lt;TResult&amp;gt;, ValueTask, 和 ValueTask&amp;lt;TResult&amp;gt;)， 其中以 Task、Task&amp;lt;TResult&amp;gt;最常見。 非同步方法的參數順序通常跟同步版本的方法相同，但方法名稱以 Async 結尾。  async、await await 運算子用來等待非同步行為完成， 或等待非同步行為完成後解析回傳值， await 運算子只能用在非同步方法中， 因此 await 運算子的外層方法必須套用 async 修飾， 否則會出現錯誤。
非同步 Action 設計原則： 總是加上 async 關鍵字 async 的方法裡面可以等待非同步方法。 action 前加上 async 的作用在於建立一個管理回傳任務的狀態機(state machine)， 當 async 方法擲出例外時會被狀態機捕獲並放到任務中回傳， 而這也是以 Task 作為回傳值的方法的預期行為。 如果沒有 async 關鍵字則擲出的例外會被直接傳遞到呼叫者(caller)， 因此除非確定該 aciton 不會擲出任何例外，否則一律加上 async。</description>
    </item>
    
    <item>
      <title>[.NET Core] ASP .NET Core 3.1 驗證與授權(二)-驗證設定</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/startup-auth/auth_guild_2/</link>
      <pubDate>Fri, 12 Mar 2021 23:08:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/startup-auth/auth_guild_2/</guid>
      <description>驗證方案(Authentication Scheme) 驗證方案包含兩個部分：
 驗證處理函式(Authentication handler)，可能是 IAuthenticationHandler 或 AuthenticationHandler 的實作，相當於驗證方案的行為，責任範圍涵蓋:  驗證使用者， 驗證成功時，建構呈現使用者識別(user identity)的 AuthenticationTicket。 驗證失敗時，回傳 &amp;rsquo;no result&amp;rsquo; 或 &amp;lsquo;failure&amp;rsquo; 負責從請求上下文(request context)中建構使用者識別 (user identity)。 定義了 challenge/forbid action。   驗證處理函式的設定選項(Opitons of Authentication handler)。  驗證方案當中的 authencate action 負責從請求上下文(request context)中建構使用者識別 (user identity)， 常見的例子為：
 cookie authentication scheme 從 cookie 資訊建構 user identity. JWT bearer scheme 反序列化(deserialize)、驗證(validate) token，並從 token 所攜帶資訊建構 user identity  使用驗證方案 在 Startup.ConfigureServices 以 AddAuthentication 註冊驗證服務時會回傳一個 AuthenticationBuilder， AuthenticationBuilder 設定驗證方案的方式有：</description>
    </item>
    
    <item>
      <title>[Tools] 在 linux 中使用 google drive cli</title>
      <link>https://tigernaxojr.github.io/blog/posts/other/linux-gdrive-cli/</link>
      <pubDate>Fri, 29 Jan 2021 23:46:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/other/linux-gdrive-cli/</guid>
      <description>重新編譯 gdrive 取得憑證  首先到Google API Console， 建立專案 啟動 Google Drive API。 啟用之後選擇左邊的&amp;quot;設定同意畫面&amp;quot;，填寫必要的欄位其他依照需求設置就好 建立一組 OAth2 憑證，會有 Client ID 和 Secret  編譯專案  1.安裝 Golang 2.下載 gdrive 專案 git clone git@github.com:prasmussen/gdrive.git  3.修改專案下的handlers_drive.go，把下列兩行改成拿到的 Client ID、Secret const ClientId = &amp;#34;*************************************.com&amp;#34; const ClientSecret = &amp;#34;*************&amp;#34;  4.取得需要的 golang 套件 go get github.com/prasmussen/gdrive  5.到專案資料夾下編譯，編譯完後就會有得到執行檔 go build   設定 設置環境變數 將編譯好的執行檔上傳Linux，假設放在${HOME}/gdrive-linux-x64：
# 建立${HOME}/bin $ mkdir -p ${HOME}/bin # 把gdrive-linux-x64放進去重新命名為gdrive $ mv ${HOME}/gdrive-linux-x64 ${HOME}/bin/gdrive # 賦予gdrive執行權限 $ chmod u+x ${HOME}/bin/gdrive  # 如果PATH裡面找不到${HOME}/bin就新增並重新讀取環境設定 $ echo ${PATH} | grep -qE ${HOME}/bin[^/] &amp;amp;&amp;amp; \ &amp;gt; echo &amp;#34;PATH=\${HOME}/bin:\${PATH}&amp;#34; &amp;gt;&amp;gt; ~/.</description>
    </item>
    
    <item>
      <title>[架構] 多層式架構(Multi-layer Architecture)</title>
      <link>https://tigernaxojr.github.io/blog/posts/system/arch-multi-layer/</link>
      <pubDate>Sun, 10 Jan 2021 23:21:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/system/arch-multi-layer/</guid>
      <description>多層架構的層可以是 layer 或 tier，這兩者之間主要的差別在於 layer 指程式邏輯在應用程式的位置； 而 tier 指 layer 在系統上實際部屬執行的位址，屬於物理層級的指涉。 這一篇的層指的是 layer。
為何以 multi-layer 撰寫程式碼
 增加程式彈性和複用性:程式社設計人員透過分離表現層、應用程式層、資料存取層的程式， 當程式需要變更時只需修改或抽換對應的程式層，而不需重寫整個應用程式。 易於維護:多層式架構中程式碼各司其職，容易定位問題發生點。 利於平行開發。 易於擴展。  BLL;Business Logic Layer 又稱為 Service Layer，命名習慣是 Service、Helper 結尾 DAL;Data Access Layer，命名習慣是 Repo 結尾
 one-tier:所有的邏輯全部寫在這 two-tier:抽離 BLL，BLL負責商業邏輯與資料存取 three-tier:從 BLL 抽離 DAL，BLL負責商業邏輯、DAL負責資料存取  分層  Presentation Layer(PL) Business Logic Layer(BLL) Service Layer(SL) Data Access Layer(DAL) Service Layer(SL) 是 Presentation Layer與Business Layer的中介層，使用的目的在於降低PL與BL之間的耦合， PL將商務邏輯功能委派給BL執行， Coarse-grained systemsfine-grained systems 一個SL操作(coarse-grained operation)通常包含複數BL操作(fine-grained operation)  Presentation Layer Business Logic Layer DTO(Data transfer object) 或 Value Object，只有屬性沒有方法 business object (BO)</description>
    </item>
    
    <item>
      <title>[JS] 非同步程式設計-Promise 與 Async/Await</title>
      <link>https://tigernaxojr.github.io/blog/posts/javascript/js-async/</link>
      <pubDate>Sat, 09 Jan 2021 01:32:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/javascript/js-async/</guid>
      <description>Promise Promise 狀態 Promise function 執行後會立即回傳一個稱為 Promise 的物件， Promise 本身帶有三種狀態：
 pending: 已初始化，但尚未成功或失敗。 fulfilled: 操作成功完成。 rejected: 操作失敗結束。  promise 一但被回傳就處於 pending 狀態， promise 的建構式有兩個參數個接收一個 function，可以操作 Promise 的 fulfilled 和 rejected。
// resolve(value): 放入解析的值 // reject(reson): 放入拒絕的理由 function test(value){  let reason = &amp;#39;找不到 value&amp;#39;  return new Promise((resolve, reject)=&amp;gt;{  value ? resolve(value) :reject(reason)  }) } 將 Promise 繫結回呼函式 若要將某個程式語句安排在 Promise 被滿足之後執行。 可以利用 Promise.prototype 上的三個物件方法(Instance Method)方法繫結回呼函式(callback function)： then catch finally resolve 會被 then 捕獲，reject 會被最近的 catch 捕獲</description>
    </item>
    
    <item>
      <title>[JS] 提升(Hoisting)與暫時性死區(Temporal Dead Zone)</title>
      <link>https://tigernaxojr.github.io/blog/posts/javascript/js-hoisting/</link>
      <pubDate>Sat, 09 Jan 2021 01:31:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/javascript/js-hoisting/</guid>
      <description>網路上時常見到充滿 function 與 var 的 JavaScript 求值題目， 筆者在釐清 Hoisting 和 TDZ 的觀念前時常覺得答案出乎意料， 雖然現在撰寫程式碼都已經避免使用 var，但是維護 legacy code 還是會用到，因此在這裡做個筆記。
Hoisting 對學過伺服器端語言(C#、C/C++&amp;hellip;)的人來說，預期試圖對未宣告的變數取值會出現 ReferenceError是很正常的事， 在 JavaScript 中也是如此：
console.log(x) // ReferenceError: x is not defined 但 JavaScript 把 var 宣告變數放在後面，x 前面對 x 取值就變成 undefine， 在 JavaScript 當中對變數取值獲得 undefine 代表變數處於宣告後已分配記憶體空間(初始化、initiation)但尚未賦值的狀態， 但是明明 JavaScript 在宣告前就取值，怎麼能夠認得 x、而且知道 x 被初始化為 undefined 呢？
console.log(x) // undefined var x 原因在於 javascript 會先程式中的蒐集 var(let/const/function) 宣告並釐清對應的作用域， 最後再執行程式碼，這個行為就如同宣告被提升(Hoisting)到前面行數的程式碼中一樣。
JavaScript 跟傳統 OOP 語言一樣，在變數提升後、宣告初始化、賦值等等時機取用變數會獲得不同輸出結果， 這篇文章(link)中提到， 稱 JavaScript 為直譯式(解釋型)語言實際上是通俗的說法，語言本身沒有規定實現的方式(編/直譯)， 舉例來說 Chrome 瀏覽器所使用的 Google V8 JavaScript engine， 所帶的解釋器 (interpreter) 會將程式編譯 (compile) 成字節碼 (bytecode)， 最後再由編譯器 (compiler) 即時編譯 (JIT;just-in-time compilation) 編譯成機器碼執行， 而 JavaScript 被編譯時宣告會被蒐集到最頂端進行定義並區分作用域(scope)，這個行為就是 Hoisting ，記住重點在於JS編譯後會先定義變數及區分作用域，編譯後的程式看起來就像這樣：</description>
    </item>
    
    <item>
      <title>[.NET Core] ASP .NET Core 3.1 驗證與授權(四)-授權設定</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/startup-auth/auth_guild_4/</link>
      <pubDate>Thu, 31 Dec 2020 14:08:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/startup-auth/auth_guild_4/</guid>
      <description>授權(Authorization)  授權(Authorization): 界定用戶可存取資源範圍的程序。  Policy-based authorization ASP .NET Core 的授權以政策 Policy 進行設定
自訂授權 RBAC Name 記載使用者識別名稱(User Identity) userData 記載以 | 分隔的使用者角色 Role
驗證與授權 Challenge、Forbid 中間件順序 先驗證、再授權 The Order of UseAuthentication、UseAuthorization
Reference  MSDN - Principal and Identity Objects MSDN - IAuthenticationService Interface MSDN - AuthenticationService Class MSDN - Overview of ASP.NET Core Security MSDN - Overview of ASP.NET Core authentication MSDN - Policy-based authorization in ASP.NET Core MSDN - Microsoft.</description>
    </item>
    
    <item>
      <title>[.NET Core] ASP .NET Core 3.1 驗證與授權(三)-Cookie 驗證實例</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/startup-auth/auth_guild_3/</link>
      <pubDate>Wed, 30 Dec 2020 23:24:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/startup-auth/auth_guild_3/</guid>
      <description>前兩篇介紹了驗證、授權在 .NET Core 當中的基本的概念，本節實作 Cookie 驗證的設定、簽發、登出&amp;hellip;
Configuration 在 Startup.ConfigureServices 方法中設置驗證方案， 並且可以在 AddCookie 當中設置 CookieAuthenticationOptions(見前一節)
// 設置 cookie 驗證作為應用程式預設的驗證方案 services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme) // 將 cookie 服務添加到服務容器當中  .AddCookie(); 在 Startup.Configure 方法中，呼叫 UseAuthentication、UseAuthorization， 啟用驗證中間件並設置 HttpContext.User 屬性， UseAuthentication 必須在 UseAuthorization 之前，且兩者都必須在 UseEndpoints 之前被呼叫：
app.UseAuthentication(); // 驗證 app.UseAuthorization(); // 授權  // 端點對應 app.UseEndpoints(endpoints =&amp;gt; {  endpoints.MapControllers();  endpoints.MapRazorPages(); }); Cookie Policy Middleware 在中間件當中設置的驗證政策會作用於全域(每個請求)， 舉例來說，最常用的就是限制應用程式所有 Cookie 的 SameSite 屬性， 所有 Controller 簽發的 Cookie.SamSite 屬性會被限縮為較嚴格(不比 MinimumSameSitePolicy 寬鬆)的設置：</description>
    </item>
    
    <item>
      <title>[.NET Core] ASP .NET Core 3.1 驗證與授權(X)-備註頁面</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/startup-auth/auth_guild_memo/</link>
      <pubDate>Mon, 23 Nov 2020 15:48:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/startup-auth/auth_guild_memo/</guid>
      <description>Identity Objects Principal Objects IPrincipal 物件帶有 IIdentity 物件的參考 可指定 Authentication Scheme 獲得 Identity
IAuthenticationService SignOutAsync 清除 Cookie 的 Claims 在 Cookie 寫入 Claims
Token 登入 登入 API 實作 宣告 ClaimsPrincipal 後，可利用服務容器已注入的認證服務(實作 IAuthencationService 的類別)，進行登入、登出。 使用 SignInAsync 方法登入(寫入認證資訊)需要這些東西：
 ClaimsPrincipal(必要)，我們需要 ClaimsPrincipal 攜帶 ClaimsIdentity 及 Claims。 AuthenticationScheme string (Optional)可指定 Scheme，若沒有給就是使用預設的 Scheme。 authProperties (Optional)，可指定自訂認證選項  AuthenticationHttpContextExtensions AuthenticationHttpContextExtensions 類別對 HttpContext 類別擴展出認證方法， 從服務容器中獲取 IAuthenticationService 實體類別，並調用同名方法。
IAuthenticationService SignOutAsync 清除 Cookie 的 Claims 可儲存 ClaimsPrincipal進行簽發(登入)認證，作為身分識別。</description>
    </item>
    
    <item>
      <title>[.NET Core] ASP .NET Core 3.1 驗證與授權(一)-驗證與授權</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/startup-auth/auth_guild_1/</link>
      <pubDate>Mon, 23 Nov 2020 08:39:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/startup-auth/auth_guild_1/</guid>
      <description>在進入 ASP .NET Core 3.1 中驗證(Authentication)與授權(Authorization)的作用流程前，應當對兩者有抽象概念上的認識，以及了解兩者的差異。
驗證(Authentication) 驗證是確認用戶識別碼(User Identity)的程序，通過驗證的用戶可具有一或多個用戶識別碼， 因此驗證服務本身就是使用者識別碼提供者 (User Identity Provider)， ASP.NET Core 3.1 當中以依賴注入(DI; Dependency Injection)將驗證服務注入服務容器 (Service Container)， 使應用程式驗證簽發時能夠取用。
授權(Authorization) 授權的作用是界定用戶可存取資源範圍，作用描述如下：
 限制所存取的資源是否需要驗證。 已獲得驗證的特定用戶、特定腳色方能存取特定資源。 所存取的資源需要以何種授權政策(Authorizaton Policy)、即驗證方案(Authencation Scheme)。  挑戰和禁止 有些名詞需要先解釋： 驗證方案(Authentication Scheme)當中設置了挑戰(Chellange)與禁止(Forbid)應該進行的動作，這些註冊於驗證方案的動作動作由授權叫用。
挑戰(Challenge) 未驗證使用者要存取需驗證才能存取的資源時， 授權服務會叫用 IAuthenticationService.ChallengeAsync 發起 challenge， challenge 被發起後所伴隨採取的行動稱為 challenge action， 且 challenge action 應讓使用者知道應該以哪一種驗證機制取得授權，常見的具體範例有：
 cookie 驗證方案將使用者轉址到登入頁面。 JWT 回傳 401 Unauthorized 狀態碼，並在 Header 帶入 www-authenticate: bearer。  禁止(Forbid) 已驗證的使用者要存取授權之外的資源時， 授權會叫用 IAuthenticationService.ForbidAsync 發起 Forbid， Forbid 發起後所伴隨採取的行動稱為 Forbid action， Forbid action 的目的是要讓使用者知道自己已通過認證、且不具權限訪問所請求的資源， 常見的具體範例有：</description>
    </item>
    
    <item>
      <title>[SignalR] Websocket 即時聊天程式(三) - 後端 Token 認證</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/startup-signalr/guild_3_validate_token/</link>
      <pubDate>Fri, 20 Nov 2020 22:44:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/startup-signalr/guild_3_validate_token/</guid>
      <description>安裝套件 要進行 Token 的認證，需要先安裝 Microsoft.AspNetCore.Authentication.JwtBearer 套件：
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer 註冊認證服務 新增一個檔案 DependencyInjection.cs，在當中製作 IServiceCollection 的擴充方法來自定義 JWT token 認證服務， 在裡面設置 Token 的認證規則、使用者識別碼對應、使用者群組對應， 而 SignalR 抓取使用者識別碼 (UserIdentifier) 的介面方法是 IUserIdProvider.GetUserId， 因此我們需要另外新增一個實作 IUserProvider 的類別注入服務容器給 SignalR 使用 ，該檔案程式碼如下：
using Microsoft.AspNetCore.Authentication.JwtBearer; using Microsoft.AspNetCore.SignalR; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Microsoft.IdentityModel.Tokens; using System.Diagnostics.CodeAnalysis; using System.IdentityModel.Tokens.Jwt; using System.Linq; using System.Threading.Tasks;  namespace SignalR.Extensions.DependencyInjection {  public static class MyAddConfig  {  public static IServiceCollection AddMyJWTAuth( [NotNull] this IServiceCollection services,  IConfiguration config  )  {   services.</description>
    </item>
    
    <item>
      <title>[Linux] 在 Ubuntu 20.04 中設置 vim plugin YouCompleteMe</title>
      <link>https://tigernaxojr.github.io/blog/posts/other/vim-plugin-ycm/</link>
      <pubDate>Wed, 18 Nov 2020 23:14:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/other/vim-plugin-ycm/</guid>
      <description>安裝 junegunn/vim-plug 管理套件 以指令安裝 junegunn/vim-plug
curl -fLo ~/.vim/autoload/plug.vim --create-dirs \  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 在 ~/.vimrc 加入 Plug &amp;lsquo;ycm-core/YouCompleteMe&amp;rsquo;
&amp;#34; Specify a directory for pluginscall plug#begin(&amp;#39;~/.vim/plugged&amp;#39;)Plug &amp;#39;ycm-core/YouCompleteMe&amp;#39;&amp;#34; Initialize plugin systemcall plug#end() 打開 vim，在 vim 命令列輸入安裝 Plugin 的指令下載 YCM，這個時候還沒編譯所以會顯示安裝失敗
:PlugInstall 編譯YCM 安裝編譯工具
sudo apt install -y build-essential cmake vim python3-dev 編譯
~/.vim/plugged/YouCompleteMe/install.py 測試 打開 vim 確認，完工~
Reference  GitHub - ycm-core/YouCompleteMe GitHub - junegunn/vim-plug  </description>
    </item>
    
    <item>
      <title>[Code] 複製元件內的文字</title>
      <link>https://tigernaxojr.github.io/blog/posts/javascript/code-copy-html-content/</link>
      <pubDate>Fri, 13 Nov 2020 06:26:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/javascript/code-copy-html-content/</guid>
      <description>要在前端用 JavaScript 將 DOM 的內容複製到剪貼簿有幾種姿勢：
Clipboard API 基本上目前(2020年底)，主流瀏覽器近期版本都支援了，如果不考慮 IE 的話倒是可以使用，語法精簡而且能非同步操作。
 不支援 IE 是非同步方法，會傳回 Promise 支援從變數直接複製到剪貼簿 只有 HTTPS 網頁可以使用此 API Chrome 66 之後透過 Clipboard 複製已經不會彈出提示視窗 只能在 active tab 發生作用 (a.k.a. 開發者無法在 colsole 做測試，會得到 DOMException: Document is not focused.)  function copyText(text) {   // 判斷瀏覽器支援  if (!navigator.clipboard) {  alert(&amp;#34;瀏覽器不支援 Clipboard API&amp;#34;)  // 這裡可以改用 document.execCommand(&amp;#39;copy&amp;#39;) 的方法  }   // 非同步複製至剪貼簿  let resolve = () =&amp;gt; {  console.</description>
    </item>
    
    <item>
      <title>[DIY] 用Typescript搭建簡易前端路由</title>
      <link>https://tigernaxojr.github.io/blog/posts/javascript/diy-simple-router/</link>
      <pubDate>Fri, 13 Nov 2020 06:26:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/javascript/diy-simple-router/</guid>
      <description>起始一個使用 vallina-ts 的 vite 專案並安裝套件，並使用 bootstrap 做簡單的 css 套用：
npm init vite@latest route-test #依序選擇 vallina-&amp;gt;vallina-ts  cd route-test npm i # 安裝套件 npm i bootstrap # 安裝 bootstrap 在 index.html 新增元素 app &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;  &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt;  &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/svg+xml&amp;#34; href=&amp;#34;favicon.svg&amp;#34; /&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt;  &amp;lt;title&amp;gt;Vite App&amp;lt;/title&amp;gt;  &amp;lt;/head&amp;gt;  &amp;lt;body&amp;gt;  &amp;lt;div id=&amp;#34;app&amp;#34; class=&amp;#34;container-fluid&amp;#34;&amp;gt;  &amp;lt;div id=&amp;#34;menu&amp;#34; class=&amp;#34;row g-0&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;  &amp;lt;div id=&amp;#34;root&amp;#34; class=&amp;#34;row g-0&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;  &amp;lt;/div&amp;gt;  &amp;lt;script type=&amp;#34;module&amp;#34; src=&amp;#34;/src/main.</description>
    </item>
    
    <item>
      <title>[JS] 各種模組(module)</title>
      <link>https://tigernaxojr.github.io/blog/posts/javascript/js-module/</link>
      <pubDate>Fri, 13 Nov 2020 06:26:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/javascript/js-module/</guid>
      <description>JS模組規範有很多：AMD、UMD、CMD、commonJS、ES6 module
Reference  JS模組規範：AMD、UMD、CMD、commonJS、ES6 module  </description>
    </item>
    
    <item>
      <title>[SignalR] Websocket 即時聊天程式(四) - 前端登入頁面</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/startup-signalr/guild_4_front_end_login/</link>
      <pubDate>Tue, 10 Nov 2020 05:05:45 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/startup-signalr/guild_4_front_end_login/</guid>
      <description>安裝 axios SignalR 連線驗證的方式是將 token 夾帶於網址參數中發送到伺服器，因此進行 websocket 連線前我們透過 ajax 向伺服器發送帳號密碼索取登入的 Token，我們安裝方便使用 ajax 的 axios 函式庫：
axios 一樣可以透過 LibMan 安裝~
libman install axios@latest \  -p unpkg \  -d wwwroot/js/axios \  --files dist/axios.min.js 在 wwwRoot/index.html 添加對 axios 的引用：
&amp;lt;script src=&amp;#34;./lib/axios/dist/axios.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 簡易登入UI 雖然是功能原型，為了讓做出來的頁面不要太粗暴，拿 bootstrap 的 css 來套用一下 UI：
libman install bootstrap@5.0.0-alpha2 \  -p unpkg \  -d wwwroot/lib/bootstrap \  --files dist/js/bootstrap.min.js \  --files dist/css/bootstrap.min.css 在 wwwRoot/index.html 添加對 bootstrap css 的引用：</description>
    </item>
    
    <item>
      <title>[SignalR] Websocket 即時聊天程式(二) - 後端 Token 授權</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/startup-signalr/guild_2_issue_token/</link>
      <pubDate>Sat, 07 Nov 2020 01:35:45 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/startup-signalr/guild_2_issue_token/</guid>
      <description>SignalR驗證方式 SignalR 的授權可以選擇使用 Cookie 或 Bearer Token：
 Cookie: 驗證方法與一般網頁別無二致，較容易實作但缺點是只能用於瀏覽器(browser-specific)。 Bearer Token 可通用於網頁和 App (或提供任何應用程式)，使用 Token 做登入能夠讓應用程式更容易實作其他使用者端，如果有其他的伺服器簽發 Token，更容易整合至單一登入(Single Sign-On)，也是官方建議使用的方式，以下假設簽發 Token 與 SignalR 伺服器為同一台進行實作。  將 Token 驗證實作至伺服器之前，讓我們先練習實作一支簽發 Token 的 API。
以 Option pattern 取得 JWT 設定 這裡練習 Option pattern，以獲取 appsetting.json 當中 JWT 相關設定的強型別支援：
appsetting.json 將 JWT 相關的設定寫到 appsetting.json 當中： {  &amp;#34;Logging&amp;#34;: {  &amp;#34;LogLevel&amp;#34;: {  &amp;#34;Default&amp;#34;: &amp;#34;Information&amp;#34;,  &amp;#34;Microsoft&amp;#34;: &amp;#34;Warning&amp;#34;,  &amp;#34;Microsoft.Hosting.Lifetime&amp;#34;: &amp;#34;Information&amp;#34;  }  },  &amp;#34;JWT&amp;#34;: {  &amp;#34;Issuer&amp;#34;: &amp;#34;Naxo&amp;#34;,  &amp;#34;Expires&amp;#34;: &amp;#34;1440&amp;#34;, // 憑證有效分鐘數  &amp;#34;SignKey&amp;#34;: &amp;#34;myNameIsTigernaxo,ThisIsMyPersonalBlog&amp;#34; // 設定簽發/解密憑證的對稱式加密金鑰  },  &amp;#34;AllowedHosts&amp;#34;: &amp;#34;*&amp;#34; }</description>
    </item>
    
    <item>
      <title>[SignalR] Websocket 即時聊天程式(一) - 建立專案</title>
      <link>https://tigernaxojr.github.io/blog/posts/netcore31/startup-signalr/guild_1_start/</link>
      <pubDate>Tue, 03 Nov 2020 05:46:45 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/netcore31/startup-signalr/guild_1_start/</guid>
      <description>這個系列會官方文件為主，保留必要的部分，並視情況修改部份程式、添加說明文字。
建立 SignalR 專案 這個範例設定用靜態 html 做前端，這樣之後要做前後端分離也更容易一些，之後會用到 web api 請求登入 Token，所以起始一個 web api 專案：
# 建立專案 dotnet new webapi -o SignalR # 以 VS Code 打開專案 code -r signalr 建立 SignalR 中樞 在.NET Core 3.1 當中使用 SignalR 伺服器端不再需要安裝額外的套件，直接將 SignalR 注入服務容器就能使用， SignalR 的 Hub 中文名稱就叫做中樞，在專案中新增資料夾 Hubs 用來專門存放 Hub 實作類別，並在 Hubs 中新增檔案 ChatHub.cs，內容如下：
using Microsoft.AspNetCore.SignalR; using System.Threading.Tasks;  namespace SignalR.Hubs {  // 這就是所謂的 SignalR 中樞  public class ChatHub : Hub  {  // 這是提供 Client (js)端呼叫的方法，後面是這個方法接受的參數  public async Task SendMessage(string user, string message)  {  // 針對每個以連線的客戶端呼叫 ReceiceMassage 方法，並傳送參數 user、message  await Clients.</description>
    </item>
    
    <item>
      <title>[Linux] CentOS 8 設定網路靜態IP</title>
      <link>https://tigernaxojr.github.io/blog/posts/linux/centos8-static-ip/</link>
      <pubDate>Tue, 16 Jun 2020 09:37:18 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/linux/centos8-static-ip/</guid>
      <description>查詢IP $ ip a1: lo: mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00inet 127.0.0.1/8 scope host lovalid_lft forever preferred_lft foreverinet6 ::1/128 scope hostvalid_lft forever preferred_lft forever2: enp0s3: mtu 1500 qdisc fq_codel state UP group default qlen 1000link/ether 08:00:27:85:fe:50 brd ff:ff:ff:ff:ff:ffinet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute enp0s3valid_lft forever preferred_lft foreverinet6 fe80::98e4:9fbc:ba91:db3f/64 scope link noprefixroutevalid_lft forever preferred_lft forever 修改網路設定 修改網路介面設置如下，檔案名稱預設為ifcfg-網路介面(網路卡)名稱，舉例來說安裝好 CentOS 預設的網路卡 enp0s3 設定檔：/etc/sysconfig/network-scripts/ifcfg-enp0s3</description>
    </item>
    
    <item>
      <title>[Linux] Ubuntu 20.4 以 netplan 設定網路靜態IP</title>
      <link>https://tigernaxojr.github.io/blog/posts/linux/ubuntu204-static-ip/</link>
      <pubDate>Sat, 13 Jun 2020 09:37:18 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/linux/ubuntu204-static-ip/</guid>
      <description>Ubuntu 自 17.10 以後就可以用 netplan 設置網卡~
檢查網路介面 以 ip a 可以看到我的 ubuntu 有2個網路介面分別是 lo、enp0s3，對應到 loopback、有線網卡
$ ip a1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00inet 127.0.0.1/8 scope host lovalid_lft forever preferred_lft foreverinet6 ::1/128 scope host valid_lft forever preferred_lft forever2: enp0s3: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000link/ether 08:00:27:6a:7b:e3 brd ff:ff:ff:ff:ff:ffinet 10.</description>
    </item>
    
    <item>
      <title>[JS] Object 常用方法</title>
      <link>https://tigernaxojr.github.io/blog/posts/javascript/js-obj-func/</link>
      <pubDate>Wed, 20 May 2020 23:31:18 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/javascript/js-obj-func/</guid>
      <description>紀錄常用的 Object 方法，細節可以到MDN看
Object.create  Object.create(proto, [propertiesObject])
 以傳入的參數作為prototype建立一個新物件，這個方法只能複製只帶有 primitive type 無法 deep copy，建立的物件所帶的函式、巢狀物件、Array等等…都和 prototype 共用。
以特定Object 作為 Prototype 建立新物件 const objParent = {  parentFeild: &amp;#39;parent feild&amp;#39;,  parentFunc: function () {  console.log(&amp;#39;This is parent Func&amp;#39;)  },  deepObj: {  a: 1,  b: 2,  }, }  // 以 objParent 作為 prototype 建立 obj 物件 const obj = Object.create(objParent)  // objFeild 只存在 obj 上 obj.</description>
    </item>
    
    <item>
      <title>[JS] JavaScript 當中的原型繼承鏈模型</title>
      <link>https://tigernaxojr.github.io/blog/posts/javascript/js-prototype/</link>
      <pubDate>Wed, 20 May 2020 09:37:18 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/javascript/js-prototype/</guid>
      <description>基於原型 (Prototype-Based) 的 JavaScript 一般物件導向式(OOP; Object Oriented Programming) 程式語言 (如：java、c++、c#) 當中的物件是由類別模板 (class) 產生實體物件 (instance)，實體物件的屬性各自獨立。類別模板上可設置共用的靜態資源包含靜態方法 (static method)、靜態屬性 (static field)，而這些靜態資源可以在沒有建立實體的情況下透過類別名稱直接取用。
JavaScript 中的物件通常隸屬於另一個物件，這種隸屬關係類似物件導向語言的繼承，而在這種關係中的上層物件稱為原型 (Prototype)。原型本身又有自己所屬的原型，這種物件層層繼承的關係稱為原型鏈 (Prototype Chain)，幾乎所有物件的最上層原型是一個構造函數叫做 Object 的物件。
因此一般物件導向式語言稱為基於類別 (Class-Based) 的語言；而 Javascript 是基於原型 (Prototype-Based) 的語言。
建立物件原型 JavaScript 本身沒有類別模板的概念，是以構造函數 (constructor) 建立物件，物件可以將 constructor 屬性指向構造函數，但並非所有物件都有構造函數，具有構造函數的物件可直接以構造函數產生原型鏈下一層物件；不具有構造函數的物件只能在其他物件建立完成後，以其他方式設置為其他物件的原型。
建立原型的方法就是直接宣告一個函數，JavaScript 會自動把該函數作為構造函數，並自動建立一個隸屬於 Object.prototype 之下的匿名物件，並把宣告的函數指定給該匿名物件的 constructor 屬性。
// 宣告一個函數 Foo function Foo (){}  // Foo.prototype 在 Foo 被宣告時自動建立 Foo.prototype // {constructor: ƒ} // Foo.prototype 的 constructor 屬性自動指向 Foo Foo.prototype.constructor === Foo // true 建立物件 透過構造函數 // 建立一個物件 let bar = new Foo{} // {} 直接對變數賦值 JavaScript 對變數賦值底層行為：以 Object 構造函數建立物件，然後對物件並賦值（故賦值發生在物件建立之後）</description>
    </item>
    
    <item>
      <title>[JS] Array 常用方法</title>
      <link>https://tigernaxojr.github.io/blog/posts/javascript/js-arr-func/</link>
      <pubDate>Wed, 29 Apr 2020 23:31:18 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/javascript/js-arr-func/</guid>
      <description>紀錄常用的 Array 方法，細節可以到MDN看
陣列操作 尾端彈出 Array.prototype.pop()、推入 Array.prototype.push()  arr.pop()
arr.push(element1[, &amp;hellip;[, elementN]])
 const arr=[1, 2, 3, 4] arr.pop() console.log(arr) // [1, 2, 3] arr.push(5) console.log(arr) // [1, 2, 3, 5] 首端彈出 Array.prototype.shift()、推入 Array.prototype.unshift()  arr.shift()
arr.unshift(element1[, &amp;hellip;[, elementN]])
 const arr=[1, 2, 3, 4] arr.shift() console.log(arr) // [2, 3, 4] arr.unshift(0) console.log(arr) // [0, 2, 3, 4] 指定位置插入/移除/取代 Array.prototype.splice()  let arrRemoved = arr.splice(start[, deleteCount[, item1[, item2[, &amp;hellip;]]]])
 可以說式集移除、插入、取代(移除+插入)於一身的重要函式，並且將被移除的區段做為新陣列回傳，可根據傳入的參數將使用場景分類如下表，可幫助理解：</description>
    </item>
    
    <item>
      <title>[台灣杉] 一鍵登入國網中心台灣杉(Taiwania)</title>
      <link>https://tigernaxojr.github.io/blog/posts/other/taiwania_login_oneclick/</link>
      <pubDate>Wed, 23 Jan 2019 09:37:18 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/blog/posts/other/taiwania_login_oneclick/</guid>
      <description>台灣杉(Taiwania)是國網中心2018年啟用的超級電腦，登入時密碼必須附加OTP (One-time Password)，國網中心建議取得OTP的方式是從驗證器取得OTP密碼，但這樣的方式每次都需要打開驗證器(手機、chrome插件… etc)，並且需要手動輸入OTP，下面分享我從Windows以及Linux環境下登入台灣杉所使用的一鍵登入方式。
OTP的演算法可粗分為HOTP (HMAC-based OTP)；以及基於HOTP的TOTP (Time-based OTP)，我們不必瞭解演算法細節，只需知道台灣杉採用Base32編碼作為TOTP金鑰(Secret)，時間間格為30秒，每30秒可以根據”Secret”與”當前時間區間”以sha1演算法生成一次性密碼(OTP，或稱為Key)，由於這是單向加密的過程所以無法用時間區間與Key逆推Secret，並且OTP在成功使用一次之後就會被伺服器廢棄，以確保安全性。
注意事項  校時
由於TOTP演算法依據當前時間區間產生OTP，如果作業系統的時間不正確則會產生錯誤的OTP，在Windows環境之下可以到國家時間與頻率標準實驗室的網頁下載NTP校時軟體，以管理員身分執行進行校時；Linux環境可以用下述指令更新時間並寫入BIOS： # 從NTP時間伺服器進行網路校時 sudo ntpdate time.stdtime.gov.tw # 將更新的時間寫入BIOS sudo hwclock -w  所有登入行為之間必須間隔30秒(包含使用winSCP、putty或從Linux直接登入)。 每個30秒區間會產生一個OTP，而該OTP一旦經過使用就會被伺服器廢棄而無法再用。我曾經連續登入以為程式壞了，但核對iService上面產生的密碼又是一樣的，後來才發現這件事…中間還因為連登失敗太頻繁還被鎖，因此記得間隔30秒以上再登入。 Linux要登入台灣衫需要將台灣衫加入know host，以生醫節點為例: ssh-keyscan 140.110.148.14 1&amp;gt;&amp;gt;~/.ssh/known_hosts 2&amp;gt;/dev/null   從Windows登入台灣杉 前置工作  安裝Go，並設置GOPATH。 安裝putty。 安裝WinSCP。 知道怎麼打開windows的命令提示字元 (WIN+R、鍵入cmd、enter)。  編譯TOTP產生器 取得TOTP套件
go get github.com/pquerna/otp/totp 撰寫程式碼main.go
package main  import (  &amp;#34;fmt&amp;#34;  &amp;#34;github.com/pquerna/otp/totp&amp;#34;  &amp;#34;os&amp;#34;  &amp;#34;time&amp;#34; )  func main() {  secret := os.</description>
    </item>
    
    
  </channel>
</rss>
