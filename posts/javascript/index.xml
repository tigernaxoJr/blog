<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Javascript on YuCheng's Site</title><link>https://tigernaxojr.github.io/blog/posts/javascript/</link><description>Recent content in Javascript on YuCheng's Site</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 06 Jun 2023 06:00:00 +0800</lastBuildDate><atom:link href="https://tigernaxojr.github.io/blog/posts/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>[Code] 格式化民國年</title><link>https://tigernaxojr.github.io/blog/posts/javascript/code-roc-format/</link><pubDate>Tue, 06 Jun 2023 06:00:00 +0800</pubDate><guid>https://tigernaxojr.github.io/blog/posts/javascript/code-roc-format/</guid><description>JS 程式碼 import day from &amp;#39;dayjs&amp;#39; const rocyyy = (dt)=&amp;gt;(dt.getFullYear() - 1911).toString().padStart(3, &amp;#39;0&amp;#39;) const prototype = Object.getPrototypeOf(day()) const handler = { get: function (target, prop, receiver) { // age, dte, tme if (prop === &amp;#39;age&amp;#39;) return day().diff(receiver, &amp;#39;years&amp;#39;, false) if (prop === &amp;#39;dte&amp;#39;) return receiver.format(&amp;#39;YYYMMDD&amp;#39;) if (prop === &amp;#39;tme&amp;#39;) return receiver.format(&amp;#39;HHmmss&amp;#39;) // format if (prop === &amp;#39;format&amp;#39;) return (format) =&amp;gt;{ const formattingTokens = /Y{4,}|Y{3}|[^Y{3}]+/g const arr = format.match(formattingTokens) const ktformat = arr .</description></item><item><title>[Tools] 10分鐘建造 proxy 克服跨網域資源存取(CORS)問題</title><link>https://tigernaxojr.github.io/blog/posts/javascript/diy-http-proxy-middleware/</link><pubDate>Sat, 20 Mar 2021 08:45:00 +0800</pubDate><guid>https://tigernaxojr.github.io/blog/posts/javascript/diy-http-proxy-middleware/</guid><description>前後端分離的開發環境以 Ajax 呼叫資源時時會遇到跨網域存取的問題， 一些比較全面的開發環境像是 webpack、vue-cli 等等通常提供內建開發代理伺服器可供設置， 如果要對於不熟悉的開發環境進行快速除錯 (例如 vue 開發者臨時檢查其他框架的程式碼遇到跨網域問題)， 重新研究如何設置開發環境跨網域代理伺服器往往就花費多餘的時間 (不過最終還是要搭建起來阿，喂~~)， 因此紀錄一下怎麼用 node.js 建立一個通用的代理伺服器處理跨網域問題，整個過程不超過5分鐘。
步驟 首先安裝 node.js 建立專案資料夾 建立一個資料夾叫做 proxy 存放這個專案吧，手動建立也可以。
mkdir proxy 起始專案 用指令移動到該專案資料夾下，起始專案：
cd proxy npm init 安裝相依性 npm i express http-proxy-middleware cors 建立 app.js const express = require(&amp;#39;express&amp;#39;); const cors = require(&amp;#39;cors&amp;#39;); const { createProxyMiddleware } = require(&amp;#39;http-proxy-middleware&amp;#39;); // 建立一個 Express 伺服器 const app = express(); app.use(cors()) // 設定 Express 伺服器的 Host、Port const PORT = 3000; const HOST = &amp;#34;localhost&amp;#34;; // 設定代理到 google 的 Proxy 端點 app.</description></item><item><title>[JS] 非同步程式設計-Promise 與 Async/Await</title><link>https://tigernaxojr.github.io/blog/posts/javascript/js-async/</link><pubDate>Sat, 09 Jan 2021 01:32:00 +0800</pubDate><guid>https://tigernaxojr.github.io/blog/posts/javascript/js-async/</guid><description>Promise Promise 狀態 Promise function 執行後會立即回傳一個稱為 Promise 的物件， Promise 本身帶有三種狀態：
pending: 已初始化，但尚未成功或失敗。 fulfilled: 操作成功完成。 rejected: 操作失敗結束。 promise 一但被回傳就處於 pending 狀態， promise 的建構式有兩個參數個接收一個 function，可以操作 Promise 的 fulfilled 和 rejected。
// resolve(value): 放入解析的值 // reject(reson): 放入拒絕的理由 function test(value){ let reason = &amp;#39;找不到 value&amp;#39; return new Promise((resolve, reject)=&amp;gt;{ value ? resolve(value) :reject(reason) }) } 將 Promise 繫結回呼函式 若要將某個程式語句安排在 Promise 被滿足之後執行。 可以利用 Promise.prototype 上的三個物件方法(Instance Method)方法繫結回呼函式(callback function)： then catch finally resolve 會被 then 捕獲，reject 會被最近的 catch 捕獲</description></item><item><title>[JS] 提升(Hoisting)與暫時性死區(Temporal Dead Zone)</title><link>https://tigernaxojr.github.io/blog/posts/javascript/js-hoisting/</link><pubDate>Sat, 09 Jan 2021 01:31:00 +0800</pubDate><guid>https://tigernaxojr.github.io/blog/posts/javascript/js-hoisting/</guid><description>網路上時常見到充滿 function 與 var 的 JavaScript 求值題目， 筆者在釐清 Hoisting 和 TDZ 的觀念前時常覺得答案出乎意料， 雖然現在撰寫程式碼都已經避免使用 var，但是維護 legacy code 還是會用到，因此在這裡做個筆記。
Hoisting 對學過伺服器端語言(C#、C/C++&amp;hellip;)的人來說，預期試圖對未宣告的變數取值會出現 ReferenceError是很正常的事， 在 JavaScript 中也是如此：
console.log(x) // ReferenceError: x is not defined 但 JavaScript 把 var 宣告變數放在後面，x 前面對 x 取值就變成 undefine， 在 JavaScript 當中對變數取值獲得 undefine 代表變數處於宣告後已分配記憶體空間(初始化、initiation)但尚未賦值的狀態， 但是明明 JavaScript 在宣告前就取值，怎麼能夠認得 x、而且知道 x 被初始化為 undefined 呢？
console.log(x) // undefined var x 原因在於 javascript 會先程式中的蒐集 var(let/const/function) 宣告並釐清對應的作用域， 最後再執行程式碼，這個行為就如同宣告被提升(Hoisting)到前面行數的程式碼中一樣。
JavaScript 跟傳統 OOP 語言一樣，在變數提升後、宣告初始化、賦值等等時機取用變數會獲得不同輸出結果， 這篇文章(link)中提到， 稱 JavaScript 為直譯式(解釋型)語言實際上是通俗的說法，語言本身沒有規定實現的方式(編/直譯)， 舉例來說 Chrome 瀏覽器所使用的 Google V8 JavaScript engine， 所帶的解釋器 (interpreter) 會將程式編譯 (compile) 成字節碼 (bytecode)， 最後再由編譯器 (compiler) 即時編譯 (JIT;just-in-time compilation) 編譯成機器碼執行， 而 JavaScript 被編譯時宣告會被蒐集到最頂端進行定義並區分作用域(scope)，這個行為就是 Hoisting ，記住重點在於JS編譯後會先定義變數及區分作用域，編譯後的程式看起來就像這樣：</description></item><item><title>[Code] 複製元件內的文字</title><link>https://tigernaxojr.github.io/blog/posts/javascript/code-copy-html-content/</link><pubDate>Fri, 13 Nov 2020 06:26:00 +0800</pubDate><guid>https://tigernaxojr.github.io/blog/posts/javascript/code-copy-html-content/</guid><description>要在前端用 JavaScript 將 DOM 的內容複製到剪貼簿有幾種姿勢：
Clipboard API 基本上目前(2020年底)，主流瀏覽器近期版本都支援了，如果不考慮 IE 的話倒是可以使用，語法精簡而且能非同步操作。
不支援 IE 是非同步方法，會傳回 Promise 支援從變數直接複製到剪貼簿 只有 HTTPS 網頁可以使用此 API Chrome 66 之後透過 Clipboard 複製已經不會彈出提示視窗 只能在 active tab 發生作用 (a.k.a. 開發者無法在 colsole 做測試，會得到 DOMException: Document is not focused.) function copyText(text) { // 判斷瀏覽器支援 if (!navigator.clipboard) { alert(&amp;#34;瀏覽器不支援 Clipboard API&amp;#34;) // 這裡可以改用 document.execCommand(&amp;#39;copy&amp;#39;) 的方法 } // 非同步複製至剪貼簿 let resolve = () =&amp;gt; { console.log(&amp;#39;透過 Clipboard 複製至剪貼簿成功&amp;#39;); } let reject = (err) =&amp;gt; { console.</description></item><item><title>[DIY] 用Typescript搭建簡易前端路由</title><link>https://tigernaxojr.github.io/blog/posts/javascript/diy-simple-router/</link><pubDate>Fri, 13 Nov 2020 06:26:00 +0800</pubDate><guid>https://tigernaxojr.github.io/blog/posts/javascript/diy-simple-router/</guid><description>起始一個使用 vallina-ts 的 vite 專案並安裝套件，並使用 bootstrap 做簡單的 css 套用：
npm init vite@latest route-test #依序選擇 vallina-&amp;gt;vallina-ts cd route-test npm i # 安裝套件 npm i bootstrap # 安裝 bootstrap 在 index.html 新增元素 app &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/svg+xml&amp;#34; href=&amp;#34;favicon.svg&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;Vite App&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34; class=&amp;#34;container-fluid&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;menu&amp;#34; class=&amp;#34;row g-0&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;root&amp;#34; class=&amp;#34;row g-0&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script type=&amp;#34;module&amp;#34; src=&amp;#34;/src/main.ts&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;</description></item><item><title>[JS] 各種模組(module)</title><link>https://tigernaxojr.github.io/blog/posts/javascript/js-module/</link><pubDate>Fri, 13 Nov 2020 06:26:00 +0800</pubDate><guid>https://tigernaxojr.github.io/blog/posts/javascript/js-module/</guid><description>JS模組規範有很多：AMD、UMD、CMD、commonJS、ES6 module
Reference JS模組規範：AMD、UMD、CMD、commonJS、ES6 module</description></item><item><title>[JS] Object 常用方法</title><link>https://tigernaxojr.github.io/blog/posts/javascript/js-obj-func/</link><pubDate>Wed, 20 May 2020 23:31:18 +0800</pubDate><guid>https://tigernaxojr.github.io/blog/posts/javascript/js-obj-func/</guid><description>紀錄常用的 Object 方法，細節可以到MDN看
Object.create Object.create(proto, [propertiesObject])
以傳入的參數作為prototype建立一個新物件，這個方法只能複製只帶有 primitive type 無法 deep copy，建立的物件所帶的函式、巢狀物件、Array等等…都和 prototype 共用。
以特定Object 作為 Prototype 建立新物件 const objParent = { parentFeild: &amp;#39;parent feild&amp;#39;, parentFunc: function () { console.log(&amp;#39;This is parent Func&amp;#39;) }, deepObj: { a: 1, b: 2, }, } // 以 objParent 作為 prototype 建立 obj 物件 const obj = Object.create(objParent) // objFeild 只存在 obj 上 obj.objFeild = &amp;#39;obj feild&amp;#39; // 可從建立的 obj 呼叫 prototype 的屬性, 方法 obj.</description></item><item><title>[JS] JavaScript 當中的原型繼承鏈模型</title><link>https://tigernaxojr.github.io/blog/posts/javascript/js-prototype/</link><pubDate>Wed, 20 May 2020 09:37:18 +0800</pubDate><guid>https://tigernaxojr.github.io/blog/posts/javascript/js-prototype/</guid><description>基於原型 (Prototype-Based) 的 JavaScript 一般物件導向式(OOP; Object Oriented Programming) 程式語言 (如：java、c++、c#) 當中的物件是由類別模板 (class) 產生實體物件 (instance)，實體物件的屬性各自獨立。類別模板上可設置共用的靜態資源包含靜態方法 (static method)、靜態屬性 (static field)，而這些靜態資源可以在沒有建立實體的情況下透過類別名稱直接取用。
JavaScript 中的物件通常隸屬於另一個物件，這種隸屬關係類似物件導向語言的繼承，而在這種關係中的上層物件稱為原型 (Prototype)。原型本身又有自己所屬的原型，這種物件層層繼承的關係稱為原型鏈 (Prototype Chain)，幾乎所有物件的最上層原型是一個構造函數叫做 Object 的物件。
因此一般物件導向式語言稱為基於類別 (Class-Based) 的語言；而 Javascript 是基於原型 (Prototype-Based) 的語言。
建立物件原型 JavaScript 本身沒有類別模板的概念，是以構造函數 (constructor) 建立物件，物件可以將 constructor 屬性指向構造函數，但並非所有物件都有構造函數，具有構造函數的物件可直接以構造函數產生原型鏈下一層物件；不具有構造函數的物件只能在其他物件建立完成後，以其他方式設置為其他物件的原型。
建立原型的方法就是直接宣告一個函數，JavaScript 會自動把該函數作為構造函數，並自動建立一個隸屬於 Object.prototype 之下的匿名物件，並把宣告的函數指定給該匿名物件的 constructor 屬性。
// 宣告一個函數 Foo function Foo (){} // Foo.prototype 在 Foo 被宣告時自動建立 Foo.prototype // {constructor: ƒ} // Foo.prototype 的 constructor 屬性自動指向 Foo Foo.prototype.constructor === Foo // true 建立物件 透過構造函數 // 建立一個物件 let bar = new Foo{} // {} 直接對變數賦值 JavaScript 對變數賦值底層行為：以 Object 構造函數建立物件，然後對物件並賦值（故賦值發生在物件建立之後）</description></item><item><title>[JS] Array 常用方法</title><link>https://tigernaxojr.github.io/blog/posts/javascript/js-arr-func/</link><pubDate>Wed, 29 Apr 2020 23:31:18 +0800</pubDate><guid>https://tigernaxojr.github.io/blog/posts/javascript/js-arr-func/</guid><description>紀錄常用的 Array 方法，細節可以到MDN看
陣列操作 尾端彈出 Array.prototype.pop()、推入 Array.prototype.push() arr.pop()
arr.push(element1[, &amp;hellip;[, elementN]])
const arr=[1, 2, 3, 4] arr.pop() console.log(arr) // [1, 2, 3] arr.push(5) console.log(arr) // [1, 2, 3, 5] 首端彈出 Array.prototype.shift()、推入 Array.prototype.unshift() arr.shift()
arr.unshift(element1[, &amp;hellip;[, elementN]])
const arr=[1, 2, 3, 4] arr.shift() console.log(arr) // [2, 3, 4] arr.unshift(0) console.log(arr) // [0, 2, 3, 4] 指定位置插入/移除/取代 Array.prototype.splice() let arrRemoved = arr.splice(start[, deleteCount[, item1[, item2[, &amp;hellip;]]]])
可以說式集移除、插入、取代(移除+插入)於一身的重要函式，並且將被移除的區段做為新陣列回傳，可根據傳入的參數將使用場景分類如下表，可幫助理解：
添加item 不添加item deleteCount=0 在現有位置添加元素 (無意義) deleteCount&amp;gt;0 取代現有元素 範圍移除元素 範圍移除元素 const arr=[0, 1, 2, 3, 4, 5, 6] // 移除索引位置3的元素，移除範圍為1 let removed = arr.</description></item></channel></rss>