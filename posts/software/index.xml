<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>[架構] Architecture on YuCheng's Site</title><link>https://blog.tigernaxo.com/posts/software/</link><description>Recent content in [架構] Architecture on YuCheng's Site</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 10 Jun 2025 10:34:00 +0800</lastBuildDate><atom:link href="https://blog.tigernaxo.com/posts/software/index.xml" rel="self" type="application/rss+xml"/><item><title>[開發] API-first approach</title><link>https://blog.tigernaxo.com/posts/software/dev-api-first/</link><pubDate>Tue, 10 Jun 2025 10:34:00 +0800</pubDate><guid>https://blog.tigernaxo.com/posts/software/dev-api-first/</guid><description>&lt;h2 id="高效協作的基石深入理解-api-first-開發方法">高效協作的基石：深入理解 API-First 開發方法&lt;/h2>
&lt;p>在現代軟體開發的浪潮中，追求更快的交付速度、更敏捷的反應能力，以及更優質的使用者體驗，是所有團隊的共同目標。傳統的瀑布式開發流程，因其僵化和漫長的等待週期，已逐漸無法滿足市場的快速變化。為此，「API-First」開發方法應運而生，它不僅僅是一種技術實踐，更是一種推動團隊高效協作的開發哲學。&lt;/p>
&lt;p>本文將深入探討 API-First 的核心概念，比較其與傳統開發流程的差異，分析其優劣，並提供在前端專案中實踐 API Mock 的具體教學。&lt;/p>
&lt;h3 id="什麼是-api-first-approach">什麼是 API-First Approach？&lt;/h3>
&lt;p>&lt;strong>API-First (API 優先)&lt;/strong> 是一種軟體開發策略，其核心精神是&lt;strong>將 API (應用程式介面) 視為整個產品的核心與一等公民 (First-class Citizen)。&lt;/strong>&lt;/p>
&lt;p>在開發啟動之初，不再是先設計資料庫或撰寫後端邏輯，而是由前後端團隊，甚至包含產品、設計團隊，共同協商並定義出一份清晰、嚴謹的 &lt;strong>API 契約 (API Contract)&lt;/strong>。這份契約詳細描述了 API 的路由、請求方法、參數、數據格式以及回傳的響應內容。&lt;/p>
&lt;p>這份契約一旦確立，就成為前後端各自開發的共同依據。後端團隊依照契約實作業務邏輯與資料庫；前端團隊則可以立即使用這份契約，搭配 Mock (模擬) 技術來打造使用者介面，無需等待後端 API 的實際完成。&lt;/p>
&lt;p>最常用來定義 API 契約的工具是 &lt;strong>OpenAPI 規範 (前身為 Swagger)&lt;/strong>。它提供了一套標準化的格式 (通常是 YAML 或 JSON)，讓人類和機器都能輕鬆理解 API 的功能與結構。&lt;/p>
&lt;blockquote>
&lt;p>核心理念： 先定義好軟體元件之間如何溝通 (API)，再各自實現內部邏輯。&lt;/p>&lt;/blockquote>
&lt;h2 id="典範轉移api-first-vs-傳統開發流程">典範轉移：API-First vs. 傳統開發流程&lt;/h2>
&lt;p>為了更清晰地理解 API-First 帶來的變革，我們從幾個關鍵維度來比較它與傳統開發流程的差異。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>比較維度&lt;/th>
&lt;th>傳統開發流程 (Database-First)&lt;/th>
&lt;th>API-First 開發流程&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>開發啟動點&lt;/strong>&lt;/td>
&lt;td>&lt;strong>資料庫先行&lt;/strong>：設計資料庫結構 -&amp;gt; 開發後端 API -&amp;gt; 前端串接。&lt;/td>
&lt;td>&lt;strong>契約先行&lt;/strong>：前後端共同定義 API 契約。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>團隊依賴性&lt;/strong>&lt;/td>
&lt;td>&lt;strong>強烈的上下游依賴&lt;/strong>：前端強烈依賴後端，後端依賴資料庫設計。任何上游變動都會造成下游阻塞。&lt;/td>
&lt;td>&lt;strong>並行開發&lt;/strong>：前後端解耦，可同時進行開發。前端依賴的是「契約」，而非「已完成的後端程式」。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>前後端溝通&lt;/strong>&lt;/td>
&lt;td>&lt;strong>後端主導&lt;/strong>：後端開發完 API 後，提供給前端使用，前端常處於被動接收的角色。溝通多發生在整合階段。&lt;/td>
&lt;td>&lt;strong>協同合作&lt;/strong>：開發初期就共同協商 API 規格。前端甚至能主導介面規格，因為他們最了解介面需要什麼資料。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>迭代速度&lt;/strong>&lt;/td>
&lt;td>&lt;strong>緩慢且僵化&lt;/strong>：任何需求變更都可能需要從資料庫層級開始修改，牽一髮動全身，迭代週期長。&lt;/td>
&lt;td>&lt;strong>快速且敏捷&lt;/strong>：前端可以基於 Mock 數據快速迭代 UI/UX，不受後端進度限制，非常適合敏捷開發中的快速原型和頻繁調整。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>錯誤發現時機&lt;/strong>&lt;/td>
&lt;td>&lt;strong>後期整合階段&lt;/strong>：許多介面不匹配、資料格式錯誤的問題，直到最後整合測試時才會浮現，修復成本高。&lt;/td>
&lt;td>&lt;strong>開發初期&lt;/strong>：由於 API 契約先行，規格不一致的問題在設計階段就被解決。介面和使用者體驗問題也能在早期透過原型被發現。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="api-first-的優點與挑戰">API-First 的優點與挑戰&lt;/h2>
&lt;p>採用 API-First 方法能帶來顯著的好處，但同時也伴隨著一些需要克服的挑戰。&lt;/p></description></item><item><title>[Program] 比較 Method chaining、fluent interface、c# 擴充方法</title><link>https://blog.tigernaxo.com/posts/software/pg-method-chaining/</link><pubDate>Sat, 22 Apr 2023 20:58:00 +0800</pubDate><guid>https://blog.tigernaxo.com/posts/software/pg-method-chaining/</guid><description>&lt;p>Method chaining、Fluent interface 和 擴充方法(Extension method) 三種雖然相似，但實則為不同的程式設計概念。&lt;/p>
&lt;h2 id="method-chaining">Method chaining&lt;/h2>
&lt;p>Method chaining 是一種技術，允許在一行程式碼中調用對象的一系列方法。鏈中的每個方法都返回被調用的對象，從而允許在同一個對象上調用下一個方法。這種技術用於創建更可讀和簡潔的代碼。&lt;/p>
&lt;h2 id="fluent-interface">Fluent interface&lt;/h2>
&lt;p>Fluent interface 是一種設計模式，使用方法串鏈創建更具表現力和可讀性的API。
Fluent interface 的目標是使代碼看起來更像自然語言，使其更容易理解和使用。
在 Fluent interface 中，每個方法調用返回一個對象，允許在同一個對象上調用下一個方法。這種技術通常用於庫和框架中，以為開發人員提供更直觀和自然的API。&lt;/p>
&lt;h2 id="擴充方法">擴充方法&lt;/h2>
&lt;p>擴充方法是一種在不修改類本身的情況下為現有類添加功能的方法。擴充方法在單獨的靜態類中定義，並像擴展類的方法一樣調用。這允許開發人員在不修改源代碼的情況下為現有類添加功能。擴充方法通常用於為現有類添加實用函數或為無法修改的類（例如第三方庫）添加功能。&lt;/p>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://www.thinkinmd.com/post/2020/03/02/coding-style-of-fluent-interface/" target="_blank" rel="noopener">Fluent Interface｜一種程式碼”寫作”風格&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/extension-methods" target="_blank" rel="noopener">擴充方法 (C# 程式設計手冊)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Method_chaining" target="_blank" rel="noopener">wiki-Method chaining&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>[架構] 多層式架構(Multi-layer Architecture)</title><link>https://blog.tigernaxo.com/posts/software/arch-multi-layer/</link><pubDate>Tue, 28 Mar 2023 23:34:00 +0800</pubDate><guid>https://blog.tigernaxo.com/posts/software/arch-multi-layer/</guid><description>&lt;p>中文多層架構的層可翻作 layer 或 tier，兩者主要的差別在於 layer 指程式邏輯在應用程式的位置；而 tier 指 layer 在系統上實際部屬執行的位址，屬於物理層級的指涉。這一篇的層說的是 layer，談如何在軟體層面利用分層 (layer) 妥善安排程式碼，以 multi-layer 撰寫程式碼能將複雜的邏輯隔離開達成關注點分離(SoC, Separation of concerns)，好處有：&lt;/p>
&lt;ul>
&lt;li>降低耦合：程式拆成各司其職的單元，降低彼此耦合，增加程式單元彈性(擴展性)、複用性。&lt;/li>
&lt;li>易於維護：多層式架構中程式碼各司其職，容易定位問題發生點、而非從整個應用程式邏輯找。&lt;/li>
&lt;li>敏捷開發：程式可快速回應需求修改(理由與易於維護類似，但是在開發時獲得的好處)。&lt;/li>
&lt;li>平行開發：解耦的程式有助於降低協作併版衝突。&lt;/li>
&lt;/ul>
&lt;h1 id="分層">分層&lt;/h1>
&lt;h2 id="三層式架構">三層式架構&lt;/h2>
&lt;p>一般來說最常用的三層式架構組成為：&lt;/p>
&lt;ul>
&lt;li>表現層 (PL; Presentation Layer)：ASP 內就是 Controller 結尾。&lt;/li>
&lt;li>商業邏輯繩 (BLL; Business Logic Layer)：又稱為 Service Layer，命名習慣是 Service、Helper 結尾。&lt;/li>
&lt;li>資料存取層(DAL; Data Access Layer)：命名習慣是 Repo 結尾。&lt;/li>
&lt;/ul>
&lt;p>另外有人將 Domain、Common 稱為一層，但這個部分其實不太像層，因為會被每一層引用，在架構上呈現比較不像層那樣扁平，裡面包含：
Model、Entity、DTO(Data transfer object) 或 Value Object，這裡只有屬性沒有方法。&lt;/p>
&lt;h2 id="四層式架構">四層式架構&lt;/h2>
&lt;p>為了降低 PL 與 BL 之間的耦合，有時會在 Business Logic Layer(BLL) 上再疊一層 Service Layer(SL)，作為 Presentation Layer 與 Business Layer 的中介層，這時 Business Logic Layer 的命名就不以 Serviece 結尾，通常較大型專案才需要如此分法。&lt;br>
而 SL 和 BLL 的差別在於商業邏輯精細度，一個SL操作 (coarse-grained operation) 通常包含複數BL操作 (fine-grained operation)。&lt;/p></description></item><item><title>[架構] 無暇的程式碼-讀書心得</title><link>https://blog.tigernaxo.com/posts/software/arch-clean-arch-review/</link><pubDate>Mon, 12 Dec 2022 10:57:00 +0800</pubDate><guid>https://blog.tigernaxo.com/posts/software/arch-clean-arch-review/</guid><description>&lt;h2 id="軟體系統價值">軟體系統價值&lt;/h2>
&lt;p>行為價值、架構價值&lt;/p>
&lt;h3 id="行為價值">行為價值&lt;/h3>
&lt;p>工程師的首要責任
需求實現、可用性保障(功能性 Bug、性能、穩定性)
業務明確、穩定的前提下，可忽略架構價值&lt;/p>
&lt;h3 id="架構價值">架構價值&lt;/h3>
&lt;p>更容易適應:需求變更。
變更實作難度和變更的範圍成正比、跟變更的具體形狀無關。 ??
業務需求通常不明確、時常變動，因此架構非常重要。
不關注架構價值會隨著版本迭代、變更每一行程式成本升高，因此投入的人力成本增加。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/65658089" target="_blank" rel="noopener">知乎-架构整洁之道, 看这一篇就够了！&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://alitech-public.oss-cn-beijing.aliyuncs.com/1557040476898/jiagouzhengjie-siweidaotu.png" target="_blank" rel="noopener">架构整洁之道超詳細關係圖&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>[Program] 巢狀結構</title><link>https://blog.tigernaxo.com/posts/software/quality-nest/</link><pubDate>Sun, 11 Dec 2022 02:19:00 +0800</pubDate><guid>https://blog.tigernaxo.com/posts/software/quality-nest/</guid><description>&lt;p>巢狀程式結構會使程式可讀性差、且難以維護，可讀性高的程式碼深度最多不超過三層，嚴格管控程式碼深度的程式設計師又稱為 Never Nester。&lt;/p>
&lt;h2 id="消除巢狀程式手法">消除巢狀程式手法：&lt;/h2>
&lt;ul>
&lt;li>Extraction&lt;/li>
&lt;li>Inversion&lt;/li>
&lt;li>依據契約式程式設計，移除不必要判斷&lt;/li>
&lt;/ul>
&lt;h3 id="extraction">Extraction&lt;/h3>
&lt;p>從複查的結構抽出程式碼&lt;/p>
&lt;h3 id="inversion">Inversion&lt;/h3>
&lt;p>把跳出函式的判斷移動到最上面&lt;/p>
&lt;h3 id="依據契約式程式設計移除不必要判斷">依據契約式程式設計，移除不必要判斷&lt;/h3>
&lt;p>依據契約式程式設計，以程式碼使用者會傳入的參數合法性為前提，移除不必要判斷&lt;/p></description></item><item><title>[架構] 多層式架構(Multitier Architecture)</title><link>https://blog.tigernaxo.com/posts/software/arch-n-tier/</link><pubDate>Mon, 17 May 2021 23:20:00 +0800</pubDate><guid>https://blog.tigernaxo.com/posts/software/arch-n-tier/</guid><description>&lt;p>多層式架構 Multitier Architecture 或稱 N-Tier Architecture，
是 Client–server architecture 的一種，
多層架構的層可以是 layer 或 tier，這兩者之間主要的差別在於 layer 指程式邏輯在應用程式的位置；
而 tier 指 layer 在系統上實際部屬執行的位址，屬於物理層級的指涉。
這一篇的層指的是 tier。&lt;/p>
&lt;h1 id="n-tier-model">N-tier model&lt;/h1>
&lt;p>N-tier model，層與層之間的邊界有 N-1 個，而程式跨邊界會造成巨大的效能損失，
一說為光是跨越同一台機器上不同進程(process)邊界存取資源損失就大約1000倍，
如果透過網路進行遠端呼叫勢必損失更多，
因此每跨越一個邊界進行資源存取效能就會以幾何級數損失。
且增加邊界在軟體設計上會增加複雜度，簡單的應用程式使用多層式架構很容易造成過度設計(over design)，
因此如何適當添加層級(tier)也是一門學問，添加層級時必需考量如何在應用程式所部屬的環境獲取最大的成本效益。
軟體是否採用多層式架構必須以多層式架構的優缺點進行取捨(尤其是可擴展性與效能之間)。&lt;/p>
&lt;ul>
&lt;li>提高可擴展性(scalability)。&lt;/li>
&lt;li>提高效能(performance)。&lt;/li>
&lt;li>提高容錯率(fault tolerance)。&lt;/li>
&lt;li>提高安全性(security)。&lt;/li>
&lt;/ul>
&lt;h2 id="1-tier-model">1-tier model&lt;/h2>
&lt;p>所有的 layer 都在同一機器、同一記憶體空間內運行，因此不需考慮網路造成的性能損失。&lt;/p>
&lt;h2 id="2-tier-model">2-tier model&lt;/h2>
&lt;p>layer 分配至兩個不同的記憶體空間運行，記憶體空間可能位於相同或兩台不同的機器上(通常是不同機器)，典型的例子是分配到 client、server 上運行。&lt;/p>
&lt;h2 id="3-tier-model">3-tier model&lt;/h2>
&lt;p>多層式架構當中最常使用的就是三層架構(three-tier architecture)。
三層架構與Web應用程式來說明如下：&lt;/p>
&lt;ul>
&lt;li>表現層(Presentation)：又稱為 UI 層，以Web來說就是呈現出來的前端網頁。&lt;/li>
&lt;li>應用程式層(Application)：以 Web 來說相當於伺服器上執行的應用程式。&lt;/li>
&lt;li>資料層(Data)：這一層包含資料儲存、呈現機制，以 Web 來說通常指 Database。&lt;/li>
&lt;/ul>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Multitier_architecture" target="_blank" rel="noopener">wikipedia - Multitier architecture&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.lhotka.net/weblog/ShouldAllAppsBeNtier.aspx" target="_blank" rel="noopener">Rockford Lhotka - Should all apps be n-tier?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.guru99.com/n-tier-architecture-system-concepts-tips.html" target="_blank" rel="noopener">N Tier(Multi-Tier), 3-Tier, 2-Tier Architecture with EXAMPLE&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>