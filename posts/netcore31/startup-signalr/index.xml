<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>[後端] 即時聊天專案 on YuCheng&#39;s Site</title>
    <link>https://tigernaxojr.github.io/posts/netcore31/startup-signalr/</link>
    <description>Recent content in [後端] 即時聊天專案 on YuCheng&#39;s Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 20 Nov 2020 22:44:00 +0800</lastBuildDate><atom:link href="https://tigernaxojr.github.io/posts/netcore31/startup-signalr/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>[SignalR] Websocket 即時聊天程式(三) - 後端 Token 認證</title>
      <link>https://tigernaxojr.github.io/posts/netcore31/startup-signalr/guild_3_validate_token/</link>
      <pubDate>Fri, 20 Nov 2020 22:44:00 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/posts/netcore31/startup-signalr/guild_3_validate_token/</guid>
      <description>安裝套件 要進行 Token 的認證，需要先安裝 Microsoft.AspNetCore.Authentication.JwtBearer 套件：
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer 註冊認證服務 新增一個檔案 DependencyInjection.cs，在當中製作 IServiceCollection 的擴充方法來自定義 JWT token 認證服務， 在裡面設置 Token 的認證規則、使用者識別碼對應、使用者群組對應， 而 SignalR 抓取使用者識別碼 (UserIdentifier) 的介面方法是 IUserIdProvider.GetUserId， 因此我們需要另外新增一個實作 IUserProvider 的類別注入服務容器給 SignalR 使用 ，該檔案程式碼如下：
using Microsoft.AspNetCore.Authentication.JwtBearer; using Microsoft.AspNetCore.SignalR; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; using Microsoft.IdentityModel.Tokens; using System.Diagnostics.CodeAnalysis; using System.IdentityModel.Tokens.Jwt; using System.Linq; using System.Threading.Tasks;  namespace SignalR.Extensions.DependencyInjection {  public static class MyAddConfig  {  public static IServiceCollection AddMyJWTAuth( [NotNull] this IServiceCollection services,  IConfiguration config  )  {   services.</description>
    </item>
    
    <item>
      <title>[SignalR] Websocket 即時聊天程式(四) - 前端登入頁面</title>
      <link>https://tigernaxojr.github.io/posts/netcore31/startup-signalr/guild_4_front_end_login/</link>
      <pubDate>Tue, 10 Nov 2020 05:05:45 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/posts/netcore31/startup-signalr/guild_4_front_end_login/</guid>
      <description>安裝 axios SignalR 連線驗證的方式是將 token 夾帶於網址參數中發送到伺服器，因此進行 websocket 連線前我們透過 ajax 向伺服器發送帳號密碼索取登入的 Token，我們安裝方便使用 ajax 的 axios 函式庫：
axios 一樣可以透過 LibMan 安裝~
libman install axios@latest \  -p unpkg \  -d wwwroot/js/axios \  --files dist/axios.min.js 在 wwwRoot/index.html 添加對 axios 的引用：
&amp;lt;script src=&amp;#34;./lib/axios/dist/axios.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 簡易登入UI 雖然是功能原型，為了讓做出來的頁面不要太粗暴，拿 bootstrap 的 css 來套用一下 UI：
libman install bootstrap@5.0.0-alpha2 \  -p unpkg \  -d wwwroot/lib/bootstrap \  --files dist/js/bootstrap.min.js \  --files dist/css/bootstrap.min.css 在 wwwRoot/index.html 添加對 bootstrap css 的引用：</description>
    </item>
    
    <item>
      <title>[SignalR] Websocket 即時聊天程式(二) - 後端 Token 授權</title>
      <link>https://tigernaxojr.github.io/posts/netcore31/startup-signalr/guild_2_issue_token/</link>
      <pubDate>Sat, 07 Nov 2020 01:35:45 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/posts/netcore31/startup-signalr/guild_2_issue_token/</guid>
      <description>SignalR驗證方式 SignalR 的授權可以選擇使用 Cookie 或 Bearer Token：
 Cookie: 驗證方法與一般網頁別無二致，較容易實作但缺點是只能用於瀏覽器(browser-specific)。 Bearer Token 可通用於網頁和 App (或提供任何應用程式)，使用 Token 做登入能夠讓應用程式更容易實作其他使用者端，如果有其他的伺服器簽發 Token，更容易整合至單一登入(Single Sign-On)，也是官方建議使用的方式，以下假設簽發 Token 與 SignalR 伺服器為同一台進行實作。  將 Token 驗證實作至伺服器之前，讓我們先練習實作一支簽發 Token 的 API。
以 Option pattern 取得 JWT 設定 這裡練習 Option pattern，以獲取 appsetting.json 當中 JWT 相關設定的強型別支援：
appsetting.json 將 JWT 相關的設定寫到 appsetting.json 當中： {  &amp;#34;Logging&amp;#34;: {  &amp;#34;LogLevel&amp;#34;: {  &amp;#34;Default&amp;#34;: &amp;#34;Information&amp;#34;,  &amp;#34;Microsoft&amp;#34;: &amp;#34;Warning&amp;#34;,  &amp;#34;Microsoft.Hosting.Lifetime&amp;#34;: &amp;#34;Information&amp;#34;  }  },  &amp;#34;JWT&amp;#34;: {  &amp;#34;Issuer&amp;#34;: &amp;#34;Naxo&amp;#34;,  &amp;#34;Expires&amp;#34;: &amp;#34;1440&amp;#34;, // 憑證有效分鐘數  &amp;#34;SignKey&amp;#34;: &amp;#34;myNameIsTigernaxo,ThisIsMyPersonalBlog&amp;#34; // 設定簽發/解密憑證的對稱式加密金鑰  },  &amp;#34;AllowedHosts&amp;#34;: &amp;#34;*&amp;#34; }</description>
    </item>
    
    <item>
      <title>[SignalR] Websocket 即時聊天程式(一) - 建立專案</title>
      <link>https://tigernaxojr.github.io/posts/netcore31/startup-signalr/guild_1_start/</link>
      <pubDate>Tue, 03 Nov 2020 05:46:45 +0800</pubDate>
      
      <guid>https://tigernaxojr.github.io/posts/netcore31/startup-signalr/guild_1_start/</guid>
      <description>這個系列會官方文件為主，保留必要的部分，並視情況修改部份程式、添加說明文字。
建立 SignalR 專案 這個範例設定用靜態 html 做前端，這樣之後要做前後端分離也更容易一些，之後會用到 web api 請求登入 Token，所以起始一個 web api 專案：
# 建立專案 dotnet new webapi -o SignalR # 以 VS Code 打開專案 code -r signalr 建立 SignalR 中樞 在.NET Core 3.1 當中使用 SignalR 伺服器端不再需要安裝額外的套件，直接將 SignalR 注入服務容器就能使用， SignalR 的 Hub 中文名稱就叫做中樞，在專案中新增資料夾 Hubs 用來專門存放 Hub 實作類別，並在 Hubs 中新增檔案 ChatHub.cs，內容如下：
using Microsoft.AspNetCore.SignalR; using System.Threading.Tasks;  namespace SignalR.Hubs {  // 這就是所謂的 SignalR 中樞  public class ChatHub : Hub  {  // 這是提供 Client (js)端呼叫的方法，後面是這個方法接受的參數  public async Task SendMessage(string user, string message)  {  // 針對每個以連線的客戶端呼叫 ReceiceMassage 方法，並傳送參數 user、message  await Clients.</description>
    </item>
    
    
  </channel>
</rss>
